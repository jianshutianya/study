

 第一阶段课程内容共19天
 云计算系统管理、 云计算应用管理、系统&服务管理进阶

 云计算系统管理	
	DAY01	开学典礼、云网络基础			
   	DAY02	Linux系统简介、安装Linux系统、Linux基本操作		
	DAY03	命令行基础、目录和文件管理			
	DAY04	管理用户和组、tar备份与恢复、cron计划任务		
	DAY05	教学环境介绍、权限和归属			
	DAY06	软件包管理、分区规划及使用、NTP时间同步	
	DAY07	LVM逻辑卷、综合串讲、综合练习		

		
 云计算应用管理	
	DAY01	Shell脚本基础、使用变量、条件测试及选择、列表式循环
	DAY02	系统安全保护、配置用户环境、防火墙策略管理			
	DAY03	ISCSI共享存储、数据库服务基础、管理表数据	
	DAY04	配置NFS共享、HTTP服务基础		
	DAY05	网页内容访问、部署动态网站	、安全Web服务	
	DAY06	综合串讲、综合练习		


 系统&服务管理进阶	
	DAY01	扩展的几个应用、发布网络YUM源、vim编辑技巧、源码编译安装	
	DAY02	KVM构建及管理、virsh控制工具、镜像管理、虚拟机快建技术
	DAY03	DNS服务基础、特殊解析、DNS子域授权、缓存DNS
	DAY04	Split分离解析、RAID磁盘阵列、进程管理、日志管理、systemctl控制
	DAY05	批量装机环境、配置PXE引导、kickstart自动应答	
	DAY06	rsync同步操作、inotify实时同步、Cobbler网络装机		
			
##################################################################################################

  准备笔记本与笔（默写），U盘（后期存储备份教学数据）
  先讲解后练习，勤奋的练习



##################################################################
一 教学环境
1.真机是Linux   账户:student  密码: 
      
2.虚拟化软件: 虚拟众多的硬件
      虚拟机被损坏,与真机无关


########################################
典型服务模式
• C/S,Client/Server架构
– 由服务器提供资源或某种功能
– 客户机使用资源或功能

##############################################
TCP/IP协议简介
• TCP/IP是最广泛支持的通信协议集合
 – 包括大量Internet应用中的标准协议
 – 支持跨网络架构、跨操作系统平台的通信

• 主机与主机之间通信的三个要素　　　　　
 – IP地址(IP address)
  – 子网掩码(subnet mask)
 – IP路由(IP router):涉及路由器

#################################################
IP地址(IP address):唯一标识网络中一个节点地址
• 地址组成(点分十进制):
– 一共32个二进制数
　11110000.00001111.10101010.11111100

   00000000.00000000.00000000.00000000
   11111111.11111111.11111111.11111111

　　 11111111 = 255

  例子： 　1.2.3.4   192.168.1.1    10.11.12.13

#################################################

为虚拟机win2008配置IP地址
利用管理员进行登录，密码为：tedu


配置IP地址：　　192.168.1.1　　子网掩码：255.255.255.0
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 属性
– 双击“Internet协议版本4(TCP/IPv4)”　　　
– 配置完成后,单击“确定”完成

查看IP地址：　
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 详细信息

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

################################################
• IP地址的分类
– A类:1 ~ 127       　网+主+主+主
– B类:128 ~ 191  　 网+网+主+主
– C类:192 ~ 223   　网+网+网+主

• 组播及科研专用
– D类:224 ~ 239 组播
– E类:240 ~ 254 科研


   192.168.1.1=只看ip地址的第一个数字,进行判别分类


################################################
IP地址由网络位与主机位，两部来组成
 网络位=座机号码的区号，标识一个网络
 主机位=编号

子网掩码：用来区分IP地址的网络位与主机位
　　　　　利用二进制的１标识网络位
　　　　　利用二进制的0标识主机位
　192.168.1.1＝11000000.10101000.00000001.00000001
                        11111111.11111111.11111111.00000000
                         255.255.255.0

　座机号码：区号－号码（编号）
　　北京：010－12345678＝北京区域，编号为12345678的座机
　　石家庄：0311－7354444＝石家庄区域,编号为7354444的座机

　区号：标识区域

　192.168.1.1　＝　192.168.1网络，编号为１的主机
　192.168.１.2　＝　192.168.１网络，编号为２的主机
　相同网络通信，网络位相同

　192.168.1.1  255.255.255.0 = 192.168.1.1/24

   192.168.1.1/24 :该IP地址有24个网络位

　1.该IP地址是哪一类 　 2.判别网络位与主机位
################################################
克隆虚拟机win2008　　　　　　　　　　
1.双击桌面windows还原,打开桌面虚拟系统管理器,双击win2008,选择查看,详情,把内存4096修改成2048,应用.
2.进行虚拟机克隆
　双击＂虚拟系统管理器＂--＞右击＂win2008＂--＞克隆--＞克隆
3. 配置二台win2008的网络参数
配置win2008的IP地址	192.168.1.10  
			子网掩码	255.255.255.0
			网关		192.168.1.254
			dns		202.106.0.20　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

配置win2008-clone的IP地址：192.168.1.20  
			子网掩码	255.255.255.0
			网关		192.168.1.254
			dns		202.106.0.20　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

################################################
采用命令方式，测试网络联通性：
　　ping　　命令
　　ping   对方IP地址　　　ping命令是双向，有去有回
　　ping 　192.168.1.20　

　　ping 　192.168.1.２　

###############################################
　ftp://172.40.50.114

###############################################
网关地址:一个网络到另一个网络的关口　（解决不同网络通信）

DNS服务器：将网站的域名解析为,对应的IP地址
  
         www.qq.com-------＞腾讯的服务器
         www.baidu.com-------＞百度的服务器

###############################################



		192.168.0.1   255.255.255.0   192.168.0.0		1
		192.168.0.2   255.255.255.0   192.168.0.0		2

		11000000.10101000.00000000.00000001
		11111111.11111111.11111111.00000000
----------------------------------------------------------------------------------
	        11000000.10101000.00000000.00000000 
		192.168.0.0

      10.0.0.1 255.0.0.0 = 10.0.0.1/8
      192.168.20.100 255.255.255.0 = 192.168.20.100/24


• 主机与主机之间通信的三个要素　　　　　
 – IP地址(IP address)
  – 子网掩码(subnet mask)
 – IP路由(IP router):涉及路由器


IP地址(IP address):唯一标识网络中一个节点的地址
子网掩码：用来区分IP地址的网络位与主机位
网关地址:一个网络到另一个网络的关口　（解决不同网络通信）



• IP地址的分类
– A类:1 ~ 127       　网+主+主+主
– B类:128 ~ 191  　 网+网+主+主
– C类:192 ~ 223   　网+网+网+主

• 组播及科研专用
– D类:224 ~ 239 组播
– E类:240 ~ 254 科研

########################################################

linux是操作系统,主要应用在服务器上
硬件是指看得见摸得着的设备

软件:1.系统软件(操作系统) 
     2.应用软件(APP)

linux系统内核官网: www.kemel.org
内科作用:管理CUP/内存、驱动基本硬件、文件系统
版本号:主版本.次版本.修订号 例如 4.8.6

linux目录结构:
最顶层为根目录(/)---unix/Linux的基本哲学理念:一切皆文件

linux命令:
pwd:查看当前目录位置
cd:切换工作目录
cat:查看文件内容
ls:查看目录内容
uname -r:列出内核版本
lscpu:可出cpu处理器信息
cat /proc/meminfo:查看内存大小,空闲 情况
poweroff:关机  init0  shtudown
reboot:重启    init6
mkdir /指定目录/创建的目录 :创建目录
less:分屏阅读
head /文件:默认查看文件头十行   head -n 3 /文件:查看文件头三行
tail /文件:默认尾查看文件十行   tail -n 3 /文件:查看文件尾三行
grep工具:输出包含指定字符串的行
route -n :查看网关信息
nmtui:修改ip地址网卡信息和主机名

########################################################

命令行基础

什么是命令?
• Linux命令
– 用来实现某一类功能的指令或程序
   执行大多数命令,都要找到相应的程序
[root@localhost ~]# ls /usr/bin/hostname
/usr/bin/hostname    #绿色可以执行的程序
[root@localhost ~]# 

– 命令的执行依赖于解释器(默认解释器:/bin/bash)

          用户------->解释器------->内核------->硬件

[root@localhost ~]# cat /etc/shells 
/bin/sh
/bin/bash
/sbin/nologin
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh
[root@localhost ~]#
###################################################
• Linux命令的分类
– 内部命令:属于解释器的一部分
– 外部命令:解释器之外的其他程序

命令行的一般格式
• 基本用法
– 命令字        [选项]...        [参数1]    [参数2]...
    打                                  周老师 .......

查看文本文件内容
[root@localhost ~]# cat   /etc/redhat-release 
[root@localhost ~]# cat --help

[root@localhost ~]# cat -n  /etc/redhat-release 
[root@localhost ~]# cat -n  /etc/passwd

[root@localhost ~]# cat /etc/redhat-release /etc/hosts

[root@localhost ~]# ls /root /boot
[root@localhost ~]# ls --help

################################################
快速编辑技巧
• Tab键自动补全
– 可补齐命令字、选项、参数、文件路径、软件名、服务名

• 快捷键
– Ctrl + l:清空整个屏幕                                    
– Ctrl + c:废弃当前编辑的命令行(结束正在运行的命令)
– Esc + . 或 Alt + .:粘贴上一个命令的参数

[root@localhost ~]# ls /etc/hosts
/etc/hosts
[root@localhost ~]# cat Alt + .

[root@localhost ~]# cat -n Alt + .


– Ctrl + u:清空至行首
– Ctrl + w:往回删除一个单词(以空格界定)

##################################################
mount挂载操作:让目录成为设备的访问点
一  安装软件包,前提需要基本软件安装包

二 从光盘中获得软件包

三  让系统识别光盘内容

Windows系统:
        光盘文件---->光驱设备---->CD驱动器图标(访问点)
Linux系统:
        光盘文件---->光驱设备---->访问点(目录/文件夹)
              /dev/sr0
              /dev/hdc
  一切皆文件

1.图形鼠标将光盘镜像文件放入虚拟光驱设备
2.查看光驱设备
[root@localhost ~]# ls /dev/sr0
/dev/sr0
[root@localhost ~]# ls /dev/cdrom
/dev/cdrom         #青色:代表快捷方式颜色
[root@localhost ~]# 

3.命令行挂载设备
[root@localhost ~]# mkdir /dvd
[root@localhost ~]# ls /dvd
[root@localhost ~]# mount /dev/cdrom  /dvd
mount: /dev/sr0 写保护，将以只读方式挂载
[root@localhost ~]# ls /dvd/

4.卸载
[root@localhost ~]# umount /dvd/
[root@localhost ~]# ls /dvd/
[root@localhost ~]# umount /dvd/
umount: /dvd/：未挂载
[root@localhost ~]# mkdir /nsd1904
[root@localhost ~]# mount /dev/cdrom  /nsd1904
[root@localhost ~]# ls /nsd1904

注意事项:
 1.卸载,当前不要在挂载点(访问点)目录下
[root@localhost dvd]# umount /dvd/
umount: /dvd：目标忙。
        (有些情况下通过 lsof(8) 或 fuser(1) 可以
         找到有关使用该设备的进程的有用信息)
[root@localhost dvd]# 

 2.挂载允许一个设备具备多个挂载点(访问点)
 3.不允许多个设备挂载到一个挂载点(访问点)
 4.强烈建议挂载点(访问点)选择自己创建的目录

##################################################
查看及切换目录

使用pwd、cd
• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd   [目标文件夹位置]

    ~:用户的家目录
  ~user表示用户user的家目录

  /root:管理员的家目录
  /home:存放所有普通用户家目录
[root@localhost ~]# useradd tom   #创建普通用户tom
[root@localhost ~]# cd ~tom
[root@localhost tom]# pwd
/home/tom
[root@localhost tom]# useradd dc  #创建普通用户dc
[root@localhost tom]# cd ~dc
[root@localhost dc]# pwd
/home/dc
[root@localhost dc]# useradd tc   #创建普通用户tc
[root@localhost dc]# cd ~tc
[root@localhost tc]# pwd
/home/tc
[root@localhost tc]# cd ~root    #切换到root用户的家目录
[root@localhost ~]# pwd
####################################################
. 表示当前目录

####################################################
ls 列出文档及属性
• ls — List
– 格式:ls [选项]... [目录或文件名]
• 常用命令选项
– -l:以长格式显示,显示目录内容的详细属性
– -A:包括名称以 . 开头的隐藏文档
– -d:显示目录本身(而不是内容)的属性
– -h:提供易读的容量单位(K、M等)

[root@localhost ~]# ls /root
[root@localhost ~]# ls -l  /root   #显示目录内容的详细属性

[root@localhost ~]# ls -ld /root   #显示目录本身的详细属性
[root@localhost ~]# ls -ld /

[root@localhost ~]# ls -l /dev/cdrom   #显示文件详细属性
[root@localhost ~]# ls -l /etc/passwd
[root@localhost ~]# ls -l /etc/redhat-release

[root@localhost ~]# ls -l /etc/passwd
[root@localhost ~]# ls -lh /etc/passwd

[root@localhost ~]# ls -lh /boot

[root@localhost ~]# ls -A /root
[root@localhost ~]# ls -A /boot

百度搜索 EB容量单位
百度搜索 正则表达式

###################################################

使用通配符
• 针对不确定的文档名称,以特殊字符表示
– *:任意多个任意字符                
– ?:单个字符
[root@localhost ~]# ls /boot/vm*     #以vm开头
[root@localhost ~]# ls /root/a*      #以a开头
[root@localhost ~]# ls /dev/tty*     #以tty开头
 
[root@localhost ~]# ls /etc/*tab     #以tab结尾
[root@localhost ~]# ls /etc/*.conf   #以.conf结尾

[root@localhost ~]# ls /etc/r*.conf   #以r开头并且.conf结尾
[root@localhost ~]# ls /etc/*passwd*

[root@localhost ~]# ls /dev/tty?
[root@localhost ~]# ls /dev/tty??

• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略
– {a,min,xy}:多组不同的字符串,全匹配

[root@localhost ~]# ls /dev/tty[3-8]
[root@localhost ~]# ls /dev/tty[1-9]

[root@localhost ~]# ls /dev/tty{1,3,5,7,9}
[root@localhost ~]# ls /dev/tty{1,3,5,7,9,23}
[root@localhost ~]# ls /dev/tty{1,3,S0,S1}

[root@localhost ~]# ls /dev/tty{1,3,S0,haha}

#################################################
别名的定义:简化复杂命令

• 查看已设置的别名
– alias [别名名称]
• 定义新的别名
– alias 别名名称='实际执行的命令行'
• 取消已设置的别名
– unalias [别名名称]

[root@localhost ~]# hostname
localhost.localdomain
[root@localhost ~]# hn
bash: hn: 未找到命令...
[root@localhost ~]# alias hn='hostname'  #定义别名
[root@localhost ~]# hn                   #运行别名测试

[root@localhost ~]# alias        #查看当前系统有效的别名
[root@localhost ~]# unalias hn   #删除别名
[root@localhost ~]# hn
bash: hn: 未找到命令...
[root@localhost ~]# 
####################################################

mkdir 创建目录
• mkdir — Make Directory
– 格式:mkdir [-p] [/路径/]目录名...
       -p:创建父目录

[root@localhost ~]# mkdir /opt/nsd01
[root@localhost ~]# ls /opt/

[root@localhost ~]# mkdir  /opt/nsd02   /opt/nsd03
[root@localhost ~]# ls /opt/

[root@localhost ~]# mkdir -p  /vod/movie/cartoon
[root@localhost ~]# ls /

[root@localhost ~]# mkdir -p  /opt/aa/bb/cc/dd
[root@localhost ~]# ls /opt/

-R:
  递归:目录本身以及目录下所有

[root@server0 ~]# ls -R /vod       
/vod:
movie
/vod/movie:
cartoon
/vod/movie/cartoon:

#################################################
rm 删除
• rm — Remove
– 格式:rm [选项]... 文件或目录...            
• 常用命令选项
– -r、-f:递归删除(含目录)、强制删除

[root@localhost ~]# rm -rf /opt/nsd03
[root@localhost ~]# ls /opt/

[root@localhost ~]# rm -rf /opt/rh
[root@localhost ~]# ls /opt/

##################################################
mv 移动/改名
• mv — Move
– 格式: mv [选项]... 原文件...    目标路径
[root@localhost ~]# mkdir /opt/nsd01
[root@localhost ~]# touch /opt/1.txt
[root@localhost ~]# ls /opt/

[root@localhost ~]# mv /opt/1.txt /opt/nsd01/
[root@localhost ~]# ls /opt/
[root@localhost ~]# ls /opt/nsd01/

重命名:路径不变的移动
[root@localhost ~]# mv /opt/nsd01/  /opt/haha01
[root@localhost ~]# ls /opt/

[root@localhost ~]# mv /opt/haha01/ /opt/stu01
[root@localhost ~]# ls /opt/
####################################################
cp 复制
• cp — Copy
– 格式:cp [选项]... 原文件...      目标路径

• 常用命令选项
– -r:递归,复制目录时必须有此选项
1.基本用法
[root@localhost ~]# cp /etc/passwd  /opt/
[root@localhost ~]# ls /opt/

[root@localhost ~]# cp -r /home/  /opt/
[root@localhost ~]# ls /opt/

2.可以支持两个以上的参数,永远将最后一个参数做目标,其他所有参数作为源
[root@localhost ~]# cp -r  /etc/hosts  /etc/fstab /boot/   /opt/

[root@localhost ~]# ls /opt/

3.cp经常与点  . 连用,将数据复制到当前路径下
    .:当前目录

[root@localhost ~]# cd /opt/
[root@localhost opt]# pwd
[root@localhost opt]# cp -r /etc/shadow  .  
[root@localhost opt]# ls

[root@localhost /]# cd /etc/sysconfig/network-scripts/
[root@localhost network-scripts]# pwd
[root@localhost network-scripts]# cp /etc/passwd    .  
[root@localhost network-scripts]# ls

4.复制到目标路径下,可以重新命名
[root@localhost /]# rm -rf /opt/*     
[root@localhost /]# ls /opt/
[root@localhost /]# cp /etc/passwd  /opt/
[root@localhost /]# ls /opt/

[root@localhost /]# cp /etc/passwd /opt/pd
[root@localhost /]# ls /opt/

[root@localhost /]# cp -r /home/ /opt/abc
[root@localhost /]# ls /opt/

请分析下列两次复制的不同:
[root@localhost /]# rm -rf /opt/*
[root@localhost /]# cp -r /home/  /opt/redhat
           将/home目录复制到/opt/并且重命名为redhat
[root@localhost /]# cp -r /home/  /opt/redhat
           将/home目录复制到/opt/redhat目录下

##################################################
grep针对文本文件内容进行过滤

在文本文件内容进行过滤,输出包含指定字符串的行
  /etc/passwd系统级配置文件
[root@localhost /]# grep root /etc/passwd

• 常用命令选项
– -v,取反匹配
– -i,忽略大小写
[root@localhost /]# grep -v root /etc/passwd
[root@localhost /]# grep ROOT /etc/passwd
[root@localhost /]# grep -i ROOT /etc/passwd

• 常用的匹配模式
– word 包含字符串word
– ^word 以字符串word开头
– word$ 以字符串word结尾

[root@localhost /]# grep ^root /etc/passwd

[root@localhost /]# grep root$ /etc/passwd

[root@localhost /]# grep bash$ /etc/passwd

#################################################
vim命令行文本编辑器

三个模式:
     命令模式      插入模式(输入模式)    末行模式

[root@server0 ~]# vim /opt/haxi.txt

		命----i 键---->插入模式(Esc 键回到命令模式)
		令
		模
		式----:  键---->末行模式(Esc 键回到命令模式)

     末行模式 :wq 保存并退出
     末行模式 :q! 强制不保存并退出

###################################################
#################################################

复制时出现重名,强制覆盖
在本次复制,临时取消别名
[root@A ~]# cp -r /boot/ /opt/
[root@A ~]# cp -r /boot/ /opt/

[root@A ~]# \cp -r /boot/ /opt/

#################################################

命令输出重定向
  >:覆盖重定向
  >>:追加重定向
[root@A ~]# ls --help
[root@A ~]# ls --help  > /opt/ls.txt
[root@A ~]# ls /opt/
[root@A ~]# less /opt/ls.txt 

[root@A ~]# hostname
[root@A ~]# hostname > /opt/ls.txt 
[root@A ~]# cat /opt/ls.txt

[root@A ~]# hostname >> /opt/ls.txt
[root@A ~]# cat /opt/ls.txt

[root@A ~]# echo haha
[root@A ~]# cat /opt/ls.txt     

[root@A ~]# echo 123456 >> /opt/ls.txt
[root@A ~]# cat /opt/ls.txt

[root@A ~]# echo hello > /opt/ls.txt
[root@A ~]# cat /opt/ls.txt
##################################################
   | 管道操作: 将前面命令的输出,交由后面命令处理
  
  显示文件内容/etc/passwd的8~12行
[root@A ~]# head -12 /etc/passwd | tail -5
[root@A ~]# head -12 /etc/passwd | tail -5 | cat  -n
[root@A ~]# cat -n /etc/passwd | head -12 | tail -5

[root@A ~]# ifconfig | less
[root@A ~]# ifconfig | head -2

##################################################
管理用户和组

  用户:登录操作系统,不同的用户具备不同的权限
  组:方便管理用户

  用户唯一标识: UID
  组唯一标识: GID

  管理员root的UID为0

  组的分类: 基本组(私有组)    附加组(从属组)
  原则:一个用户必须至少属于一个组
  基本组(私有组) :由系统创建与用户同名的组
  附加组(从属组):由管理员root创建的组

[root@A ~]# useradd nsd01
[root@A ~]# 组:nsd01

               附加组(从属组): caiwu   meinv  haha  jishu
###################################################
添加用户
用户基本信息存放在 /etc/passwd 文件
[root@A ~]# head -1 /etc/passwd
 root:x:0:0:root:/root:/bin/bash
 用户名:密码占位符:UID:基本组GID:用户描述信息:家目录:解释器程序
• 使用 useradd 命令
– useradd [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器、-G 附加组

[root@A ~]# useradd nsd02    #创建nsd02用户
[root@A ~]# id nsd02         #查看nsd02用户基本信息

[root@A ~]# useradd nsd03
[root@A ~]# id nsd03

[root@A ~]# useradd -u 1500 nsd04  #指定用UID值创建
[root@A ~]# id nsd04

[root@A ~]# useradd -d /opt/abc  nsd05  #指定用户家目录创建
[root@A ~]# ls /opt/
[root@A ~]# grep  nsd05  /etc/passwd

 用户名:密码占位符:UID:基本组GID:用户描述信息:家目录:解释器程序

[root@A ~]# useradd -d /opt/nsd06  nsd06 
[root@A ~]# ls /opt/
[root@A ~]# grep  nsd06  /etc/passwd

###################################################
-s 登录解释器
 /sbin/nologin:禁止登录操作系统
[root@A ~]# useradd -s /sbin/nologin nsd06
[root@A ~]# grep nsd06 /etc/passwd

-G 附加组
[root@A ~]# groupadd stugrp     #创建stugrp组
[root@A ~]# useradd -G stugrp  nsd07
[root@A ~]# id nsd07
 
[root@A ~]# useradd -G stugrp  nsd08
[root@A ~]# id nsd08

##################################################
设置登录密码
用户密码信息存放在 /etc/shadow 文件
[root@A ~]# tail -1 /etc/shadow
nsd08:$6$VjFxZ9GD$XaYwBkrcR0eVnFNZrO/om1bQKFYzlsXW.aHMCx.nOGguVde19zLyyl1jBekeU6r49UfFcvWy4sUDw8iG2OSv2.:18022:0:99999:7:::

用户名:密码加密字符串:上一次修改密码的时间

         1970-1-1~2019-5-6     18022

[root@A ~]# useradd nsd10
[root@A ~]# tail -1 /etc/shadow
nsd10:!!:18022:0:99999:7:::

第二个字段为!!,代表用户为锁定状态

• 使用 passwd 命令
– passwd [用户名]
[root@A ~]# useradd nsd08
[root@A ~]# passwd nsd08   #交互方式设置密码
更改用户 nsd08 的密码 。
新的 密码：                                #输入新的密码
无效的密码： 密码少于 8 个字符
重新输入新的 密码：                    #重新输入新的密码
passwd：所有的身份验证令牌已经成功更新。
[root@A ~]# su - nsd08      #命令行临时切换身份
[nsd08@A ~]$ passwd 
更改用户 nsd08 的密码 。
为 nsd08 更改 STRESS 密码。
（当前）UNIX 密码：              #输入旧密码
新的 密码：                            #输入新的密码
重新输入新的 密码：                #重新输入新的密码
passwd：所有的身份验证令牌已经成功更新。
[nsd08@A ~]$ exit        #退出回到root


非交互式设置密码
 echo '密码'   |   passwd  --stdin 用户名

[root@A ~]# echo 123  | passwd --stdin nsd08

[root@A ~]# echo redhat | passwd --stdin nsd08

[root@A ~]# echo 654321 | passwd --stdin nsd08

#################################################
修改用户属性
• 使用 usermod 命令
– usermod [选项]... 用户名
• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器、-G 附加组

[root@A ~]# useradd nsd11
[root@A ~]# id nsd11
[root@A ~]# grep nsd11 /etc/passwd

[root@A ~]# usermod -u 1800 -d /opt/test -s /sbin/nologin -G stugrp  nsd11

[root@A ~]# id nsd11
[root@A ~]# grep nsd11 /etc/passwd

[root@A ~]# useradd nsd13
[root@A ~]# grep nsd13 /etc/passwd
[root@A ~]# ls /home/

[root@A ~]# usermod -d  /opt/n13  nsd13
[root@A ~]# grep nsd13 /etc/passwd

[root@A ~]# ls /opt/n13
ls: 无法访问/opt/n13: 没有那个文件或目录

################################################
检查用户ID信息
• 使用 id 命令
– id 用户名

##################################################
删除用户
• 使用 userdel 命令
– userdel [-r] 用户名
   -r:连同用户家目录一并删除

[root@A ~]# ls /home/

[root@A ~]# userdel nsd01
[root@A ~]# ls /home/

[root@A ~]# id nsd01
id: nsd01: no such user
[root@A ~]# rm -rf /home/nsd01/
[root@A ~]# ls /home/

[root@A ~]# ls /home/
[root@A ~]# userdel -r nsd02
[root@A ~]# ls /home/

####################################################
管理组账号

添加组
组基本信息存放在 /etc/group 文件
[root@A ~]# grep linux /etc/group
linux:x:1802:

组名:组的密码占位符:组的编号:组成员列表

• 使用 groupadd 命令
– groupadd [-g 组ID] 组名
[root@A ~]# groupadd  linux
[root@A ~]# grep linux /etc/group

[root@A ~]# useradd natasha
[root@A ~]# useradd kaka
[root@A ~]# useradd jack
[root@A ~]# useradd xiha

管理组成员
组成员信息存放在 /etc/gshadow 文件
• 使用 gpasswd 命令
– gpasswd -a 用户名 组名
– gpasswd -d 用户名 组名

[root@A ~]# grep linux /etc/group
[root@A ~]# gpasswd -a natasha linux   #将用户加入组

[root@A ~]# grep linux /etc/group
[root@A ~]# id natasha

[root@A ~]# gpasswd -a kaka linux
[root@A ~]# grep linux /etc/group

[root@A ~]# gpasswd -a jack linux
[root@A ~]# grep linux /etc/group

[root@A ~]# gpasswd -d kaka linux    #将用户从组中删除
[root@A ~]# grep linux /etc/group

案例1:配置用户和组账号
• 新建用户 alex,其用户ID为3456,密码是flectrag           
[root@A ~]# useradd -u 3456 alex 
[root@A ~]# id alex
[root@A ~]# echo flectrag | passwd --stdin alex
• 创建下列用户、组以及组的成员关系:创建一个名为 adminuser 的组
[root@A ~]# groupadd adminuser
[root@A ~]# grep adminuser /etc/group
• 创建natasha 的用户,其属于 adminuser 组,这个组是该用户的从属组
[root@A ~]# gpasswd -a natasha adminuser
[root@A ~]# grep adminuser /etc/group
• 创建harry 的用户,其属于 adminuser 组,这个组是该用户的从属组
[root@A ~]# gpasswd -a harry adminuser
[root@A ~]# grep adminuser /etc/group
• 创建 sarah 的用户,其在系统中没有可交互的Shell(解释器),不是 adminuser 组的成员
[root@A ~]# useradd -s /sbin/nologin sarah
[root@A ~]# grep sarah /etc/passwd
• natasha 、harry、sarah 的密码都要设置为 flectrag
[root@A ~]# echo flectrag | passwd --stdin natasha
[root@A ~]# echo flectrag | passwd --stdin harry
[root@A ~]# echo flectrag | passwd --stdin sarah

###################################################
删除组
• 使用 groupdel 命令
– groupdel 组名
[root@A ~]# groupdel linux
[root@A ~]# grep linux /etc/group

###############################################
tar备份与恢复

    作用:减少占用的空间,零散的文件整理到一个压缩包

    压缩格式:
       gzip-----> .gz  
       bzip2-----> .bz2
       xz  -----> .xz

制作tar包:打包
  格式: tar  选项      /路径/压缩包的名字      /路径/源文档  .......

解包
  格式: tar  选项     /路径/压缩包的名字       /释放位置


• tar 集成备份工具
– -c:创建归档
– -x:释放归档
– -f:指定归档文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz格式的工具进行处理
– -t:显示归档中的文件清单
– -C:指定释放路径

 f选项必须放在,所有选项的最后         
制作tar包:打包

]# tar -zcf /opt/file.tar.gz  /home/ /etc/passwd
]# ls /opt/

]# tar -jcf /opt/nsd.tar.bz2  /home/  /etc/passwd
]# ls /opt/

]# tar -Jcf /opt/abc.tar.xz   /home/  /etc/passwd
]# ls /opt/

  -z:gzip压缩格式
  -j:bzip2压缩格式
  -J:xz压缩格式

[root@A ~]# mkdir /nsd02
[root@A ~]# tar -xf /opt/file.tar.gz -C /nsd02
[root@A ~]# ls /nsd02/
[root@A ~]# ls /nsd02/etc/
[root@A ~]# ls /nsd02/home/

[root@A ~]# mkdir /nsd03
[root@A ~]# tar -xf /opt/nsd.tar.bz2 -C /nsd03
[root@A ~]# ls /nsd03

[root@A ~]# tar -tf /opt/abc.tar.xz   #查看包里内容


案例2:创建一个备份包
使用 tar 工具完成以下备份任务:
– 创建一个名为 /root/backup.tar.bz2 的归档文件
– 其中包含 /usr/local 目录中的内容
– tar 归档必须使用 bzip2 进行压缩

[root@A ~]# tar -jcf /root/backup.tar.bz2 /usr/local/

[root@A ~]# ls /root/

[root@A ~]# tar -tf /root/backup.tar.bz2   #查看包里内容

#####################################################
周期性任务

cron任务概述
• 用途:按照设置的时间间隔为用户反复执行某一项固定的系统任务
• 日志文件:/var/log/crond

执行周期 配置说明
分钟 从0到59之间的整数
小时 从0到23之间的整数
日期 从1到31之间的整数
月份 从1到12之间的整数
星期 0~7之间的整数,0或7代表星期日



• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]
– 查看:crontab -l [-u 用户名]
– 清除:crontab -r [-u 用户名]

如何编写crontab任务记录 
– 分  时  日  月  周    任务命令行(绝对路径)       

   30   8   *   *   *           #每天早晨的8:30              

   30   23   *   *   5         #每周的周五晚上11:30      

   30   8   1   *    *          #每月的1号早晨的8:30   

   30   23   *   *   1-5      #周一至周五晚上11:30      

   30   23   *   *   1,3,5   #周一或周三或周五晚上11:30     

	*:匹配范围内任意时间
	,:分隔多个不连续的时间点
	-:指定连续时间范围
	/n:指定时间频率,每n ...

   1   */2   *   *   *     #每隔2个小时执行一次

   */5   *   *   *   *     #每隔5分钟执行一次

   30   23   1   *   1     #周一或每月一号 晚上11:30       

##################################################
每分钟记录当前系统时间,将系统时间每分钟写入文件/opt/time.txt
[root@A ~]# date
[root@A ~]# date >> /opt/time.txt
[root@A ~]# cat /opt/time.txt
[root@A ~]# crontab -e -u root
*  *  *  *  *   date  >>  /opt/time.txt

[root@A ~]# crontab -l -u root
[root@A ~]# cat /opt/time.txt

###################################################
[root@A ~]# crontab -e -u root
*/2  *  *  *  *  date >> /opt/time.txt
[root@A ~]# crontab -l -u root

[root@A ~]# cat /opt/time.txt
###################################################

教学环境介绍

使用教学虚拟机

• 每个学员机上有三台预先配置好的虚拟机
– server —— 作为练习用服务器
– desktop —— 作为练习用客户机
– classroom —— 提供网关/DNS/软件素材等资源

优先开启classroom虚拟机

真机上:使用rht-vmctl辅助工具
• 控制教学用虚拟机
– 格式:rht-vmctl 控制指令 虚拟机名
– 常用控制指令:
[student@room9pc01 ~]$ rht-vmctl 　reset　 classroom
classroom [OK]
域 classroom 已开始

[student@room9pc01 ~]$ rht-vmctl　 reset　 server
server [OK]
域 server 已开始

[student@room9pc01 ~]$ rht-vmctl 　reset　 desktop
desktop [OK]
域 desktop 已开始

虚拟机server与虚拟机desktop,利用root登录密码为redhat
#################################################
字体变大：ctrl   shift   +
字体变小：ctrl   -

#################################################
虚拟机server:
  1.查看系统的版本:RHEL7.0
  2.查看eth0网卡的IP地址:172.25.0.11/24  
  3.查看主机名:server0.example.com

虚拟机desktop:
  1.查看系统的版本:RHEL7.0
  2.查看eth0网卡的IP地址:172.25.0.10/24  
  3.查看主机名:desktop0.example.com

#################################################
利用真机,远程管理两台虚拟机
1.前提真机可以与两台虚拟机通信
[student@room9pc01 ~]$ ping 172.25.0.11

[student@room9pc01 ~]$ ping 172.25.0.10

2.真机上,ssh命令进行远程管理

    ssh   对方用户名@对方IP地址
[student@room9pc01 ~]$ ssh　root@172.25.0.11 

[student@room9pc01 ~]$ ssh　root@172.25.0.10

开启一个新的终端：ctrl + shift + t

   -X(大写):在远程管理时,开启对方的图形程序

[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ ssh -X root@172.25.0.11
[root@server0 ~]# firefox           #火狐浏览器

[root@server0 ~]# firewall-config   #防火墙图形配置工具


常见提示:dconf桌面服务报错,与远程管理无关
(process:30405): dconf-WARNING **: failed to commit changes to dconf: 无法连接：拒绝连接

###################################################
补充:为真机,设置永久的别名,修改系统级配置文件
   ~/.bashrc  #设置永久别名配置文件,每开一个终端会被执行一次

[student@room9pc01 ~]$ vim /home/student/.bashrc
# .bashrc
alias  gos='ssh  -X  root@172.25.0.11'
alias  god='ssh  -X  root@172.25.0.10'

新开一个终端验证:
[student@room9pc01 ~]$ gos
[student@room9pc01 ~]$ god

#################################################
权限和归属

基本权限

• 访问方式(权限)
– 读取:允许查看内容-read  r
– 写入:允许修改内容-write  w
– 可执行:允许运行和切换-execute  x

  对文本文件:
       r: cat less head tail 
       w: vim 保存   >   >>
       x: 书写Shell脚本或Python脚本

• 权限适用对象(归属)
– 所有者(属主):拥有此文件/目录的用户-user  u
– 所属组(属组):拥有此文件/目录的组-group    g
– 其他用户:除所有者、所属组以外的用户-other   o

     zhangsan       1.txt
         所有者的基本组成为该文件的所属组

####################################################
查看权限
• 使用 ls -l 命令
– ls -ld 文件或目录...

   以d开头:目录
   以-开头:文件
   以l开头:快捷方式

[root@server0 ~]# ls -ld /etc/
[root@server0 ~]# ls -l /etc/passwd

[root@server0 ~]# ls -l /etc/shadow
[root@server0 ~]# ls -ld /home/student
[root@server0 ~]# ls -ld /tmp
####################################################
设置基本权限
• 使用 chmod 命令
– chmod  归属关系+-=权限类别  文档...

   [-R]:递归设置权限

[root@server0 ~]# mkdir /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod g+w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod u-w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod o=--- /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod u=rwx,g=rx,o=rx /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod ugo=rwx /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# mkdir -p /opt/aa/bb/cc
[root@server0 ~]# ls -ld /opt/aa
[root@server0 ~]# ls -ld /opt/aa/bb/
[root@server0 ~]# ls -ld /opt/aa/bb/cc/

[root@server0 ~]# chmod -R o=--- /opt/aa
[root@server0 ~]# ls -ld /opt/aa

##################################################
Linux判定用户具备的权限                      匹配及停止
    1.判定用户对该文档的身份               所有者>所属组>其他人       
    2.查看相应身份 权限位的权限
  
Permission denied :权限不足

目录的 r 权限:能够 ls 浏览此目录内容
目录的 w 权限:能够执行 rm/mv/cp/mkdir/touch/等更改目录内容的操作
目录的 x 权限:能够 cd 切换到此目录


以root用户新建/nsddir目录，在此目录下新建readme.txt文件
并进一步完成下列操作
 1）使用户lisi能够在此目录下创建子目录     切换用户 su  -  lisi
     chmod o+w  /nsddir/
 2）使用户lisi不能够在此目录下创建子目录
     chmod o-w  /nsddir/
 3）使用户lisi能够修改readme.txt文件内容
     chmod o+w  /nsddir/readme.txt
 4）调整此目录的权限，使所有用户都不能cd进入此目录
     chmod u-x,g-x,o-x  /nsddir/
 5）为此目录及其下所有文档设置权限 rwxr-x---
     chmod -R  u=rwx,g=rx,o=---  /nsddir/
　　　-R：递归设置权限，目录下及目录下所有

##################################################
设置文档归属
• 使用 chown 命令
– chown [-R] 属主       文档...
– chown [-R] :属组      文档...
– chown [-R] 属主:属组   文档...   -R:递归

[root@server0 ~]# groupadd tedu
[root@server0 ~]# mkdir /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown lisi:tedu /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown zhangsan /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown :root  /nsd03
[root@server0 ~]# ls -ld /nsd03

################################################
利用root用户新建/nsd06目录，并进一步完成下列操作
1）将属主设为gelin01，属组设为tarena组              
[root@server0 /]# useradd gelin01
[root@server0 /]# useradd gelin02
[root@server0 /]# groupadd tarena
[root@server0 /]# chown gelin01:tarena  /nsd06
2）使用户gelin01对此目录具有rwx权限
      除属主与属组之外的人，对此目录无任何权限
[root@server0 /]# chmod o=--- /nsd06
3）使用户gelin02能进入、查看此目录内容
[root@server0 /]# gpasswd -a  gelin02  tarena
4）将gelin01加入tarena组, 将nsd06目录的权限设为rw-r-x---
      再测试gelin01用户能否进入此目录
[root@server0 /]# gpasswd -a  gelin01  tarena
[root@server0 /]# chmod u=rw,g=rx /nsd06
###################################################
让lisi用户可以读取/etc/shadow文件内容,您有几种办法  
   1.利用其他用户
      chmod  o+r  /etc/shadow
           
   2.利用所属组
      chown :lisi  /etc/shadow
      chmod  g+r   /etc/shadow

   3.利用所有者
      chown  lisi  /etc/shadow
      chmod  u+r   /etc/shadow
###################################################
附加权限(特殊权限)

Set GID
• 附加在属组的 x 位上
属组的权限标识会变为 s
适用于目录,Set GID可以使目录下新增的文档自动设置与父目录相同的属组
让父目录下,新增的子文档继承父目录的所属组身份

[root@server0 ~]# mkdir /nsd07
[root@server0 ~]# chown :tedu /nsd07   #修改所属组
[root@server0 ~]# ls -ld /nsd07

[root@server0 ~]# mkdir /nsd07/abc
[root@server0 ~]# ls -ld /nsd07/abc
[root@server0 ~]# chmod g+s /nsd07/    #设置Set GID权限
[root@server0 ~]# ls -ld /nsd07/

[root@server0 ~]# mkdir /nsd07/test
[root@server0 ~]# ls -l /nsd07/

[root@server0 ~]# touch /nsd07/1.txt
[root@server0 ~]# ls -l /nsd07/

###################################################

        /nsd09  rwx  r-x ---  存放打卡记录
         2019-5-6.txt
         2019-5-7.txt
         2019-5-8.txt
         2019-5-9.txt

        groupadd  caiwu

        chown  :caiwu  /nsd09
        chmod  g+s   /nsd09

##################################################
Set UID
• 附加在属主的 x 位上
属主的权限标识会变为 s
适用于可执行文件,Set UID可以让使用者具有文件属主的身份及部分权限

[root@server0 ~]# /usr/bin/mkdir /opt/haha   
[root@server0 ~]# ls /opt/
[root@server0 ~]# cp /usr/bin/mkdir /usr/bin/hahadir
[root@server0 ~]# /usr/bin/hahadir /opt/xixi
[root@server0 ~]# ls /opt/
[root@server0 ~]# chmod u+s /usr/bin/hahadir 
[root@server0 ~]# ls -l /usr/bin/hahadir
[root@server0 ~]# su - lisi
[lisi@server0 ~]$ /usr/bin/mkdir  test01
[lisi@server0 ~]$ /usr/bin/hahadir test02
[lisi@server0 ~]$ ls
test01  test02
[lisi@server0 ~]$ ls -l
[lisi@server0 ~]$ exit
###################################################

Sticky Bit
• 附加在其他人的 x 位上
其他人的权限标识会变为 t
适用于开放 w 权限的目录,可以阻止用户滥用 w 写入权限(禁止操作别人的文档)

[root@server0 ~]# mkdir /public
[root@server0 ~]# chmod ugo=rwx /public
[root@server0 ~]# ls -ld /public

[root@server0 ~]# chmod o+t /public/
[root@server0 ~]# ls -ld /public/

##############################################

ACL权限(策略)

acl策略的作用
• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持


设置acl访问控制策略
• 使用 getfacl、setfacl 命令
– getfacl 文档...
– setfacl [-R] -m u:用户名:权限类别     文档...
– setfacl [-R] -m g:组名:权限类别       文档...
– setfacl [-R] -b      文档...                #删除所有ACL策略
– setfacl [-R] -x u:用户名    文档...     #删除指定ACL策略


让lisi用户可以读取/etc/shadow文件内容,您有几种办法  
   1.利用其他用户
      chmod  o+r   /etc/shadow
   2.利用所属组
      chown :lisi  /etc/shadow
      chmod  g+r   /etc/shadow
   3.利用所有者
      chown  lisi  /etc/shadow
      chmod  u+r   /etc/shadow
   4.利用ACL策略
      setfacl  -m u:lisi:r  /etc/shadow


[root@server0 ~]# mkdir /nsd01
[root@server0 ~]# chmod o=--- /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# su - student
[student@server0 ~]$ cd /nsd01
-bash: cd: /nsd01: Permission denied
[student@server0 ~]$ exit
logout
[root@server0 ~]# setfacl -m  u:student:rx  /nsd01
[root@server0 ~]# getfacl /nsd01   #查看ACL策略
[root@server0 ~]# su - student
[student@server0 ~]$ cd /nsd01
[student@server0 nsd01]$ pwd

#####################################################

[root@server0 ~]# mkdir /nsd02
[root@server0 ~]# setfacl -m u:student:rwx /nsd02
[root@server0 ~]# setfacl -m u:dc:rx /nsd02
[root@server0 ~]# setfacl -m u:lisi:rx /nsd02
[root@server0 ~]# setfacl -m u:zhangsan:rwx /nsd02

[root@server0 ~]# getfacl /nsd02
[root@server0 ~]# setfacl -x u:dc  /nsd02   #删除指定ACL
[root@server0 ~]# getfacl /nsd02

[root@server0 ~]# setfacl -b /nsd02  #删除所有ACL策略
[root@server0 ~]# getfacl /nsd02

###################################################
设置黑名单
[root@server0 ~]# mkdir /public            
[root@server0 ~]# chmod ugo=rwx /public
[root@server0 ~]# ls -ld /public

[root@server0 ~]# setfacl -m u:lisi:--- /public
[root@server0 ~]# getfacl /public

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /public/
-bash: cd: /public/: Permission denied
[lisi@server0 ~]$ ls /public/
ls: cannot open directory /public/: Permission denied
[lisi@server0 ~]$ exit

###################################################
软件包管理

一 零散软件管理
1.前提具备软件包

2.虚拟机classroom搭建Web服务器,共享RHEL7.0光盘所有内容

  Web服务:提供网页内容的服务

3.访问虚拟机classroom网页
   真机利用火狐浏览器:   classroom.example.com

classroom.example.com/content/rhel7.0/x86_64/dvd/

4.下载软件包到虚拟机server:
• 使用wget下载工具
– wget 软件包的URL网址
– wget 软件包的URL网址   -O  /目录路径/新文件名

   Packages目录中
   在火狐浏览器中,按键盘  Ctrl + f  进行当前页面搜索

[root@server0 ~]# wget   软件包的网络路径
[root@server0 ~]# wget  http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/vsftpd-3.0.2-9.el7.x86_64.rpm

[root@server0 ~]# ls 


使用rpm命令管理软件
• RPM Package Manager,RPM包管理器
– rpm -q   软件名...
– rpm -ivh 软件名-版本信息.rpm...
– rpm -e   软件名...

1 查询软件是否安装
[root@server0 ~]# rpm -q firefox
[root@server0 ~]# rpm -q zip

[root@server0 ~]# rpm -q hostname   
[root@server0 ~]# rpm -q vsftpd   #查询软件软件安装

[root@server0 ~]# rpm -q haha

2.安装软件包
[root@server0 ~]# rpm -q vsftpd  
未安装软件包 vsftpd 

]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

[root@server0 ~]# rpm -q vsftpd
 
[root@server0 ~]# rpm -e vsftpd    #卸载
[root@server0 ~]# rpm -q vsftpd    #查询是否卸载成功
未安装软件包 vsftpd 
[root@server0 ~]# 

补充内容:
[root@server0 ~]# rpm -ql vsftpd   #已安装软件的清单

了解:导入红帽签名信息
]# wget http://classroom.example.com/content/rhel7.0/x86_64/dvd/RPM-GPG-KEY-redhat-release

]# ls

]# rpm --import /root/RPM-GPG-KEY-redhat-release 

]# rpm -e vsftpd
]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

##################################################
常见报错信息:
]# rpm -ivh /root/bind-chroot-9.9.4-14.el7.x86_64.rpm 
错误：依赖检测失败：
	bind = 32:9.9.4-14.el7 被 bind-chroot-32:9.9.4-14.el7.x86_64 需要

#################################################
Yum软件包仓库:自动解决依赖关系安装软件

构建Yum服务

服务:自动解决依赖关系安装软件

服务端:  1.众多的软件包   2.仓库数据文件  3.构建FTP或Web服务
                   都在光盘内容里

           虚拟机classroom:构建Web服务,共享光盘所有内容
[student@room13pc20 ~]$ rpm -q vsftpd
vsftpd-3.0.2-22.el7.x86_64

[student@room13pc20 ~]$ ls /var/ftp/centos-1804/

[student@room13pc20 ~]$ systemctl status vsftpd  #查看vsftp状态

[student@room13pc20 ~]$ vim /etc/fstab 
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0




客户端: 虚拟机server 指定服务端位置
    书写配置文件: /etc/yum.repos.d/*.repo
    错误的文件会影响正确的配置文件
[root@server0 /]# rm -rf /etc/yum.repos.d/*
[root@server0 /]# vim  /etc/yum.repos.d/dvd.repo
 [rhel7]                #仓库标识
 name=rhel7.0           #仓库描述信息
 baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/             #指定服务端位置
 enabled=1              #是否启用本文件
 gpgcheck=0             #是否检测软件包的红帽签名

[root@server0 /]# yum repolist   #显示仓库基本信息

Yum仓库的使用:
[root@server0 /]# yum -y install httpd    
[root@server0 /]# yum -y install sssd
[root@server0 /]# yum -y install gcc
[root@server0 /]# yum -y install system-config-kickstart
[root@server0 /]# yum -y install tftp-server

卸载软件包:
[root@server0 /]# yum remove httpd
[root@server0 /]# yum remove gcc
[root@server0 /]# yum remove sssd

清空Yum缓存:
[root@server0 /]# yum repolist 
[root@server0 /]# yum clean all   #清空Yum缓存
[root@server0 /]# yum repolist 
#################################################
升级内核

1.下载新的内核
[root@server0 ~]# wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

[root@server0 ~]# ls

2.查看当前系统内核版本
[root@server0 ~]# uname -r
 3.10.0-123.el7.x86_64

3.安装新的内核软件包
]# rpm -ivh /root/kernel-3.10.0-123.1.2.el7.x86_64.rpm 

4.重启虚拟机server验证:
[root@server0 ~]# reboot 
Connection to 172.25.0.11 closed by remote host.
Connection to 172.25.0.11 closed.

[student@room9pc01 ~]$ gos
[root@server0 ~]# uname -r
3.10.0-123.1.2.el7.x86_64
[root@server0 ~]# 
####################################################
分区规划及使用

  扇区默认的大小512字节

•  识别硬盘 => 分区规划 => 格式化 => 挂载使用
     毛坯楼层 => 打隔断 => 装修  =>入驻

一  识别硬盘
[root@server0 ~]# lsblk               
NAME    SIZE  TYPE MOUNTPOINT
vda     10G   disk 
└─vda1   10G   part /
vdb      10G   disk 

[root@server0 ~]# ls /dev/vdb

关机添加一块新的硬盘60G硬盘
[root@server0 ~]# poweroff 
Connection to 172.25.0.11 closed by remote host.
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ gos
[root@server0 ~]# lsblk 
[root@server0 ~]# ls   /dev/vdc

二  分区规划 

     分区模式: 
     MBR主引导记录的分区模式
         – 最大支持容量为 2.2TB 的磁盘
         – 1~4个主分区,或者 3个主分区+1个扩展分区(n个逻辑分区)
         – 扩展分区不能格式化

• 修改硬盘的分区表
[root@server0 ~]# fdisk /dev/vdb
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
  p 查看分区表
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +1G
  d 删除分区
  w 保存并退出 

[root@server0 ~]# lsblk 
[root@server0 ~]# ls  /dev/vdb[1-2]

   /dev/sda5设备表示的含义:
                     第一块SCSI接口的硬盘,第5个分区
                     第一块SCSI接口的硬盘,第1个逻辑分区

三  格式化:赋予空间文件系统的过程               

     文件系统:空间存储数据的规则
  
    Windows: NTFS   FAT32

    Linux:  ext4(RHEL6)   xfs(RHEL7)

[root@server0 ~]# mkfs.ext4 /dev/vdb1  #格式化ext4文件系统
[root@server0 ~]# blkid /dev/vdb1      #查看分区文件系统

[root@server0 ~]# mkfs.xfs /dev/vdb2   #格式化xfs文件系统
[root@server0 ~]# blkid /dev/vdb2      #查看分区文件系统



四 挂载使用
[root@server0 ~]# mkdir /mypart1
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# df -h  #查看正在挂载的设备,使用情况

[root@server0 ~]# mkdir /mypart2
[root@server0 ~]# mount /dev/vdb2  /mypart2
[root@server0 ~]# df -h  #查看正在挂载的设备,使用情况

五  开机自动挂载

• 配置文件 /etc/fstab 的记录格式
   设备路径       挂载点        类型        参数         备份标记    检测顺序

[root@server0 ~]# vim  /etc/fstab  
 #命令模式 按 o可以另起新的一行进入 插入模式 
.......
/dev/vdb1  /mypart1  ext4   defaults  0 0
/dev/vdb2  /mypart2  xfs    defaults  0 0

[root@server0 ~]# umount /mypart1
[root@server0 ~]# umount /mypart2
[root@server0 ~]# df -h
[root@server0 ~]# mount -a
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载
[root@server0 ~]# df -h

六 综合分区
综合分区，/dev/vdb继续分区
最终有3个主分区，分别为2G、1G、1G
   创建扩展分区 --->  两个逻辑分区，分别为1G、1G
[root@server0 ~]# fdisk  /dev/vdb
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +1G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe   #刷新分区表
[root@server0 ~]# lsblk 

####################################################
总结：
1.识别硬盘　lsblk
2.分区规划    fdisk
3.刷新分区表　　partprobe
4.进行格式化　　mkfs.xfs  mkfs.ext4   blkid
5.挂载使用　mount  /etc/fstab开机自动挂载   mount -a  df -h

########################################################################

图形添加一块硬盘为80G
[root@server0 ~]# lsblk 
NAME   SIZE  TYPE  MOUNTPOINT
vda     10G   disk 
└─vda1   10G   part  /
vdb      10G   disk 
vdc      80G   disk 
[root@server0 ~]# ls  /dev/vdc

综合分区:
划分三个主分区10G,一个扩展分区,二个逻辑分区10G
[root@server0 ~]# fdisk  /dev/vdc
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
         连续划分三个主分区
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# lsblk 
[root@server0 ~]# ls /dev/vdc[1-6]

###################################################
LVM逻辑卷
     作用:1.整合分散的空间     2.空间可以扩大            

– 零散空闲存储 ---- 整合的虚拟磁盘 ---- 虚拟的分区

   将众多的物理卷(PV),组建成卷组(VG),再从卷组中划分逻辑卷(LV)

LVM管理工具集
	功能 			物理卷管理 	卷组管理 		逻辑卷管理
	Scan 扫描 	pvs		     vgs 		lvs
	Create 创建 	pvcreate 	vgcreate 	lvcreate
	Display 显示 	pvdisplay 	vgdisplay 	lvdisplay
	Remove 删除 	pvremove 	vgremove 	lvremove
	Extend 扩展 	/                       vgextend 	lvextend

###################################################
创建逻辑卷
1.创建卷组
   命令格式: vgcreate  卷组名    分区设备路径......

[root@server0 ~]# vgcreate systemvg /dev/vdc[1-2]
[root@server0 ~]# pvs     #查看物理卷基本信息
[root@server0 ~]# vgs     #查看卷组基本信息

2.创建逻辑卷
   命令格式: lvcreate -n 逻辑卷名  -L  大小    基于的卷组名
[root@server0 ~]# lvcreate -n mylv -L 16G systemvg 
[root@server0 ~]# vgs
[root@server0 ~]# lvs     #查看逻辑卷基本信息

3.使用逻辑卷
[root@server0 ~]# ls /dev/dm-0
[root@server0 ~]# ls /dev/systemvg/mylv 
[root@server0 ~]# ls -l /dev/systemvg/mylv

[root@server0 ~]# mkfs.xfs /dev/systemvg/mylv
[root@server0 ~]# blkid /dev/systemvg/mylv
[root@server0 ~]# vim /etc/fstab 
 /dev/systemvg/mylv  /nsd  xfs  defaults  0 0

[root@server0 ~]# mkdir /nsd
[root@server0 ~]# mount -a
[root@server0 ~]# df -h
#################################################
逻辑卷扩大

一  卷组有足够的剩余空间                      
1.空间的扩展
[root@server0 ~]# lvs
[root@server0 ~]# vgs 
[root@server0 ~]# lvextend -L 18G /dev/systemvg/mylv 
[root@server0 ~]# lvs  
                                 
2.文件系统的扩展
   扩展xfs文件系统命令: xfs_growfs 
   扩展ext4文件系统命令: resize2fs 

[root@server0 ~]# df -h
[root@server0 ~]# xfs_growfs /dev/systemvg/mylv 
[root@server0 ~]# df -h

二 卷组没有足够的剩余空间
1.先扩展卷组的空间
[root@server0 ~]# vgextend systemvg /dev/vdb
[root@server0 ~]# vgs
2.逻辑卷空间的扩展
[root@server0 ~]# lvs
[root@server0 ~]# vgs 
[root@server0 ~]# lvextend -L 25G /dev/systemvg/mylv 
[root@server0 ~]# lvs  
                                 
2.逻辑卷文件系统的扩展
[root@server0 ~]# df -h
[root@server0 ~]# xfs_growfs /dev/systemvg/mylv 
[root@server0 ~]# df -h

###################################################
补充: 逻辑卷也支持缩减
     ext4文件系统支持缩减
     xfs文件系统不支持缩减
##################################################
卷组划分空间的单位   PE

[root@server0 ~]# vgdisplay systemvg #显示卷组详细信息

     PE Size               4.00 MiB


 请划分一个大小为250M的逻辑卷
[root@server0 ~]# vgchange -s 1M systemvg   #修改PE大小
[root@server0 ~]# vgdisplay systemvg      #查看详细信息
[root@server0 ~]# lvcreate -n lvtest -L 250M systemvg 
[root@server0 ~]# lvs

 请划分一个为800个PE大小的逻辑卷   -l:指定PE的个数
[root@server0 ~]# lvcreate -n lvnsd -l 800 systemvg
[root@server0 ~]# lvs
###################################################
逻辑卷的删除
  删除卷组前提:基于该卷组创建的,所有逻辑卷都要删除

[root@server0 ~]# lvremove /dev/systemvg/lvnsd 
Do you really want to remove active logical volume lvnsd? [y/n]: y
  Logical volume "lvnsd" successfully removed
[root@server0 ~]# 

[root@server0 ~]# lvremove /dev/systemvg/lvtest 
Do you really want to remove active logical volume lvtest? [y/n]: y
  Logical volume "lvtest" successfully removed


[root@server0 ~]# lvremove /dev/systemvg/mylv 
  Logical volume systemvg/mylv contains a filesystem in use.
[root@server0 ~]# umount /nsd/
[root@server0 ~]# lvremove /dev/systemvg/mylv 
Do you really want to remove active logical volume mylv? [y/n]: y
  Logical volume "mylv" successfully removed
[root@server0 ~]# lvs
[root@server0 ~]# vgs
##################################################
find高级使用

– find [目录] [条件1] [-a|-o] [条件2] ...

– 常用条件表示:                                     
	-type 类型(f、d、l)
	-name "文档名称"
	-size +|-文件大小(k、M、G)
	-user 用户名
	-mtime 根据文件修改时间

###############################################
	-type 类型(f文本文件、d目录、l快捷方式)
[root@server0 /]# find /boot  -type l
[root@server0 /]# ls -l /boot/grub/menu.lst

[root@server0 /]# find /boot  -type d
[root@server0 /]# find /boot  -type f

[root@server0 /]# find /root  -type d
[root@server0 /]# find /root  -type f

	-name '文档名称'
[root@server0 /]# find /etc/  -name  '*tab'
[root@server0 /]# find /etc/  -name  'passwd'
[root@server0 /]# find /etc/  -name  'passwd*'

[root@server0 /]# find /etc/  -name  '*.conf'

[root@server0 /]# find /boot  -name  'vm*'

[root@server0 /]# mkdir /root/nsd01
[root@server0 /]# mkdir /root/nsd02
[root@server0 /]# touch /root/nsd03.txt

[root@server0 /]# find  /root/  -name  'nsd*'
[root@server0 /]# find  /root/  -name  'nsd*'  -type f
[root@server0 /]# find  /root/  -name  'nsd*'  -type d

两个条件满足其一即可
[root@server0 /]# find /root/ -name 'nsd*' -o -type d 


	-size +|-文件大小(k、M、G)

[root@server0 /]# find /boot/ -size +10M
[root@server0 /]# ls -lh /boot/initramfs-*

[root@server0 /]# find /boot/ -size -10M 

	-mtime 根据文件修改时间(都是过去时间)
                    +10:十天之前
                    -10:最近十天之内

[root@server0 /]# find /var/   -mtime +90
[root@server0 /]# find /var/   -mtime +1000
[root@server0 /]# find /root/   -mtime -2

	-user 用户名

[root@server0 /]# find  /home  -user student
[root@server0 /]# ls -l  /home


[root@server0 /]# find  /  -user student
[root@server0 /]# ls -l /var/spool/student


#################################################

find扩展使用
• 使用find命令的 -exec 操作
– find .. .. -exec 处理命令 {} \;
– 优势:以 {} 代替每一个结果,逐个处理,遇 \; 结束

]# find /boot/ -size +10M
]# find /boot/ -size +10M  -exec  cp  {}  /opt/  \; 
]# ls /opt/

]# find / -user student  -type f  -exec cp {} /opt  \;
]# ls -A /opt/

]# find /boot/ -name 'vm*'  
]# find /boot/ -name 'vm*'  -exec  cp  {}  /opt/  \; 
]# ls -A /opt/

##################################################
NTP时间同步

[root@server0 /]# date    #查看系统时间 
[root@server0 /]# date -s '2000-10-1  12:10:08'

[root@server0 /]# date
[root@server0 /]# date -s  '年-月-日    时:分:秒'   #修改时间格式


NTP网络时间协议
• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通

NTP时间服务器:虚拟机classroom

NTP客户机:虚拟机server
1.安装chrony软件包,与时间服务器沟通软件
[root@server0 /]# yum -y install chrony
[root@server0 /]# rpm -q chrony

[root@server0 /]# rpm  -ql chrony
/etc/NetworkManager/dispatcher.d/20-chrony
/etc/chrony.conf

2.修改配置/etc/chrony.conf,指定时间服务器位置
[root@server0 /]# vim  /etc/chrony.conf   
 以#开头的为注释行

 #server 0.rhel.pool.ntp.org iburst
 #server 1.rhel.pool.ntp.org iburst
 #server 2.rhel.pool.ntp.org iburst
 server classroom.example.com  iburst   #指定服务端位置

3.重启服务(程序)
[root@server0 /]# systemctl  restart chronyd 
[root@server0 /]# systemctl  enable chronyd   #开机自启动

 daemon
  英 [ˈdiːmən] 美 [ˈdiːmən]
  (古希腊神话中的)半神半人精灵
  守护进程

4.验证:
[root@server0 /]# date -s '2000-1-1  1:1:1'
2000年 01月 01日 星期六 01:01:01 CST
[root@server0 /]# systemctl restart chronyd
[root@server0 /]# date
2000年 01月 01日 星期六 01:01:58 CST
[root@server0 /]# date
2019年 05月 09日 星期四 16:19:00 CST

###################################################
grep补充
	^$:匹配空行

[root@server0 /]# grep ^root /etc/passwd
[root@server0 /]# grep bash$  /etc/passwd

 显示/etc/login.defs文件有效信息(去除注释  去除空行)
]# grep -v ^# /etc/login.defs
]# grep -v ^# /etc/login.defs | grep   -v ^$
]# grep -v ^# /etc/login.defs | grep   -v ^$  >  /opt/1.txt

################################################
修改用户家目录                                                    
[root@server0 /]# useradd tom
[root@server0 /]# id tom
[root@server0 /]# grep tom /etc/passwd

[root@server0 /]# usermod -d  /opt/abc  tom
[root@server0 /]# grep tom /etc/passwd

[root@server0 /]# grep tom /etc/passwd
[root@server0 /]# ls /opt/abc    #默认没有创建该用户的家目录

[root@server0 /]# cp -r /home/tom  /opt/abc
[root@server0 /]# chown -R tom:tom /opt/abc
[root@server0 /]# su - tom

[tom@server0 ~]$ exit
###################################################

使用LDAP认证,实现网络用户认证,达到用户的集中管理
  
　　RHCSA　红帽认证管理员  
　　RHCE　红帽认证工程师
　　RHCA　红帽认证架构师

     网络用户:用户信息会放在网络中LDAP服务器
     本地用户:用户信息会放在/etc/passwd

LDAP服务器:虚拟机classroom

客户端:虚拟机server
1.安装sssd软件,与LDAP服务器沟通
[root@server0 /]# yum -y install sssd
[root@server0 /]# rpm -q sssd

2.安装authconfig-gtk图形的工具,进行配置客户端sssd软件
[root@server0 /]# yum -y install authconfig-gtk
[root@server0 /]# authconfig-gtk

完全合格的主机名  www.baidu.com　　　www.qq.com    
               classroom.example.com

     选择LDAP
      dc=example,dc=com             #指定服务端域名
      classroom.example.com         #指定服务端主机名
     勾选TLS加密
      使用证书加密:
     http://classroom.example.com/pub/example-ca.crt

     选择LDAP密码 

3.重起服务
[root@server0 ~]# systemctl  restart  sssd   #重起服务
[root@server0 ~]# systemctl  enable  sssd    #设置开机自启动
[root@server0 ~]# grep ldapuser0 /etc/passwd
[root@server0 ~]# id ldapuser0     #验证LDAP用户信息
          
###################################################      
家目录漫游

    在LDAP服务器搭建共享,共享所有普通用户的家目录

  LDAP服务器:虚拟机classroom

    虚拟机classroom已经完成共享所有操作

 虚拟机server:访问共享数据
[root@server0 ~]# mkdir /haha
[root@server0 ~]# ls /haha
[root@server0 ~]# showmount -e classroom.example.com
Export list for classroom.example.com:
/home/guests 172.25.0.0/255.255.0.0

[root@server0 ~]# mount classroom.example.com:/home/guests  /haha
[root@server0 ~]# df -h

[root@server0 ~]# mkdir /home/guests
[root@server0 ~]# mount classroom.example.com:/home/guests/   /home/guests
[root@server0 ~]# ls /home/guests

[root@server0 ~]# su - ldapuser0
上一次登录：三 4月 10 19:21:04 CST 2019pts/0 上
[ldapuser0@server0 ~]$ 

#############################################################
##############################################################
#############################################################
#############################################################
#############################################################
#############################################################
############################################################
###########################################################
###############################################################
############################################################

什么是Shell脚本
• 提前设计可执行语句,用来完成特定任务的文件
– 解释型程序
– 顺序、批量执行

案例1:Shell脚本的编写及测试
1. 编写一个面世问候 /root/helloworld.sh 脚本
– 显示出一段话  Hello World

[root@server0 ~]# vim /root/hello.sh
echo Hello World
[root@server0 ~]# chmod +x /root/hello.sh  #赋予执行权限

[root@server0 ~]# /root/hello.sh    #绝对路径运行


规范Shell脚本的一般组成
• #! 环境声明,以下代码由那个程序进行解释
• # 注释文本
• 可执行代码


1)输出当前红帽系统的版本信息                
2)输出当前使用的内核版本
3)输出当前系统的主机名
[root@server0 ~]# vim /root/hello.sh 
#!/bin/bash
echo hello world
cat  /etc/redhat-release 
uname -r
hostname
ifconfig | head -2
[root@server0 ~]# /root/hello.sh 

#################################################
简单脚本技巧

重定向输出
     >:只收集前面命令的正确输出信息
     2>:只收集前面命令的错误输出信息
     &>:收集前面命令的正确与错误信息

[root@server0 ~]# cat /etc/redhat-release 
[root@server0 ~]# cat /xixi

[root@server0 ~]# cat /etc/redhat-release /xixi

]# cat /etc/redhat-release /xixi  >  /opt/1.txt
]# cat /opt/1.txt 

]# cat /etc/redhat-release /xixi  2>   /opt/2.txt
]# cat /opt/2.txt 

]# cat /etc/redhat-release /xixi  &>   /opt/3.txt
]# cat /opt/3.txt 

####################################################
案例:书写一个创建用户设置密码的脚本
      /dev/null:黑洞设备

[root@server0 ~]# vim  /root/user.sh
#!/bin/bash
useradd nsd04 &> /dev/null
echo 用户nsd04创建成功
echo 123 | passwd --stdin  nsd04 &> /dev/null
echo 用户nsd04密码设置成功
[root@server0 ~]# chmod +x   /root/user.sh

[root@server0 ~]# /root/user.sh


 为了让脚本,适应多变需求,所以使用变量

 变量:会变化的量     类似容器
        以不变的名称,存储可以变化的值               

 定义变量:
      变量名=存储的值

  使用变量储存的值:     $变量名

[root@server0 ~]# vim /root/user.sh
#!/bin/bash
a=dc
useradd $a  &> /dev/null
echo 用户$a创建成功
echo 123 | passwd --stdin  $a  &> /dev/null
echo 用户$a密码设置成功


  提高用户体验度,产生交互
   read
            1.直接产生交互,等待用户输入
            2.记录用户在键盘上的输入
            3.将记录的内容,赋值给一个变量储存
   -p  '屏幕提示信息'

[root@server0 ~]# vim  /root/user.sh
#!/bin/bash
read -p '请您输入要创建的用户名:'   a
read -p '请您输入要设置的密码:'   b
useradd $a &> /dev/null
echo 用户$a创建成功
echo $b  | passwd --stdin  $a &> /dev/null
echo 用户$a密码设置成功

[root@server0 ~]# 


什么是变量
• 以不变的名称存放的可能会变化的值
– 变量名=变量值
– 方便以固定名称重复使用某个值
– 提高对任务需求、运行环境变化的适应能力

定义/赋值变量
• 设置变量时的注意事项
– 等号两边不要有空格
– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符
– 若指定的变量名已存在,相当于为此变量重新赋值


  以下有效变量名为: B
  A.2008file   B.tun_01  C a-b   D a_ccd_9-abc

查看/引用变量
• 基本格式
– 引用变量值:$变量名
– 查看变量值:echo $变量名、echo ${变量名}

[root@server0 ~]# a=rhel
[root@server0 ~]# echo $a
rhel
[root@server0 ~]# echo $a7

[root@server0 ~]# echo ${a}7
rhel7

################################################
  单引号' ':取消所有特殊字符的意义,原样输出
[root@server0 ~]# echo '********'
********
[root@server0 ~]# echo '| ? * {} [] > '
| ? * {} [] > 
[root@server0 ~]# 

  反撇号 ` `  或  $(  ) 
       :将命令的输出,直接参与另一条命令的运行,作为另一条命令的参数
[root@server0 ~]# mkdir /opt/nsd`date +%F`
[root@server0 ~]# ls /opt/
[root@server0 ~]# mkdir /opt/`hostname`-`date  +%F`
[root@server0 ~]# ls /opt/

[root@server0 ~]# mkdir /opt/abc-$(date  +%F)
[root@server0 ~]# ls /opt/
###################################################

环境变量
    变量名为大写字母,由系统定义并且赋值完成

   USER=当前登录的用户名
[root@server0 ~]# echo $USER
root
[root@server0 ~]# su - student
[student@server0 ~]$ echo $USER
student
[student@server0 ~]$ exit
logout
[root@server0 ~]# su - nsd01
[nsd01@server0 ~]$ echo $USER
nsd01
[nsd01@server0 ~]$ 

#################################################

位置变量
• 由系统定义并且赋值完成
• 在执行脚本时提供的命令行参数
– 表示为 $n,n为序号
– $1、$2、.. .. ${10}、${11}、.. ..

[root@server0 ~]# vim  /root/user.sh 
#!/bin/bash
#read  -p  '请您输入要创建的用户名:'    a
#read  -p  '请您输入要设置的密码:'   b
useradd $1 &> /dev/null
echo 用户$1创建成功
echo  123  | passwd --stdin  $1 &> /dev/null
echo 用户$1密码设置成功
[root@server0 ~]#  /root/user.sh  natasha

[root@server0 ~]# vim  /root/1.sh
#!/bin/bash
cat -n  $1  |  head -$2
echo 您输入的文件为$1
echo 显示文件内容的头$2行
[root@server0 ~]# /root/1.sh  /etc/passwd  3
####################################################

预定义变量
• 由系统定义并且赋值完成                                    
  $#  已加载的位置变量的个数
  $?  程序退出后的状态值,0表示正常,其他值异常

[root@server0 ~]# vim /root/2.sh
#!/bin/bash
echo $1
echo $2
echo $3
echo $#
[root@server0 ~]# chmod +x /root/2.sh
[root@server0 ~]# /root/2.sh  haha xixi hehe lele

###################################################
条件测试

   [ 测试表达式 ]  每一部分都要有空格


常用的测试选项
• 检查文件状态
 -e:文档存在为真
 -d:文档存在,且必须为目录才为真
 -f:文档存在,且必须为文件才为真
[root@server0 ~]# [ -e /etc ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ -e /xixi ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -d /etc/passwd ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -f /etc/passwd ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# 

• 比较整数大小
  -gt:大于
  -ge:大于等于
  -eq:等于
  -ne:不等于
  -lt:小于
  -le:小于等于
[root@server0 ~]# [ 1 -eq 2 ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ 1 -eq 1 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ 10 -gt 9 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ 9 -ge 9 ]
[root@server0 ~]# echo $?

• 字符串比对
    ==:一致为真
    !=:不一致为真
[root@server0 ~]# [ student == dc ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ student == root ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ student != root ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ $USER == root ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# 
##################################################
if双分支处理

	if  [条件测试];then
	  命令序列xx
	else
	  命令序列yy
	fi

[root@server0 ~]# vim  /root/if01.sh
#!/bin/bash
if  [  $1  -eq  1  ];then
  echo hello
else
  echo hi
fi
[root@server0 ~]# /root/if01.sh 1
[root@server0 ~]# /root/if01.sh 2


案例:利用read获取,用户所输入的用户名
  进行判断,如果用户名当前系统已存在,则输出 用户已存在    
  进行判断,如果用户名当前系统不存在,则输出 用户不存在
[root@server0 ~]# vim  /root/if02.sh      
#!/bin/bash
read  -p  '请输入您要测试的用户名:'    a
id $a  &> /dev/null
if [  $?  -eq  0  ];then
  echo  $a用户已存在
else
  echo  $a用户不存在
fi
[root@server0 ~]# 


案例:利用read获取,用户所输入的IP地址
  进行判断,如果当前系统可以与该IP地址通信,则输出 可以ping通 
  进行判断,如果当前系统不可以与该IP地址通信,则输出 不可以ping通 
[root@server0 ~]# vim /root/if03.sh 
 #!/bin/bash
 read  -p  '请输入您要测试的IP地址:'    ip
 ping -c 2 $ip &> /dev/null
 if [ $? -eq 0 ];then
  echo $ip可以通信
 else
  echo $ip不可以通信
 fi

 ##################################################
if多分支处理

	if [条件测试1];then
	  命令序列xx
	elif [条件测试2];then
	  命令序列yy
	elif [条件测试3];then
	  命令序列aa
       ..........
	else
	  命令序列zz
	fi

案例:利用read获取,用户所输入的成绩 
 进行判断
    如果大于等于90,则输出  优秀
    如果大于等于80,则输出  良好
    如果大于等于70,则输出  一般
    如果大于等于60,则输出  合格
    以上条件均不满足,则输出 再牛的肖邦,也弹不出哥的悲伤

[root@server0 ~]# vim  /root/if04.sh
 #!/bin/bash
 read  -p  '请输入您的成绩:'     num
 if  [ $num  -ge  90 ];then
   echo  优秀
 elif  [ $num -ge  80 ];then
   echo  良好
 elif  [ $num -ge  70 ];then
   echo  一般
 elif  [ $num -ge  60 ];then
   echo  合格
 else
   echo  '再牛的肖邦,也弹不出哥的悲伤!'
 fi

####################################################
列表式循环,反复执行类似的操作

for循环处理
• 遍历/列表式循环
– 根据变量的不同取值,重复执行xx处理

	for 变量名  in 值列表
	do
	   命令序列
	done

    for 献血车  in  zhangsan  lisi  wangwu
	do
	    抽血
	done

[root@server0 ~]# vim  /root/for01.sh     
#!/bin/bash
for a  in  zhangsan lisi  wangwu  natasha  harry jack
do
  useradd $a &> /dev/null
  echo $a创建成功
done
[root@server0 ~]# 


列表值可以不参与循环执行的操作

造数工具: {起始..结束}    

   {1..20}:制造1到20之间连续的数字

[root@server0 ~]# vim /root/for01.sh 
#!/bin/bash
for a  in  {1..20}
do
  echo Hello World
done

###################################################
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: 
  /root/foo.sh  redhat|fedora

[root@server0 ~]# vim /root/foo.sh 
#!/bin/bash
if [ $# -eq 0 ];then     #判断用户是否输入参数
 echo '/root/foo.sh  redhat|fedora' >&2  #将正确输出变成错误输出
 exit 38   #脚本退出返回值
elif [ $1 == redhat ];then   #判断参数是否是redhat
 echo fedora
elif [ $1 == fedora ];then   #判断参数是否是fedora
 echo redhat
else
 echo '/root/foo.sh  redhat|fedora' >&2   #将正确输出变成错误输出
 exit 48  #脚本退出返回值
fi

########################################################

案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示
 Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
 http://classroom.example.com/pub/materials/userlist

[root@server0 ~]# vim /root/batchusers
 #!/bin/bash
 if  [ $# -eq 0 ];then                #判断用户是否输入参数
  echo 'Usage: /root/batchusers' >&2
  exit 2
 elif [ -f $1 ];then　　　　　　　　＃判断用户输入的文件是否存在
  for a  in $(cat $1)
  do
   useradd -s /bin/false $a  &> /dev/null
   echo $a创建成功
  done
 else
  echo 'Input file not found' >&2
  exit 3
 fi
[root@server0 ~]# /root/batchusers  /root/userlist

###########################################################
系统安全保护

SELinux安全机制

• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系
– 集成到Linux内核(2.6及以上)中运行
– RHEL7基于SELinux体系针对用户、进程、目录和文件
提供了预设的保护策略,以及管理工具

• SELinux的运行模式
– enforcing(强制)、permissive(宽松)             
– disabled(彻底禁用)

  所有状态变成disabled(彻底禁用),都要经历重启系统

• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件

虚拟机server
[root@server0 ~]# getenforce    #查看SELinux当前系统状态
Enforcing
[root@server0 ~]# setenforce 0  #修改SELinux状态,为宽松模式
[root@server0 ~]# getenforce 
Permissive  
[root@server0 ~]# vim /etc/selinux/config#SELinux状态永久配置文件
SELINUX=permissive

虚拟机desktop
[root@desktop0 ~]# getenforce 
Enforcing
[root@desktop0 ~]# setenforce 0
[root@desktop0 ~]# getenforce 
Permissive
[root@desktop0 ~]# vim /etc/selinux/config 
SELINUX=permissive
##########################################################
用户个性化配置文件
• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效

全局环境配置
• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

虚拟机server0
[root@server0 ~]# vim /home/student/.bashrc 
alias hello='echo  hello'
[root@server0 ~]# vim /root/.bashrc 
alias hi='echo  hi'
[root@server0 ~]# vim /etc/bashrc 
alias dc='echo  dc'

#######################################################
搭建基本Web服务,提供一个网页内容
  http协议:超文本传输协议,专用于传输页面内容

服务端:虚拟机server
1.安装httpd软件包
[root@server0 ~]# yum -y install httpd
2.重启httpd服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd
ln -s '/usr/lib/systemd/system/httpd.service' '/etc/systemd/system/multi-user.target.wants/httpd.service'

3.本机测试
[root@server0 ~]# firefox 172.25.0.11         

4.书写自己的页面
   默认存放文件文件路径:/var/www/html/
   默认网页文件名称:index.html
[root@server0 ~]# cat  /var/www/html/index.html
<marquee><font  color=red><h1>NSD1904hahaxixi
  滚动            字体颜色            标题字体
[root@server0 ~]# 

#######################################################
搭建基本的FTP服务

  FTP:文件传输协议

默认FTP服务共享位置:/var/ftp/

虚拟机server
1.安装vsftpd软件
[root@server0 ~]# yum -y install vsftpd
2.重启vsftpd服务
[root@server0 ~]# systemctl restart  vsftpd
[root@server0 ~]# systemctl enable  vsftpd
3.本机验证
[root@server0 ~]# firefox ftp://172.25.0.11

##########################################################
防火墙策略管理
   
    作用:隔离,进行入站过滤

 硬件防火墙
 软件防火墙

 firewalld服务基础
Linux的防火墙体系
• 系统服务:firewalld
• 管理工具:firewall-cmd、firewall-config

预设安全区域
• 根据所在的网络场所区分,预设保护规则集
 – public:仅允许访问本机的sshd dhcp  ping 
 – trusted:允许任何访问
 – block:拒绝任何来访请求(明确拒绝回应)
 – drop:丢弃任何来访的数据包(直接丢弃不给回应,节省服务器资源)

 数据包: 源IP地址  目标IP地址   数据

防火墙的判定规则
1.查看请求数据包,中客户端来源IP地址,查看自己所有区域规则,如果某一个区域有该源IP地址的规则,则进入该区域

2.进入默认区域public

#######################################################
防火墙默认区域修改
虚拟机server
]# firewall-cmd --get-default-zone  #查看默认区域
虚拟机desktop
]# ping  172.25.0.11   #可以通信

虚拟机server
]# firewall-cmd --set-default-zone=block   #修改默认区域为block
]# firewall-cmd --get-default-zone    #查看默认区域
虚拟机desktop
]# ping  172.25.0.11  #不可以通信,有回应

虚拟机server
]# firewall-cmd --set-default-zone=drop  #修改默认区域为drop
]# firewall-cmd --get-default-zone   #查看默认区域
虚拟机desktop
]# ping  172.25.0.11  #不可以通信,没有回应
###########################################################
常见的互联网协议:
           http:超文本传输协议    默认端口:80 
           FTP:文本传输协议   默认端口:21
           https:安全的超文本传输协议   默认端口:443
           DNS:域名解析协议      默认端口:53
           telnet:远程管理协议     默认端口:23
           tftp:简单的文本传输协议   默认端口:69
           smtp:发邮件协议    默认端口:25
           pop3:收邮件协议    默认端口:110
           snmp:简单的网络管理协议   默认端口:161 


在默认区域添加协议:
虚拟机server:
]# firewall-cmd --set-default-zone=public  #修改默认区域为public
]# firewall-cmd --get-default-zone 
]# firewall-cmd --zone=public  --list-all  #查看区域详细规则
虚拟机desktop
]# firefox 172.25.0.11        #失败
]# firefox ftp://172.25.0.11  #失败

虚拟机server:
]# firewall-cmd --zone=public  --list-all
]# firewall-cmd --zone=public  --add-service=http #添加允许的协议
]# firewall-cmd --zone=public  --add-service=ftp #添加允许的协议
]# firewall-cmd --zone=public  --list-all
虚拟机desktop
]# firefox 172.25.0.11        #成功
]# firefox ftp://172.25.0.11  #成功

##########################################################
防火墙永久策略                                                    

– 永久(permanent)
]# firewall-cmd --reload   #重新加载防火墙所有配置

]# firewall-cmd --permanent --zone=public  --add-service=http
]# firewall-cmd --permanent --zone=public  --add-service=ftp
]# firewall-cmd --zone=public --list-all 

]# firewall-cmd --reload  #重新加载防火墙所有配置

]# firewall-cmd --zone=public --list-all 

#########################################################
单独拒绝虚拟机desktop的访问

]# firewall-cmd --zone=block --add-source=172.25.0.10
]# firewall-cmd --zone=block --list-all 


#########################################################

 端口:编号    标识协议或服务 可以具备多个
           由root指定

数据包: 源IP地址   目标IP地址   端口号    数据

实现本机的端口映射
• 本地应用的端口重定向(端口1 --> 端口2)                            
– 从客户机访问 端口1 的请求,自动映射到本机 端口2
– 比如,访问以下两个地址可以看到相同的页面:
  http://172.25.0.11:5423 --->  http://172.25.0.11:80

虚拟机server
]# firewall-cmd --permanent --zone=public  --add-forward-port=port=5423:proto=tcp:toport=80

]# firewall-cmd --reload 

]# firewall-cmd --zone=public --list-all

虚拟机desktop
]# firefox  172.25.0.11:5423 

#########################################################


宽松模式:
默认区域为trusted,把拒绝的客户端源IP地址写入block,拒绝的较少允许较多

严格模式:
默认区域为block,把允许的客户端源IP地址写入trusted,拒绝的较多允许较少


###########################################################

交换空间(虚拟内存)
   当真实物理内存不够用时,会启用交换空间,将不常用的内存数据暂时放入到,交换空间中,缓解内存不足

   利用硬盘的空间来充当交换空间(虚拟内存)


1.划分新的分区
[root@server0 ~]# fdisk /dev/vdb   #划分两个主分区分别为2G
[root@server0 ~]# lsblk 
[root@server0 ~]# ls /dev/vdb[1-2]

2.格式化文件系统swap(交换文件系统)
[root@server0 ~]# mkswap /dev/vdb1
[root@server0 ~]# mkswap /dev/vdb2

[root@server0 ~]# blkid /dev/vdb1
[root@server0 ~]# blkid /dev/vdb2

3.启用交换分区
[root@server0 ~]# swapon /dev/vdb1 
[root@server0 ~]# swapon -s          #查看组成交换空间的成员

[root@server0 ~]# swapon /dev/vdb2
[root@server0 ~]# swapon -s          #查看组成交换空间的成员

4.开机自动启用交换分区
[root@server0 ~]# vim /etc/fstab    
/dev/vdb1  swap  swap defaults 0 0
/dev/vdb2  swap  swap defaults 0 0

[root@server0 ~]# swapon -s
[root@server0 ~]# swapoff  /dev/vdb1   #停用交换分区/dev/vdb1
[root@server0 ~]# swapoff  /dev/vdb2   #停用交换分区/dev/vdb2
[root@server0 ~]# swapon -s 

[root@server0 ~]# swapon -a    #专用于检测交换分区开机自动挂载
[root@server0 ~]# swapon -s

################################################

一  环境设置
虚拟机server
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@server0 ~]# firewall-cmd --get-default-zone 
虚拟机desktop
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --get-default-zone 
##########################################################
iSCSI网络磁盘

• Internet SCSI,网际SCSI接口(默认端口:3260)
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

一 划分一个主分区3G
[root@server0 ~]# fdisk  /dev/vdb
[root@server0 ~]# lsblk 
[root@server0 ~]# ls /dev/vdb1


二 服务端选择虚拟机server,构建iSCSI共享存储

• backstore,后端存储
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称      

• target,磁盘组
– 是客户端的访问目标,作为一个框架,由多个lun组成

• ISCSI Qualified Name(iqn) 名称规范           
– iqn.yyyy-mm.倒序域名:自定义标识
– 用来识别 target 磁盘组,也用来识别客户机身份

• 名称示例
– iqn.2016-02.com.example:server0




• lun,逻辑单元
– 每一个lun需要关联到某一个后端存储设备,在客户端会视为一块虚拟硬盘

             冰箱------->纸质的包装       木质的箱子

1.安装targetcli软件包
[root@server0 ~]# yum -y install targetcli

2.配置  
   a)建立backstore,后端存储(冰箱)
[root@server0 ~]# targetcli 
/> ls
/> backstores/block  create  name=nsd  dev=/dev/vdb1
/> ls

   b)建立target磁盘组(建立木质的箱子)
     iqn.yyyy-mm.倒序域名:自定义标识

/> iscsi/ create  iqn.2019-05.com.example:server0
/> ls

   c)进行lun关联(冰箱----->木质的箱子)
/> iscsi/iqn.2019-05.com.example:server0/tpg1/luns     create   /backstores/block/nsd 

/> ls

   d)设置访问控制ACL,设置客户端声称的名字(符合iqn命名规范)
/> iscsi/iqn.2019-05.com.example:server0/tpg1/acls    create   
 iqn.2019-05.com.example:abc

/> ls
   
   e)指定本机开放共享服务的IP地址及端口
/> iscsi/iqn.2019-05.com.example:server0/tpg1/portals create 172.25.0.11 

/> ls

[root@server0 ~]# systemctl restart target   #重启服务
[root@server0 ~]# systemctl enable target    #设置开机自动
ln -s '/usr/lib/systemd/system/target.service' '/etc/systemd/system/multi-user.target.wants/target.service'
[root@server0 ~]# 
###########################################################
虚拟机desktop:客户端
1.安装客户端软件
• 所需软件包:iscsi-initiator-utils
Yum安装软件时可以补全包名:
             前提1:必须有Yum缓存,  yum  repolist  可以直接生成缓存
             前提2:必须是当前系统没有安装
[root@desktop0 ~]# rpm -q  iscsi-initiator-utils
iscsi-initiator-utils-6.2.0.873-21.el7.x86_64
[root@desktop0 ~]# yum -y install iscsi(tab)

2.配置客户端声称的名字
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi
InitiatorName=iqn.2019-05.com.example:abc

3.客户端刷新声称名字的服务
[root@desktop0 ~]# systemctl restart iscsid
  Warning: Unit file of iscsid.service changed on  
  disk, 'systemctl daemon-reload' recommended.
[root@desktop0 ~]# systemctl daemon-reload
[root@desktop0 ~]# systemctl restart iscsid

4.发现服务端共享存储
  Linux查看命令帮助的方法 :  man  iscsiadm 
   全文查找/example   按n项下跳转匹配,看到EXAMPLES

   Ctrl    - ：减小字体
   Ctrl   Shift   + ：变大字体     

[root@desktop0 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover

172.25.0.11:3260,1 iqn.2019-05.com.example:server0

5.使用服务端共享存储
[root@desktop0 ~]# lsblk 
[root@desktop0 ~]# systemctl restart iscsi  #重启客户端服务
[root@desktop0 ~]# lsblk 
[root@desktop0 ~]# systemctl enable iscsi   #设置开机自启动服务


#########################################################
总结:
服务端:
1.修改防火墙默认区域trusted
2.安装targetcli软件
3.运行targetcli命令进行配置
   1)建立后端存储
   2)建立target磁盘
   3)进行lun关联
   4)设置ACL访问控制
   5)设置启用IP地址 默认端口为3260
4.重启target服务

客户端:
1.修改防火墙默认区域trusted
2.所需软件包:iscsi-initiator-utils
3.修改配置文件/etc/iscsi/initiatorname.iscsi
4.客户端刷新声称名字的服务 systemctl restart iscsid

5.发现共享存储
]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover

6.使用共享存储
]# systemctl enable iscsi 

########################################################
数据库服务基础

  什么是数据库:存放数据的仓库

– 社区开源版 MariaDB

部署mariadb数据库服务器
• RHEL7 中的 MariaDB 相关包
– mariadb-server:提供服务端有关的系统程序

[root@server0 ~]# yum -y install mariadb-server
[root@server0 ~]# systemctl restart mariadb

 在数据库中,有众多的库,在每一个库中有很多的表格

一 数据库的基本操作                                           
[root@server0 ~]# mysql

MariaDB [(none)]> show databases;          #显示所有库
MariaDB [(none)]> create database nsd01;   #创建库nsd01

MariaDB [(none)]> show databases;          
MariaDB [(none)]> drop database nsd01;    #删除nsd01库

MariaDB [(none)]> show databases;
MariaDB [(none)]> create database nsd1904;
MariaDB [(none)]> show databases;
MariaDB [(none)]> exit

######################################################
二 为数据库管理员设置密码
    数据库管理员root,针对数据库具有最高权限,信息存放mysql库中user表
    系统管理员root,针对系统具有最高权限,信息存放/etc/passwd

命令格式: mysqladmin [-u用户名] [-p[旧密码]] password '新密码'

[root@server0 ~]# mysqladmin -u root  password '123'

[root@server0 ~]# mysql -u root -p     #交互式
Enter password: 
 
[root@server0 ~]# mysql -u root -p123  #非交互式

已知旧密码修改新密码
[root@server0 ~]# mysqladmin -u root -p123 password '321'
#########################################################
数据库的主配置文件:/etc/my.cnf

#########################################################

• 导入/恢复到数据库
– mysql [-u用户名] [-p[密码]] 数据库名 < 备份文件.sql

]# wget http://classroom.example.com/pub/materials/users.sql
]# ls
]# mysql -u root -p123 nsd1904 < /root/users.sql 

• 查看库中有哪些表格
[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd1904;   #切换到nsd1904库
MariaDB [nsd1904]> show tables;   #显示当前库有那些表格

表格:  表字段   表记录

           编号       姓名       联系方式          居住地址
        1      dc    138.....     东村
        2      tc    138.....     西村

表格:    增(insert)     删(delete)      改(update)    查(select)

查(select)
格式: select  表字段,表字段.....    from  库名.表名称     

[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> use nsd1904;           #进入nsd1904库
MariaDB [(none)]> show tables;           #显示库中所有表格
MariaDB [(none)]> select * from base;
MariaDB [(none)]> select * from location;
MariaDB [(none)]> select name,password from base;

MariaDB [(none)]> use mysql;
MariaDB [(none)]> select * from nsd1904.base;

########################################################
查看表结构: desc 表名字;
MariaDB [(none)]> desc nsd1904.base;
MariaDB [(none)]> desc mysql.user;

MariaDB [nsd1904]> select user,host,password from mysql.user;

########################################################
条件查询:
MariaDB [nsd1904]> use nsd1904;

MariaDB [nsd1904]> select * from base;
MariaDB [nsd1904]> select * from base where password='123';
MariaDB [nsd1904]> select * from base where password='456';
MariaDB [nsd1904]> select * from base where name='tom';

MariaDB [nsd1904]> select * from base where id='4';

########################################################
除了root用户,此nsd1904库只能被用户lisi查询,此用户的密码为123

数据库的授权

 GRANT 权限列表  ON 数据库名.表名 TO 用户名@客户机地址
 IDENTIFIED BY  '密码';


    grant select on nsd1904.*  to  lisi@localhost identified by '123';
   
    当lisi通过本地localhost登录,输入密码为123,将会获得nsd1904库中所有表格的查询权限.

[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> grant  select on nsd1904.* to lisi@localhost  identified by '123';


MariaDB [(none)]> select user,host,password from mysql.user;
MariaDB [(none)]> exit

[root@server0 ~]# mysql -u lisi -p123   #检测lisi登录
MariaDB [(none)]> show databases;
MariaDB [(none)]> exit

#########################################################
案例4:使用数据库查询
2. 在系统 server0 上使用数据库 nsd1904,并使用相        
应的 SQL 查询以回答下列问题:
1)密码是 solicitous 的人的名字?
[root@server0 ~]# mysql -u root -p123
> use nsd1904;
> select * from base;
> select * from base where password='solicitous';

2)有多少人的姓名是 Barbara 同时居住在 Sunnyvale?
> select * from base,location         
 where base.name='Barbara' and location.city='Sunnyvale' and 
 base.id=location.id ;

> select count(*)  from base,location         
 where base.name='Barbara' and location.city='Sunnyvale' and 
 base.id=location.id ;

> insert base values ('6','Barbara','789');
> select * from base;

> insert location values ('6','Sunnyvale');
> select * from location;


1. 禁止空密码root用户访问 mariadb 数据库
> use mysql;
> select user,host,password from user;
> select user,host,password from user where password=''; 

#删除表中password值为空的记录
> delete from user where password='';  

> select user,host,password from user;

> flush privileges;  #刷新user表记录
> exit 

验证登录失败:
[root@server0 ~]# mysql -u root -h server0.example.com
ERROR 1130 (HY000): Host 'server0.example.com' is not allowed to connect to this MariaDB server

##########################################################

配置NFS共享
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)、RPC(TCP/UDP 111)
• 所需软件包:nfs-utils
• 系统服务:nfs-server

一  环境设置
虚拟机server
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@server0 ~]# firewall-cmd --get-default-zone
虚拟机desktop
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --get-default-zone

二  虚拟机server构建NFS共享

1.安装nfs-utils软件包
[root@server0 ~]# rpm -q nfs-utils
nfs-utils-1.3.0-0.el7.x86_64
[root@server0 ~]# 
2.修改配置文件
[root@server0 ~]# mkdir /nsd01              #创建共享目录
[root@server0 ~]# echo haha > /nsd01/a.txt  #建立测试文件
[root@server0 ~]# ls /nsd01

[root@server0 ~]# vim /etc/exports
 文件夹路径    客户机地址(权限)  客户机地址(权限) .. ..
/nsd01   *(ro)      #将/nsd01目录共享给所有客户端,可以只读方式访问

[root@server0 ~]# systemctl restart nfs-server  #重启服务
[root@server0 ~]# systemctl enable nfs-server  #设置开机自启动

虚拟机desktop                             
[root@desktop0 ~]# mkdir /mnt/test
[root@desktop0 ~]# ls /mnt/test
[root@desktop0 ~]# showmount -e 172.25.0.11  #显示服务端共享路径
[root@desktop0 ~]# mount 172.25.0.11:/nsd01  /mnt/test/
[root@desktop0 ~]# df -h

开机自动挂载
   _netdev:声明网络设备,Linux先部署网络所有参数,在进行挂载该设备

[root@desktop0 ~]# vim /etc/fstab  
172.25.0.11:/nsd01    /mnt/test   nfs   defaults,_netdev  0 0 

[root@desktop0 ~]# umount /mnt/test/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
#########################################################
HTTP服务基础

Web通信基本概念
• 基于 B/S (Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页
• Hyper Text Transfer Protocol(http),超文本传输协议
• Hyper Text Markup Language(html),超文本标记语言


提供Web服务的软件
  httpd(Apache)、nginx、tomcat


• 软件包:httpd
• 系统服务:httpd
• 提供的默认配置
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)

虚拟机server:构建基本的Web服务
1.安装httpd
2.重启httpd服务
]# systemctl restart httpd
3.设置httpd服务开机自启
4.书写一个网站内容
]# echo '<h1>NSD1904 Web1' > /var/www/html/index.html
]# cat /var/www/html/index.html

]# firefox 172.25.0.11

########################################################
 DocumentRoot:设置存放网页文件的路径(设置网页文件根目录)
  
虚拟机server:
]# mkdir /var/www/myweb
]# echo '<h1>wo shi myweb' > /var/www/myweb/index.html

]# vim /etc/httpd/conf/httpd.conf   #全文命令模式下  搜索 /Doc

DocumentRoot  "/var/www/myweb"

]# systemctl restart httpd
]# firefox 172.25.0.11

######################################################
实际路径与网络路径(浏览器中输入的路径)

客户端:firefox 172.25.0.11:80 ----->服务端 httpd---->主配置 DocumenRoot /var/www/myweb -----> /var/www/myweb

客户端:firefox 172.25.0.11 
服务端:/var/www/myweb

客户端:firefox 172.25.0.11/abc
服务端:/var/www/myweb/abc

客户端:firefox 172.25.0.11/nsd
服务端:/var/www/myweb/nsd

DocumenRoot /var/www/myweb
客户端:firefox 172.25.0.11/var/www/myweb
服务端:/var/www/myweb/var/www/myweb

虚拟机server
]# mkdir /var/www/myweb/abc
]# echo '<h1>wo shi abc' > /var/www/myweb/abc/index.html
]# firefox 172.25.0.11/abc

#########################################################
Web访问控制,默认继承父目录访问控制

访问控制的配置字段:

<Directory  "/var/www">
    Require all granted   #允许所有人访问
</Directory>

<Directory  "/var/www">
    Require ip 172.25.0.10   #仅允许172.25.0.10访问
</Directory>

<Directory  "/var/www">
    Require all denied   #拒绝所有人访问
</Directory>
#######################################################
<Directory  "/var/www">
    Require all denied   #拒绝所有人访问
</Directory>

<Directory  "/var/www/test">
    Require all granted  #允许所有人访问
</Directory>

 /var/www/路径下的页面,拒绝所有人访问
 /var/www/test路径下的页面,允许所有人访问
 /var/www/abc路径下的页面,拒绝所有人访问
 /var/www/abc/nsd路径下的页面,拒绝所有人访问



#######################################################

案例:
修改网页文件,存放路径为/webroot
1.创建路径写入网页文件
]# mkdir /webroot
]# echo '<h1>wo shi webroot' > /webroot/index.html
]# ls /webroot/

2.修改配置文件
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
DocumentRoot "/webroot"

<Directory   "/webroot">    #针对/webroot进行访问控制配置
    Require  all  granted   #允许所有人访问
</Directory>
[root@server0 ~]# setenforce 0   #将SELinux设置宽松模式
[root@server0 ~]# getenforce     #查看SELinux状态

[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# firefox 172.25.0.11
#########################################################
虚拟Web主机
– 由同一台服务器提供多个不同的Web页面

• 区分方式
– 基于域名的虚拟主机
– 基于端口的虚拟主机
– 基于IP地址的虚拟主机

域名可以DNS解析 :
  DNS服务器虚拟机classroom

     server0.example.com
     www0.example.com
     webapp0.example.com

• 为每个虚拟站点添加配置
  <VirtualHost IP地址:端口>
    ServerName 此站点的DNS名称
    DocumentRoot 此站点的网页根目录
  </VirtualHost>




• 配置文件路径
– /etc/httpd/conf/httpd.conf  主配置文件
– /etc/httpd/conf.d/*.conf    调用配置文件


虚拟机server
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf #调用配置文件
<VirtualHost *:80>                   #启用虚拟Web主机功能
   ServerName  server0.example.com   #设置访问的域名
   DocumentRoot  /var/www/qq         #设置存放网页文件目录
</VirtualHost>

<VirtualHost *:80>                #启用虚拟Web主机功能
   ServerName  www0.example.com   #设置访问的域名
   DocumentRoot  /var/www/baidu   #设置存放网页文件目录
</VirtualHost>
           
[root@server0 ~]# mkdir /var/www/qq /var/www/baidu
[root@server0 ~]# echo '<h1>企鹅' > /var/www/qq/index.html
[root@server0 ~]# echo '<h1>百度' > /var/www/baidu/index.html
[root@server0 ~]# systemctl restart httpd

[root@desktop0 ~]# firefox server0.example.com    
[root@desktop0 ~]# firefox www0.example.com

#########################################################
 一旦使用了虚拟Web主机功能,所有的网站都必须使用虚拟Web主机实现
如果直接使用IP地址进行访问,默认会将第一个虚拟Web主机页面内容呈现

[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
   ServerName server0.example.com
   DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
   ServerName www0.example.com
   DocumentRoot /var/www/baidu
</VirtualHost>
<VirtualHost *:80>
   ServerName webapp0.example.com
   DocumentRoot /var/www/myweb
</VirtualHost>
[root@server0 ~]# systemctl  restart httpd
#########################################################

一  环境设置
虚拟机server
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@server0 ~]# firewall-cmd --get-default-zone
虚拟机desktop
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --get-default-zone

二 虚拟机server构建基于域名的虚拟Web主机
- 实现三个网站的部署
- 实现客户端访问server0.example.com网页内容为 卖女孩的小火柴
- 实现客户端访问www0.example.com网页内容为  奔跑吧骆驼
- 实现客户端访问webapp0.example.com网页内容为 20里春风不如你

[root@server0 ~]# yum -y install httpd
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost  *:80>
 ServerName  server0.example.com
 DocumentRoot /var/www/nsd01
</VirtualHost>
<VirtualHost  *:80>
 ServerName  www0.example.com                 
 DocumentRoot /var/www/nsd02
</VirtualHost>
<VirtualHost  *:80>
 ServerName  webapp0.example.com              
 DocumentRoot /var/www/nsd03
</VirtualHost>

]# cd /var/www/
]# mkdir nsd01 nsd02  nsd03
]# echo '<h1>卖女孩的小火柴' > /var/www/nsd01/index.html
]# echo '<h1>奔跑吧骆驼' > /var/www/nsd02/index.html
]# echo '<h1>20春风不如你' > /var/www/nsd03/index.html
]# systemctl restart httpd

###########################################################
文件夹权限
• 针对 DocumentRoot 网页目录的权限控制
• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的ACL访问权限
– 除非针对子目录有明确设置

案例1:虚拟机server配置网页内容访问
在 Web 网站 http://server0.example.com 的
DocumentRoot 目录下创建一个名为 private 的子目录,要求如下:

1.查看server0.example.com的DocumentRoot目录路径
]# cat /etc/httpd/conf.d/nsd01.conf 
]# mkdir /var/www/nsd01/private
]# echo '<h1>wo shi private' > /var/www/nsd01/private/index.html

]# firefox server0.example.com/private

2.从虚拟机server0上,任何人都可以浏览 private 的内容
但是从其他系统不能访问这个目录的内容
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf 
<Directory  "/var/www/nsd01/private">
    Require ip 172.25.0.11     #仅允许172.25.0.11进行访问
</Directory>

[root@server0 ~]# systemctl restart httpd


虚拟机desktop0:访问测试权限不足
]# firefox server0.example.com/private
Forbidden

You don't have permission to access /private/ on this server.

##########################################################
案例2:使用自定Web根目录
调整 Web 站点 http://server0.example.com 的网页
目录,要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
]# mkdir /webroot
]# echo '<h1>wo shi Webroot' > /webroot/index.html
]# ls /webroot/

[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost  *:80>
 ServerName  server0.example.com
 DocumentRoot /webroot
</VirtualHost>
........
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf
........
<Directory "/webroot">
    Require all granted
</Directory>

[root@server0 ~]# systemctl restart httpd




SELinux三大策略:  1.布尔值   2.安全上下文   3.非默认端口的开放    

[root@server0 ~]# setenforce 1       #开启SELinux
[root@server0 ~]# getenforce         #查看SELinux状态

SELinux安全上下文(标签值)
[root@server0 ~]# ls -Zd /var/www/   #查看目录的上下为值
[root@server0 ~]# ls -Zd /webroot/
• 方式1:参照标准目录,重设新目录的属性
– chcon [-R] --reference=模板目录   新目录

[root@server0 ~]# chcon -R --reference=/var/www  /webroot/
[root@server0 ~]# ls -Zd /webroot/

########################################################
部署动态网站

静态网站的运行
• 服务端的原始网页 = 浏览器访问到的网页
– 由Web服务软件处理所有请求
– 文本(txt/html)、图片(jpg/png)等静态资源

动态网站的运行
• 服务端的原始网页 ≠ 浏览器访问到的网页
– 由Web服务软件接受请求,动态程序转后端模块处理
– PHP网页、Python网页、JSP网页......


虚拟机server新建一个动态站点站点名称为 webapp0.example.com
1.部署Python页面
[root@server0 ~]# cat /etc/httpd/conf.d/nsd01.conf 
[root@server0 ~]# cd /var/www/nsd03
[root@server0 nsd03]# wget http://classroom.example.com/pub/materials/webinfo.wsgi

[root@server0 nsd03]# cat webinfo.wsgi

2.方便用户的访问,页面跳转(页面别名   地址重写)

浏览器中输入: firefox  webapp0.example.com
服务端:/var/www/nsd03/webinfo.wsgi

  Alias  网络路径     服务端实际路径

[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf

<VirtualHost *:80>
 ServerName  webapp0.example.com
 DocumentRoot /var/www/nsd03

 Alias   /      /var/www/nsd03/webinfo.wsgi

   #当客户端直接访问网页文件根目录时,呈现/var/www/nsd03/webinfo.wsgi页面内容

</VirtualHost>

[root@server0 /]# systemctl restart httpd
[root@server0 /]# firefox webapp0.example.com

3.安装mod_wsgi软件包,专用于翻译Python页面
[root@server0 /]# yum -y install mod_wsgi
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
 ServerName  webapp0.example.com
 DocumentRoot /var/www/nsd03
 WsgiScriptAlias   /      /var/www/nsd03/webinfo.wsgi

</VirtualHost>

[root@server0 /]# systemctl restart httpd

[root@desktop0 ~]# firefox webapp0.example.com
显示内容为 UNIX时间戳:从1970-1-1 0:0:0到达当前系统时间,所经历的秒数


4.此虚拟webapp0.example.com主机侦听在端口8909
[root@server0 /]# vim  /etc/httpd/conf.d/nsd01.conf
Listen 8909             #让httpd程序监听8909端口
<VirtualHost  *:8909>   #本虚拟Web主机使用8909端口
 ServerName    webapp0.example.com
 DocumentRoot  /var/www/nsd03
 WsgiScriptAlias   /      /var/www/nsd03/webinfo.wsgi
</VirtualHost>
      
5.SELinux非默认端口的开放    
-l:列出  -a:添加  -t:类型  -p:协议
]# semanage port -l | grep http
]# semanage port -a -t http_port_t  -p tcp 8909   #添加端口
             
]# systemctl restart httpd
]# firefox webapp0.example.com:8909
#########################################################
 1.端口的优先级最高
 2.默认将第一个虚拟Web主机内容呈现
#########################################################
安全Web服务,实现https(完全的超文本传输协议)

PKI公钥基础设施
• Public Key Infrastructure,公钥基础设施
– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作

虚拟机server:构建安全的Web服务

1.部署网站证书
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/tls/certs/server0.crt
]# ls

2.部署根证书
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/example-ca.crt
]# ls 

3.部署私钥(解密数据)
]# cd /etc/pki/tls/private/
]# wget http://classroom.example.com/pub/tls/private/server0.key

]# ls 

4.安装支持安全的软件
[root@server0 /]# yum -y install mod_ssl
[root@server0 /]# ls /etc/httpd/conf.d/ssl.conf 
[root@server0 /]# vim  /etc/httpd/conf.d/ssl.conf 
 vim末行模式  :set  nu   #开启行号功能

 59 DocumentRoot  "/var/www/html"
 60 ServerName   www0.example.com:443

#指定网站证书的路径及名称
100 SSLCertificateFile  /etc/pki/tls/certs/server0.crt
#指定解密的私钥
107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key
#指定根证书
122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt

5.书写一个网站
]# echo '<h1>haha xixi' > /var/www/html/index.html 

6.重启httpd服务
]# systemctl restart httpd

7.验证
[root@desktop0 ~]# firefox https://www0.example.com
   我已了解可能的风险--->添加例外---->确认例外
#########################################################

一  环境设置
虚拟机server
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@server0 ~]# firewall-cmd --get-default-zone
虚拟机desktop
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --get-default-zone

#########################################################
二 网络参数配置
方式一:nmtui

方式二:
1.设置永久设置主机名,修改/etc/hostname配置文件

[root@server0 ~]# echo A.tedu.cn > /etc/hostname  
[root@server0 ~]# hostname
A.tedu.cn
[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ gos
Last login: Fri May 17 09:04:25 2019 from 172.25.0.250
[root@A ~]# 

2.配置IP地址,子网掩码,网关地址

1)查看识别的网卡名称
[root@A ~]# nmcli connection show 
名称         
System eth0

2)修改IP地址,子网掩码,网关地址                                    
]#  nmcli connection modify 'System eth0'     
    ipv4.method manual 
    ipv4.addresses '172.25.0.112/24   172.25.0.254' 
    connection.autoconnect yes 

]#  nmcli connection 修改  '识别的网卡名'
    ipv4.方法  手工配置IP地址
    ipv4.地址  'IP地址/子网掩码   网关地址'
       每次开机自动启用 

3)激活配置
[root@A ~]# ifconfig | head -2
[root@A ~]# nmcli connection up 'System eth0'
######################################################
DNS服务器地址:将域名解析为对应的IP地址
/etc/resolv.conf  #指定DNS服务器最终有效配置文件

]# echo 'nameserver  172.25.254.254'  >   /etc/resolv.conf

]# cat /etc/resolv.conf
nameserver  172.25.254.254

]# nslookup  www0.example.com    #测试域名解析
Server:		172.25.254.254
Address:	172.25.254.254#53

www0.example.com	canonical name = server0.example.com.
Name:	server0.example.com
Address: 172.25.0.11
#######################################################
配置IPv6地址

• IPv4 地址表示
– 32个二进制位,点分隔的十进制数
– 例如:172.25.0.11、127.0.0.1

• IPv6 地址表示
– 128个二进制位,冒号分隔的十六进制数
– 每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::

– 例如: 2003:ac18:0000:0000:0000:0000:0000:0305
      2003:ac18::305/64


1)查看识别的网卡名称
[root@A ~]# nmcli connection show 
2)修改IP地址,子网掩码,网关地址                                    
]#  nmcli connection modify 'System eth0'     
    ipv6.method manual 
    ipv6.addresses 2003:ac18::305/64 
    connection.autoconnect yes 

]#  nmcli connection 修改  '识别的网卡名'
    ipv6.方法  手工配置IP地址
    ipv6.地址  IP地址/子网掩码
       每次开机自动启用 

3)激活配置
[root@A ~]# ifconfig | head -4
[root@A ~]# nmcli connection up 'System eth0'
[root@A ~]# ifconfig | head -4
[root@A ~]# ping6 2003:ac18::305
#########################################################
链路聚合(聚合链路 网卡绑定)                     

   作用:提高网卡设备的可靠性,提供冗余    
   

                eth1          eth2    
                     
                                 虚拟网卡:team0 
                                  192.168.1.1


1.建立虚拟网卡team0,参考 man teamd.conf   全文搜索 /example

]# nmcli connection add type team             
   con-name team0 ifname team0 autoconnect yes         
   config  '{"runner": {"name": "activebackup"}}'

]# nmcli connection 添加  类型  team
     配置文件名  team0 网卡名 team0  每次开机自动启用
     链路聚合管理方式为 热备份方式


]# ifconfig   #查看生成的虚拟网卡team0

生成配置文件位置:/etc/sysconfig/network-scripts/

2.添加成员
]# nmcli connection add type team-slave       
   con-name team0-1 ifname eth1 master team0 

]# nmcli connection add type team-slave       
   con-name team0-2 ifname eth2 master team0 


]# nmcli connection 添加   类型  team-成员
     配置文件名   team0-1  网卡名  eth1  主设备为 team0

生成配置文件位置:/etc/sysconfig/network-scripts/

3.配置IP地址激活
[root@A ~]# nmcli connection modify team0 ipv4.method manual ipv4.addresses 192.168.1.1/24 connection.autoconnect  yes

[root@A ~]# nmcli connection up team0  #激活配置

[root@A ~]# teamdctl team0 state    #专用于查看team0信息
[root@A ~]# ifconfig eth2 down      #禁用eth2网卡
[root@A ~]# teamdctl team0 state

如果无法激活,删除所有配置重新来过
[root@A ~]# nmcli connection delete team0
[root@A ~]# nmcli connection delete team0-1
[root@A ~]# nmcli connection delete team0-2

###################################################
parted分区工具,进行gpt分区模式

       128个主分区 最大空间支持18EB

[root@A ~]# parted  /dev/vdb
(parted) mktable  gpt        #指定分区表类型为gpt
(parted) print               #输出分区表信息
(parted) mkpart              #划分新的分区
分区名称？  []? haha             #分区名称随意写
文件系统类型？  [ext2]? ext4     #文件系统随意些,不起实际作用
起始点？ 0                                    #分区起始点
结束点？ 2G                   #分区结束点
警告: The resulting partition is not properly aligned
for best performance.
忽略/Ignore/放弃/Cancel? Ignore    #选择ignore忽略
(parted) print               
(parted) unit  GB             #使用GB最为单位
(parted) print
(parted) mkpart 
分区名称？  []? haha 
文件系统类型？  [ext2]? ext4
起始点？ 2G
结束点？ 5G
(parted) print
(parted) quit
###################################################
基础邮件服务

邮件域名:
   server0.example.com

邮箱帐号:
   yg@server0.example.com


• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱

快速部署postfix邮件服务器
1.装postfix软件包
[root@A ~]# rpm -q postfix
postfix-2.10.1-6.el7.x86_64

2.修改配置文件/etc/postfix/main.cf 
vim末行模式 :set  nu    #开启行号

99  myorigin = server0.example.com  #默认补全域名后缀

116 inet_interfaces = all   #允许本机所有网卡提供邮件服务

164 mydestination = server0.example.com #此值判断为本域邮件

3.重启服务                                                      
[root@A ~]# systemctl  restart  postfix


测试邮件收发
[root@A ~]# useradd yg
[root@A ~]# useradd xln

•发信操作: mail -s '邮件标题'    -r  发件人      收件人
[root@A ~]# mail -s 'test01' -r yg  xln
ahahxixihehelele
.
EOT
[root@A ~]# echo AAA | mail -s 'test02' -r yg  xln

•收信操作: mail [-u 用户名]
[root@A ~]# mail -u xln
>N  1 yg@server0.example.c  Fri May 17 15:28  18/565   
& 1     #输入邮件编号1回车查看邮件的内容

####################################################

配置smb只读共享（Samba共享）
用途：为客户机提供共享使用的文件夹
协议：SMB（TCP 139）、CIFS（TCP 445）


所需软件包：samba
系统服务：smb


管理共享账号：
samba用户——专门用来访问文件夹的用户
—采用独立设置的密码
—但需要建立同名的系统用户（登录系统的密码可以不设置）

使用pdbedit管理工具
添加用户： pdbedit -a 用户名
查询用户： pdbedit -L【用户名】
删除用户： pdbedit -x 用户名

修改配置文件：
[root@server0 ~]# vim /etc/samba/smb.conf 
[自定义共享名称]
       path = 实际共享的文件夹绝对路径


实验环境：防火墙默认区域设置为trusted
虚拟机server0
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
success

虚拟机desktop0
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
success


server0:
1、安装软件包
[root@server0 ~]# yum -y install samba
2、创建samba共享账号
[root@server0 ~]# useradd harry
[root@server0 ~]# pdbedit -a harry  //将harry添加为samba共享的用户
new password:  //设置harry用户的密码
retype new password:  //再次设置harry用户的密码
3、创建共享目录/NSD1904
[root@server0 ~]# mkdir /NSD1904
[root@server0 ~]# echo 123 >/NSD1904/1.txt
4、修改配置文件
[abc]   //设置共享名
   path = /NSD1904  //设置实际共享文件夹路径
5、重启服务
[root@server0 ~]# systemctl restart smb
[root@server0 ~]# systemctl enable smb
6、修改selinux，修改布尔值
[root@server0 ~]# getsebool -a | grep samba
[root@server0 ~]# setsebool -P samba_export_all_ro=on


desktop0:
1、安装cifs-utils软件包，让本机支持cifs协议以及该文件系统
[root@desktop0 ~]# yum -y install cifs-utils
[root@desktop0 ~]# mount -o user=harry,pass=123 //172.25.0.11/abc /mnt/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# umount /mnt/
2、加入开机自启
[root@desktop0 ~]# vim /etc/fstab 
//172.25.0.11/abc /mnt cifs  defaults,user=harry,pass=123  multiuser,sec=ntlmssp,_netdev 0 0

注： _netdev：声明网路设备，在开启网络服务之后，再挂载本设备
[root@desktop0 ~]# mount -a

su - student 
studen# cifscreds add -u chihiro用户 server0.example.com服务端

###################################################################
********************************************************************

搭建新教学环境

一  关闭虚拟机classroom与server与desktop

二  真机建立全新的两台虚拟机
[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 4

[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 5

   vi是Linux最基本的编辑器 

虚拟机root的密码:123456

##################################################
三   配置虚拟机A
1.为虚拟机A:配置eth0的IP地址为192.168.4.7/24
真机管理本机虚拟机,前提关闭所有虚拟机图形窗口             
[student@room9pc01 ~]$ virsh  console  A
   Ctrl +  ]:退出管理
[root@localhost ~]# nmcli connection modify eth0 ipv4.method manual ipv4.address 192.168.4.7/24 connection.autoconnect yes

[root@localhost ~]# nmcli connection up eth0
[root@localhost ~]# ifconfig | head -2
2.为虚拟机A配置主机名:svr7.tedu.cn
[root@localhost ~]# echo svr7.tedu.cn  > /etc/hostname
svr7.tedu.cn
[root@localhost ~]# hostname svr7.tedu.cn
[root@localhost ~]# hostname
svr7.tedu.cn
[root@svr7 ~]# cat /etc/motd   #每次开机自动显示内容#自己随意编辑

###################################################
真机利用virsh console管理虚拟机B进行配置
[root@localhost ~]# hostname pc207.tedu.cn
[root@localhost ~]# echo pc207.tedu.cn > /etc/hostname 

[root@localhost ~]# nmcli connection modify eth0 ipv4.method manual ipv4.address 192.168.4.207/24 connection.autoconnect yes

[root@localhost ~]# nmcli connection up eth0
[root@localhost ~]# ifconfig | head -2

###################################################
利用真机进行ssh远程管理
真机上设置
[student@room9pc01 ~]$ vim /home/student/.bashrc
alias goa='ssh  -X  root@192.168.4.7'
alias gob='ssh  -X  root@192.168.4.207'

 开启新的终端才能验证

###################################################
为虚拟机A与虚拟机B构建Yum仓库

一 真机:服务端 
      构建Web服务或FTP服务,共享光盘所有内容

1.构建FTP服务,共享光盘所有内容                               
[student@room9pc01 ~]$ rpm -q vsftpd
vsftpd-3.0.2-22.el7.x86_64
[student@room9pc01 ~]$ ls /var/ftp/centos-1804/

[student@room9pc01 ~]$ systemctl status vsftpd

[student@room9pc01 ~]$ vim /etc/fstab
..........
      真机路径下的系统文件路径
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0

]$ firefox ftp://192.168.4.254/centos-1804  

二 客户端:虚拟机A与虚拟机B  #搭建yum仓库
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[root@svr7 ~]# yum  repolist
[root@svr7 ~]# yum -y install xeyes

[root@svr7 ~]# xeyes

###################################################
总结新建虚拟机:
1.真机利用clone-vm7生成虚拟机,开启虚拟机
2.真机利用virsh console  虚拟机名   设置IP地址
3.真机利用ssh远程管理虚拟机,配置主机名与Yum客户端配置文件

####################################################
虚拟机C
   1.配置eth0的IP地址:192.168.4.10/24
   2.配置主机名:svr10.tedu.cn
   3.配置Yum仓库,以真机提供FTP作为服务端

虚拟机D
   1.配置eth0的IP地址:192.168.4.20/24
   2.配置主机名:pc20.tedu.cn
   3.配置Yum仓库,以真机提供FTP作为服务端




####################################################

目录结构
• 认识Linux的目录层次:
– man hier

• 常见一级目录的用途
	/boot        存放系统引导必需的文件,包括内核、启动配置
	/bin、/sbin  存放各种命令程序
	/dev         存放硬盘、键盘、鼠标、光驱等各种设备文件
	/etc         存放Linux系统及各种程序的配置文件
	/root、/home/用户名   分别是管理员root、普通用户的默认家目录
	/var         存放日志文件、邮箱目录等经常变化的文件
	/proc        存放内存中的映射数据,不占用磁盘
	/tmp         存放系统运行过程中使用的一些临时文件

权限的数值表示
• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1

[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 700 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 007 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 755 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 750 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 3755 /nsd01
[root@svr7 ~]# ls -ld /nsd01

###################################################
历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令
• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000    #默认记录1000条


[root@svr7 ~]# history        #查看历史命令
[root@svr7 ~]# history -c     #清空历史命令
[root@svr7 ~]# history 
    1  history 
[root@svr7 ~]# cat /etc/redhat-release 
[root@svr7 ~]# ls -l /etc/redhat-release
[root@svr7 ~]# cat /etc/hostname

[root@svr7 ~]# history 

[root@svr7 ~]# !cat     #执行历史命令中最近一条cat开头

###################################################
实用小命令工具
• du,统计文件的占用空间
– du [选项]... [目录或文件]...

– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du -s /root/

[root@svr7 ~]# du -sh /root/

[root@svr7 ~]# du -sh  /boot/ /etc/

[root@svr7 ~]# du -sh /    #最佳搭配组合

################################################
bc 交互式计算器
[root@svr7 ~]# bc
-bash: bc: 未找到命令
[root@svr7 ~]# yum -y install bc

[root@svr7 ~]# bc     #进入交互式模式
   +   -   *   /     %(取余数运算)

公式是:  被除数 ÷ 除数 = 商

  余数一定小于除数
   
##################################################
• date,查看/调整系统日期时间
– date +%F、date +%R
– date +"%Y-%m-%d %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"

[root@svr7 ~]# date +%F   #显示年月日 
[root@svr7 ~]# date +%R   #显示时分

[root@svr7 ~]# date +%Y   #显示年
[root@svr7 ~]# date +%m   #显示月

[root@svr7 ~]# date +%d   #显示日期
[root@svr7 ~]# date +%H   #显示时

[root@svr7 ~]# date +%M   #显示分
[root@svr7 ~]# date +%S   #显示秒

#####################################################
制作快捷方式(连接文件 符号文件)

格式:ln -s   /路径/源文件    /路径/生成快捷方式名称       #软连接

[root@svr7 ~]# cat /etc/hostname 

[root@svr7 ~]# ln -s /etc/hostname  /
[root@svr7 ~]# ls /
[root@svr7 ~]# ls -l /hostname 

[root@svr7 ~]# ln -s /etc/hostname  /hn
[root@svr7 ~]# ls   /
[root@svr7 ~]# ls -l  /hn

[root@svr7 ~]# cat /hn
[root@svr7 ~]# cat /hostname

若原始文件或目录被删除,连接文件将失效
软连接可存放在不同分区/文件系统,也可以针对目录

[root@svr7 ~]# echo 123 > /opt/A
[root@svr7 ~]# cat /opt/A
123
[root@svr7 ~]# ln -s /opt/A  /opt/B
[root@svr7 ~]# ls /opt/
A  B
[root@svr7 ~]# rm -rf /opt/A
[root@svr7 ~]# ls /opt/
B
[root@svr7 ~]# cat /opt/B

ln,创建硬连接
– ln 原始文件   硬连接文件

 若原始文件被删除,连接文件仍可用
 硬连接与原始文件必须在同一分区/文件系统,必须时文件

[root@svr7 ~]# echo haha > /opt/1.txt
[root@svr7 ~]# ln /opt/1.txt /opt/2.txt
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# cat /opt/2.txt 

[root@svr7 ~]# rm -rf /opt/1.txt 
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# cat /opt/2.txt 
####################################################

获取命令帮助   --help    man帮助  
[root@svr7 ~]# date --help
[root@svr7 ~]# man date

[root@svr7 ~]# man passwd
[root@svr7 ~]# man 5 passwd   #配置文件帮助信息
###################################################
zip归档工具(跨平台的压缩工具)

• 归档+压缩操作
– zip [-r]  备份文件.zip   被归档的文档...

[root@svr7 ~]# yum -y install zip
[root@svr7 ~]# zip -r /opt/file.zip /etc/passwd /home
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# zip -r /opt/abc.zip /etc/fstab /etc/hosts
[root@svr7 ~]# ls /opt/

• 释放归档+解压操作
– unzip 备份文件.zip [-d 目标文件夹]

[root@svr7 ~]# yum -y install unzip
[root@svr7 ~]# mkdir /nsd02
[root@svr7 ~]# unzip /opt/file.zip -d /nsd02

[root@svr7 ~]# ls /nsd02
[root@svr7 ~]# ls /nsd02/etc/
[root@svr7 ~]# ls /nsd02/home/
####################################################
发布自定义Yum仓库

   把从互联网下载的软件包,采用Yum的机制进行管理

1.具备从互联网下载的软件包
真机上:
[student@room9pc01 ~]$ ls /linux-soft/01    
Cobbler.zip  tools.tar.gz

2.将真机tools.tar.gz上传到虚拟机A的/root目录下
  scp=ssh+cp结合
  scp   /本地路径/源文件   root@对方IP地址:/目标路径/

scp /linux-soft/01/tools.tar.gz  root@192.168.4.7:/root

3.验证在虚拟机A进行查看
[root@svr7 ~]# ls /root/
Desktop  tools.tar.gz
[root@svr7 ~]# 

4.虚拟机A解包:
[root@svr7 ~]# tar -xf /root/tools.tar.gz -C /
[root@svr7 ~]# ls /
[root@svr7 ~]# ls /tools/
[root@svr7 ~]# ls /tools/other/

5.生成仓库清单(仓库数据文件)
[root@svr7 ~]# yum -y install createrepo #软件
@svr7 ~]# createrepo /tools/other/ #生成仓库数据文件,在目录下叫repodata文件

[root@svr7 ~]# ls /tools/other/

6.修改配置文件指定新的Yum服务端
[root@svr7 ~]# ls /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[myrpm]
name=myrpm
baseurl=file:///tools/other      #指定本机为服务端
enabled=1
gpgcheck=0

[root@svr7 ~]# yum  repolist

##################################################
[root@svr7 ~]# yum -y install cmatrix
[root@svr7 ~]# cmatrix

[root@svr7 ~]# yum -y install sl
[root@svr7 ~]# sl

[root@svr7 ~]# yum -y install oneko
[root@svr7 ~]# oneko &
     关闭终端,可以结束oneko程序

##################################################
vim编辑技巧

命令模式
[root@svr7 ~]# cp  /etc/passwd   /opt/pa.txt
[root@svr7 ~]# vim  /opt/pa.txt             
光标跳转
	Home 键 或 ^、数字 0 	跳转到行首
	End 键 或“$”键 			跳转到行尾
	1G 或 gg 				跳转到文件的首行
	G 					跳转到文件的末尾行
复制/粘贴/删除
	复制 yy、#yy 		复制光标处的一行、#行
	粘贴 p、P 		粘贴到光标处之后、之前
	x 或 Delete键 		删除光标处的单个字符
	dd、#dd 			删除光标处的一行、#行
	d^ 				从光标处之前删除至行首
	d$或D(大写) 		从光标处删除到行尾
	C(大写) 			从光标处删除到行尾,并且进入插入模式
	u                	撤销

查找/撤销/保存
	/word 	向后查找字符串“word”
	n、N 	跳至后/前一个结果
	u 		撤销最近的一次操作
	U 		撤销对当前行的所有修改
	Ctrl + r 取消前一次撤销操作
	ZZ(大写)	保存修改并退出
[root@svr7 ~]# cp /etc/passwd /opt/pa.txt 
cp：是否覆盖"/opt/pa.txt"？ y
[root@svr7 ~]# vim  /opt/pa.txt


####################################################
末行模式操作

读入其他文件内容

[root@svr7 ~]# echo 123 > /opt/a.txt
[root@svr7 ~]# echo abc > /opt/b.txt
[root@svr7 ~]# vim /opt/a.txt

      末行模式下   :r  /opt/b.txt   #读入/opt/b.txt内容到当前文件
      末行模式下   :r  /etc/hostname
      末行模式下   :r  /etc/hosts
 
字符串替换
	:s/root/admin 		替换光标所在的当前行第一个“root”
	:s/root/admin/g 		替换光标所在的当前行所有的“root”
	:5,10 s/root/admin/g 		替换第5-10行所有的“root”
	:% s/root/admin/g 		替换文件内所有的“root”

[root@svr7 ~]# cp /etc/passwd /opt/p.txt
[root@svr7 ~]# vim /opt/p.txt

开关参数的控制                                                
	:set nu或nonu 	显示/不显示行号
	:set ai或noai 	启用/关闭自动缩进

###############################################
源码编译安装

RPM包:  rpm  -ivh    yum  

源码包----gcc与make---->可以执行的文件------->运行安装

源码编译安装的优势
• 主要优点
 – 获得软件的最新版,及时修复bug
 – 软件功能可按需选择/定制,有更多软件可供选择
 – 源码包适用各种平台

步骤1:安装依赖关系包(安装开发工具)
[root@svr7 ~]# yum -y install  gcc  make
[root@svr7 ~]# rpm -q gcc
gcc-4.8.5-28.el7.x86_64
[root@svr7 ~]# rpm -q make
make-3.82-23.el7.x86_64

步骤2:tar解包,释放源代码至指定目录
]# tar -xf /tools/inotify-tools-3.13.tar.gz -C  /
]# ls /
]# cd /inotify-tools-3.13/
]# ls

步骤3: ./configure 配置,指定安装目录/功能模块等选项
  
            ./=当前路径下运行    作用1:检测本机是否安装gcc
                                          作用2:指定安装目录/功能模块等选项

       --prefix=指定安装位置

]# cd /inotify-tools-3.13/
]# ./configure --prefix=/mnt/myrpm

常见报错提示:没有安装gcc
checking for gcc... no
checking for cc... no
checking for cl.exe... no
configure: error: no acceptable C compiler found in $PATH
See `config.log' for more details.

步骤4:make 编译,生成可执行的二进制程序文件
]# cd /inotify-tools-3.13/
]# make

步骤5:make install 安装,将编译好的文件复制到安装目录
]# cd /inotify-tools-3.13/
]# make install

]# ls /mnt/
]# ls /mnt/myrpm/         #查看安装生成的目录
]# ls /mnt/myrpm/bin/

####################################################

一   真机远程管理虚拟机A

虚拟化概述
• virtualization 资源管理
– x个物理资源 --> y个逻辑资源
– 实现程度:完全、部分、硬件辅助(CPU)

 CPU能够直接识别运算虚拟机指令

虚拟机A:
[root@svr7 ~]# lscpu | grep vmx   #查看CPU是否支持虚拟化

真机查看CPU是否支持虚拟化
[student@room9pc01 ~]$ lscpu | grep vmx

####################################################
• 虚拟化主要厂商及产品
	VMware 		VMware Workstation、vSphere
	Microsoft 	VirtualPC、Hyper-V
	RedHat 		KVM、RHEV
	Citrix 		Xen
	Oracle 		Oracle VM VirtualBox

####################################################
二  手动安装一台有图形的虚拟机nsd01     
  
  操作系统为:CentOS 7.5
  内存为:2048M
  硬盘大小:9G 
 cpu:1
  虚拟名为:nsd01
  网络类型:private1
  软件包选择:带GUI的服务器
  分区:自动分区

 root密码设置为1     创建lisi用户密码设置为1
####################################################
三   针对虚拟机nsd01进行配置

  1.关闭SELinux  
[root@localhost ~]# getenforce 
[root@localhost ~]# setenforce 0
[root@localhost ~]# vim /etc/selinux/config 
SELINUX=permissive
  2.防火墙设置为trusted
  3.设置IP地址为:192.168.4.30/24
]# nmcli connection modify eth0       
 ipv4.method manual ipv4.addresses 192.168.4.30/24    
 connection.autoconnect yes
]# nmcli connection up eth0 
]# ifconfig | head -2
  4.主机名:kvm.tedu.cn
  5.构建Yum仓库,使用真机FTP最为服务端
[root@localhost yum.repos.d]# mkdir  repo
[root@localhost yum.repos.d]# mv  *.repo   repo

###################################################
虚拟机nsd01:安装虚拟化服务器平台
• 主要软件包
– qemu-kvm:为 kvm 提供底层仿真支持
– libvirt-daemon:libvirtd 守护进程,管理虚拟机
– libvirt-client:用户端软件,提供客户端管理命令
– libvirt-daemon-driver-qemu:libvirtd 连接 qemu 的驱动
– virt-manager:图形管理工具

[root@kvm ~]# yum -y install qemu-kvm 
[root@kvm ~]# yum -y install libvirt-daemon
[root@kvm ~]# yum -y install libvirt-daemon-driver-qemu
 
[root@kvm ~]# yum -y install libvirt-client 
[root@kvm ~]# yum -y install virt-manager

[root@kvm ~]# virt-manager   #图形虚拟系统管理器

####################################################
虚拟化服务:
[root@kvm ~]# systemctl status libvirtd

####################################################
真机上进行虚拟机管理:             
virsh命令工具介绍
• 查看KVM节点(服务器)信息
– virsh nodeinfo
• 列出虚拟机
– virsh list [--all]
• 查看指定虚拟机的信息
– virsh dominfo 虚拟机名称
• 将指定的虚拟机设为开机自动运行
– virsh autostart [--disable] 虚拟机名称
• 强制关闭指定的虚拟机
– virsh destroy 虚拟机名称
• 运行|重启|关闭指定的虚拟机
– virsh start  虚拟机名称

###################################################
xml配置文件(虚拟机描述文件)

默认存放路径:
[student@room9pc01 ~]$ ls /etc/libvirt/qemu

输出虚拟机xml文件内容
[student@room9pc01 ~]$ virsh dumpxml nsd01 | less
   
   虚拟机名称:  <name>nsd01</name>
  <uuid>cf4e78cb-65bb-48df-a84b-56741a470fcb</uuid>
  <source file='/var/lib/libvirt/images/nsd01.qcow2'/>
   网卡MAC地址:网卡唯一编号<mac address='52:54:00:20:37:74'/>


###################################################
一台KVM虚拟机的组成
 – xml配置文件:定义虚拟机的名称、UUID、CPU、内
存、虚拟磁盘、网卡等各种参数设置
默认路径:/etc/libvirt/qemu

 – 磁盘镜像文件:保存虚拟机的操作系统及文档数据,
镜像路径取决于xml配置文件中的定义
默认路径:/var/lib/libvirt/images/

真机:手动创建一个虚拟机abc01
1.创建虚拟机磁盘镜像文件
]$ cd  /var/lib/libvirt/images/
]$ cp  .node_tedu.qcow2       abc01.qcow2

2.创建虚拟机xml配置文件
]$ virsh dumpxml nsd01 > /etc/libvirt/qemu/abc01.xml
]$ ls /etc/libvirt/qemu
]$ ls -l /etc/libvirt/qemu/abc01.xml 
]$ vim /etc/libvirt/qemu/abc01.xml
    虚拟机名称:  <name>abc01</name>

  <uuid>删除整行内容,如果删多了按u进行撤销

  <source file='/var/lib/libvirt/images/abc01.qcow2'/>

  <mac address='52:54:00:20:37:74'/> 删除整行内容

3.导入虚拟机信息
]$ virsh define /etc/libvirt/qemu/abc01.xml 

]$ virsh list --all
]$ virsh start abc01
]$ virsh list

###################################################
手动创建虚拟机:
1.创建新的虚拟机磁盘文件
2.导出虚拟机xml配置文件
]$ virsh dumpxml nsd01 > /etc/libvirt/qemu/abc01.xml
]$ vim /etc/libvirt/qemu/abc01.xml
    虚拟机名称:  <name>abc01</name>
  <uuid>删除整行内容,如果删多了按u进行撤销
  <source file='/var/lib/libvirt/images/abc01.qcow2'/>
  <mac address='52:54:00:20:37:74'/> 删除整行内容

3.导入虚拟机信息
]$ virsh define /etc/libvirt/qemu/abc01.xml 

##################################################
三合一的命令:导出xml配置文件      修改    导入

1.创建一个虚拟机磁盘文件
]$ cd /var/lib/libvirt/images/
]$ cp .node_tedu.qcow2      abc02.qcow2

2.三合一的命令:导出xml配置文件      修改    导入
[student@room9pc01 /]$ virsh edit nsd01
    虚拟机名称:  <name>abc02</name>
  <uuid>删除整行内容,如果删多了按u进行撤销
  <source file='/var/lib/libvirt/images/abc02.qcow2'/>
  <mac address='52:54:00:20:37:74'/> 删除整行内容

[student@room9pc01 /]$ virsh list --all
[student@room9pc01 /]$ virsh start  abc02

###################################################
虚拟机命令行的删除
[student@room9pc01 /]$ virsh list 
[student@room9pc01 /]$ virsh destroy abc02  #强制关机
域 abc02 被删除

[student@room9pc01 /]$ virsh list --all
[student@room9pc01 /]$ virsh undefine abc02  #取消定义
域 abc02 已经被取消定义

]$ virsh list --all
]$ cd /var/lib/libvirt/images/
]$ ls abc02.qcow2   
]$ rm -rf abc02.qcow2   #删除磁盘文件
]$ ls
##################################################
COW(Copy On Write)机制  写时复制

• 虚拟机的磁盘镜像文件格式
	特点\类型 		RAW		   QCOW2
	KVM默认 		否 			是
	I/O效率 		高 			较高
	占用空间 		大 			小
	压缩 			不支持 		支持
	后端盘复用 	不支持 		支持
	快照 			不支持 		支持

– 直接映射原始盘的数据内容
– 当前端盘的数据有修改时,在修改之前自动将原始盘的旧数据存入前端盘
– 对前端盘的修改不回写到原始盘

 前端盘大小最好比原始盘大或相等

1.基于原始盘.node_tedu.qcow2生成前端盘test.qcow2  
]$ cd /var/lib/libvirt/images/
]$ qemu-img create  -f qcow2   -b .node_tedu.qcow2   test.qcow2 10G

]$ qemu-img info test.qcow2   #查看磁盘文件信息

2.修改虚拟机xml文件内容
]$ virsh edit nsd01
     虚拟机名称:  <name>test</name>
   <uuid>删除整行内容,如果删多了按u进行撤销
   <source file='/var/lib/libvirt/images/test.qcow2'/>
   <mac address='52:54:00:20:37:74'/> 删除整行内容

]$ virsh  start test
]$ virsh  list  --all   

###################################################
离线访问虚拟机:虚拟机关机状态,直接修改磁盘文件里面的数据

]$ guestmount -a /var/lib/libvirt/images/tedu_node09.img  -i /home/student/nsdfile/

##################################################




• DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址
– 反向解析:根据IP地址查找对应的注册域名,不常用

所有的域名都必须以点作为结尾

根域：　　　　　　　　．
　　
一级域名：　.cn    .us   .tw   .hk   .jp  .kr


二级域名：　tedu.cn    .com.cn   .net.cn   .org.cn


三级域名：　nb.com.cn   haha.com.cn  haxi.com.cn  


完全合格的主机名:  主机头部+域名

  该网站的FQDN为: www.qq.com

Full Qualified Domain Name(FQDN),完全合格主机名

@       IN SOA  @ rname.invalid. (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
格式为：[zone] IN SOA [主机名] [管理员email] （[五组更新时间参数])

主机名：Master DNS的主机名称，通常是本机名即可。注意后面的小数点。

管理员emali:本来应该是“root@localhost.”的格式，不过因为@已经被作为特殊代码(zone)，所以就用小数点来取代，因此email就成为"root.localhost."

五组更新时间参数:

serial:该序号作为slave与master更新的依据,建议的格式为YYYYMMDDnn 其中nn为修订号;
refresh:命令slave多久进行一次主动更新。
retry:如果到了refresh的时间，但是slave却无法连接master时，那么多久之后，slave会再次的主动尝试与主机连线。
expire:如果slave一直无法与master连接上，那么经过多久的时间后，则命令slave不要在连接master了。
minimun:没有指定生存期的数据，可以指定保存在数据库中的时间，及TTL。
 NS记录：Name server的缩写

格式为：[zone] IN NS [主机名称]

意思是：这个zone的查询请向后面这部主机请求。如果此zone有两部以上的DNS服务器负责时，就必须写两个NS，而NS后面接的主机名称必须要有ip的对应，这时需要A记录。

A记录

格式为：[hostname] IN A [IP]

功能为:传回一个 32 比特的 IP v4地址，最常用于映射主机名称到 IP地址，但也用于DNSBL等。
--------------------- 
作者：温海深 
来源：CSDN 
原文：https://blog.csdn.net/weixin_36217005/article/details/88614725 
版权声明：本文为博主原创文章，转载请附上博文链接！

###################################################
bind-9.9.4-29.el7.x86_64   //域名服务包
bind-chroot-9.9.4-29.el7.x86_64  //提供虚拟根支持,牢笼政策

– 系统服务:named
– 默认端口:TCP/UDP 53
– 运行时的虚拟根环境:/var/named/chroot/

• 主配置文件:/etc/named.conf    #设置负责解析域名   tedu.cn
• 地址库文件:/var/named/        #记录域名与IP地址对应关系
              
虚拟机A构建DNS服务
1.安装软件
[root@svr7 ~]# yum -y install  bind  bind-chroot
2.修改主配置文件
[root@svr7 ~]# cp /etc/named.conf /etc/named.bak
[root@svr7 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";   #地址库文件存放路径
};
zone "tedu.cn" IN {          #设置负责解析的域名
        type master;         #类型为主DNS服务器
        file "tedu.cn.zone"; #地址库文件名称
};

3.建立地址库文件
[root@svr7 ~]# cd /var/named/
[root@svr7 named]# cp -p named.localhost tedu.cn.zone
        -p:保持源文件属性不变
[root@svr7 named]# ls -l tedu.cn.zone
[root@svr7 named]# vim  tedu.cn.zone
所有的域名都必须以点结尾
如果没有以点结尾,那么自动补全本地址库负责的域名

tedu.cn.  NS   svr7
svr7      A    192.168.4.7
www       A    1.1.1.1
ftp       A    2.2.2.2

[root@svr7 named]# systemctl  restart named

虚拟机B测试域名解析

1.指定本机DNS服务器/etc/resolv.conf 
]# echo nameserver 192.168.4.7  >  /etc/resolv.conf 
]# cat /etc/resolv.conf

]# nslookup www.tedu.cn
]# nslookup ftp.tedu.cn
##################################################
多区域的DNS服务器
1.修改主配置文件                                             
options {
        directory       "/var/named";
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
2.建立地址库文件qq.com.zone
 qq.com.   NS   svr7
 svr7      A    192.168.4.7
 www       A    3.3.3.3
 ftp       A    4.4.4.4


3.重启named服务

###################################################
搭建DNS服务器,实现www.sina.com解析结果为192.168.4.100

###################################################
DNS服务器资源解析记录:
  NS解析记录 
  A正向地址解析记录
  CNAME解析记录的别名

##################################################
特殊的解析记录
1.DNS轮询,基于DNS的站点负载均衡
– 一个域名 ---> 多个不同IP地址
[root@svr7 /]# vim /var/named/tedu.cn.zone  
tedu.cn.  NS   svr7
svr7      A    192.168.4.7
www       A    192.168.4.1
www       A    192.168.4.2
www       A    192.168.4.3
ftp       A    2.2.2.2

2.泛域名解析

虚拟机A
[root@svr7 /]# vim /var/named/tedu.cn.zone
 最后追加写入
 *         A    1.2.3.4
 tedu.cn.  A    10.20.30.40

[root@svr7 /]# systemctl  restart named

虚拟机B
[root@pc207 /]# nslookup wwww.tedu.cn
[root@pc207 /]# nslookup haxi.tedu.cn
[root@pc207 /]# nslookup tedu.cn

3.有规律的泛域名解析
    pc1.tedu.cn ------>192.168.10.1
    pc2.tedu.cn ------>192.168.10.2
    pc3.tedu.cn ------>192.168.10.3
    pc4.tedu.cn ------>192.168.10.4
        ..........
    pc50.tedu.cn ------>192.168.10.50

内置函数: $GENERATE  制造连续范围数字

虚拟机A
[root@svr7 /]# vim  /var/named/tedu.cn.zone
    最后追加写入

  $GENERATE 1-50  pc$  A  192.168.10.$

[root@svr7 /]# systemctl  restart named

虚拟机B
[root@pc207 /]# nslookup pc1.tedu.cn
[root@pc207 /]# nslookup pc2.tedu.cn

4.解析记录的别名
[root@svr7 /]# vim /var/named/tedu.cn.zone  
 最后追加写入
 tts       CNAME   ftp

[root@svr7 /]# systemctl  restart named

虚拟机B
[root@pc207 /]# nslookup  tts.tedu.cn

###################################################
主机名映射文件:/etc/hosts
  1.解析域名过程中,最高优先级
  2.只为本机提供解析

虚拟机A:
[root@svr7 /]# vim /etc/hosts
[root@svr7 /]# tail -1 /etc/hosts
最后追加写入

192.168.4.110  www.360.com

[root@svr7 /]# ping  www.360.com

###################################################
虚拟机B,构建DNS服务器,负责解析bj.qq.com
1.安装软件bind  bind-chroot
2.修改主配置文件
options {
        directory       "/var/named";
};      
zone "bj.qq.com" IN {
        type master;
        file "bj.qq.com.zone";
}; 
[root@pc207 ~]# cd /var/named/
[root@pc207 named]# cp -p named.localhost bj.qq.com.zone
[root@pc207 named]# vim bj.qq.com.zone
  bj.qq.com.      NS      pc207
  pc207           A       192.168.4.207
  www             A       11.12.13.14
[root@pc207 named]# systemctl restart named

####################################################
DNS子域授权

   父域:www.qq.com
   子域:www.bj.qq.com

  虚拟机A为DNS服务,负责qq.com域名的解析
  虚拟机B为DNS服务,负责bj.qq.com域名的解析

[root@pc207 /]# nslookup www.qq.com 192.168.4.7
[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.207

解析请求www.bj.qq.com询问父域DNS服务器虚拟机A,也能够解析
虚拟机A:
[root@svr7 ~]# vim /var/named/qq.com.zone    
 qq.com.    NS   svr7
 bj.qq.com. NS   pc207
 svr7       A    192.168.4.7
 pc207      A    192.168.4.207
 www        A    3.3.3.3
 ftp        A    4.4.4.4
[root@svr7 ~]# systemctl restart named

[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.7
Server:		 192.168.4.7
Address:	      192.168.4.7#53

Non-authoritative answer:   #非权威解答
Name:	www.bj.qq.com
Address: 11.12.13.14

 

递归查询
     客户端请求域名解析,主DNS服务器与其他DNS服务器交互,最终将解析结果带回来

[root@svr7 ~]# vim /etc/named.conf      
options {
        directory       "/var/named";
        recursion no;    #禁止DNS递归查询
};

迭代查询
      主DNS服务器与其他DNS服务器交互

####################################################
缓存DNS服务器,缓存解析记录加快解析

虚拟机A:互联网真DNS服务器                           
虚拟机B:缓存DNS服务器
虚拟机C:测试客户端

虚拟机C解析请求发送给虚拟机B,虚拟机B将请求发送给虚拟机A

一  准备虚拟机C,配置IP地址为192.168.4.10/24

二  配置虚拟机B
[root@pc207 /]# vim /etc/named.conf 
options {
        directory       "/var/named";
        forwarders { 192.168.4.7; };  #转发给192.168.4.7
};
[root@pc207 /]# systemctl restart named
[root@pc207 /]# nslookup www.tedu.cn 192.168.4.207
 
###################################################
综合实验:
 虚拟机A:DNS服务器
 虚拟机B:Web服务器,提供www.tedu.cn与www.qq.com
 虚拟机C:客户端测试

虚拟机B:
1.安装httpd软件包
[root@pc207 /]# yum -y install httpd
2.建立调用配置文件
[root@pc207 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName www.tedu.cn
  DocumentRoot /var/www/tedu
</VirtualHost>
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
[root@pc207 /]# mkdir /var/www/tedu /var/www/qq
[root@pc207 /]# echo '<h1>tedu'  > /var/www/tedu/index.html 
[root@pc207 /]# echo '<h1>QQ' > /var/www/qq/index.html
[root@pc207 /]# systemctl restart httpd

虚拟机A:
1.修改地址库文件记录
[root@svr7 ~]# vim /var/named/tedu.cn.zone
tedu.cn.  NS   svr7
svr7      A    192.168.4.7
www       A    192.168.4.207

[root@svr7 ~]# vim /var/named/qq.com.zone 
qq.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.207
[root@svr7 ~]# !sys
systemctl restart named
[root@svr7 ~]# 

虚拟机C:测试
1.指定DNS服务器地址
]# echo nameserver 192.168.4.7 > /etc/resolv.conf 
]# nslookup www.qq.com
]# nslookup www.tedu.cn

2.测试访问Web页面
]# firefox www.qq.com
]# firefox www.tedu.cn

##################################################################

Split分离解析(视图解析)
• 当收到客户机的DNS查询请求的时候
– 能够区分客户机的来源地址
– 为不同类别的客户机提供不同的解析结果(IP地址)
– 为不同的客户端,提供最近的解析结果

案例需求及要点
• 环境及需求
– 权威DNS:svr7.tedu.cn 192.168.4.7
– 负责区域:tedu.cn
– A记录分离解析 —— 以 www.tedu.cn 为例
客户机来自 解析结果
	192.168.4.207  ---www.tedu.cn----> 192.168.4.100
	其他地址 ---www.tedu.cn----->  1.2.3.4

分离解析配置:
1.客户端匹配原则为,由上到下,匹配即停止
2.每一个客户端都必须找到自己的分类
3.所有的zone都必须在view中
虚拟机A:
1.修改主配置文件
options {
        directory       "/var/named";
};
 view "nsd" {                              #自己添加
  match-clients {  192.168.4.207;  };      #自己添加 
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";---->写入解析结果192.168.4.100
  };
 };
 view "other" {
  match-clients {  any;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";---->写入解析结果1.2.3.4
   };
 };
2.建立不同地址库文件
####################################################
多区域的分离解析

客户机来自 解析结果
	192.168.4.207  -------> 192.168.4.100
	其他地址 -------->  1.2.3.4


1.每一个view中zone的个数,以及zone负责的域名均要一致
view "nsd" {
 match-clients {  192.168.4.207;  };
 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.zone";
  };
};
view "other" {
 match-clients {  any;  };
 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.other";
  };
};

###################################################
了解内容:
  acl地址列表                                                

acl test {  192.168.4.207;  192.168.4.1;  192.168.7.0/24; 192.168.4.2; 192.168.4.27; };

view "nsd" {
 match-clients {  test;  };
 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.zone";
  };
};
####################################################
RAID磁盘阵列

• 廉价冗余磁盘阵列
– Redundant Arrays of Inexpensive Disks
– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘
– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同

• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率
– 至少由两块磁盘组成

• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少由两块磁盘组成

• RAID5,高性价比模式
– 相当于RAID0和RAID1的折中方案
– 需要至少一块磁盘的容量来存放校验数据
– 至少由三块磁盘组成

• RAID6,高性价比/可靠模式
– 相当于扩展的RAID5阵列,提供2份独立校验方案
– 需要至少两块磁盘的容量来存放校验数据
– 至少由四块磁盘组成

• RAID 0+1/RAID 1+0
– 整合RAID 0、RAID 1的优势
– 并行存取提高效率、镜像写入提高可靠性
– 至少由四块磁盘组成

####################################################
进程管理

   程序:静态的代码  占用磁盘空间
 
   进程:动态执行的代码  占用CPU  内存

   父进程与子进程   结构:树型结构

   僵尸进程     孤儿进程

  PID:进程的编号
  
查看进程树
• pstree — Processes Tree
– 格式:pstree [选项] [PID或用户名]

  systemd:上帝进程,所有进程的父进程
   
[root@svr7 /]# pstree
• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号

[root@svr7 ~]# pstree lisi     #查看lisi用户开启的进程
bash───vim
[root@svr7 ~]# pstree -p lisi
bash(3394)───vim(3419)
[root@svr7 ~]# pstree -ap lisi
bash,3394
  └─vim,3419 a.txt
[root@svr7 ~]# 


• ps aux 操作
– 列出正在运行的所有进程,信息非常全面

用户 进程ID %CPU %内存 虚拟内存 固定内存 终端 状态 起始时间 CPU时间 程序指令

• ps -elf 操作
– 列出正在运行的所有进程,可以显示该进程的父进程的PID

  PPID:父进程的PID号

请计算当前系统中运行的进程个数?
]# wc -l /etc/passwd
]# ps aux | wc -l

]# find /etc/ -name '*tab' -type f 
]# find /etc/ -name '*tab' -type f   | wc -l

]# find /etc/ -name '*.conf' -type f 
]# find /etc/ -name '*.conf' -type f     |  wc -l


###################################################

进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]

[root@svr7 ~]# top -d 1
     P(大写)进行CPU排序
     M(大写)进行内存排序

###################################################
检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件            
• 常用命令选项
– -l:输出进程名,而不仅仅是 PID
– -U:检索指定用户的进程
– -x:精确匹配完整的进程名
[root@svr7 ~]# pgrep -l a
[root@svr7 ~]# pgrep -l log

[root@svr7 ~]# pgrep -U lisi  
[root@svr7 ~]# pgrep -lU lisi
[root@svr7 ~]# pstree -ap lisi

################################################
进程的前后台调度

• 后台启动
– 在命令行末尾添加“&”符号,不占用当前终端
• Ctrl + z 组合键
– 挂起当前进程(暂停并转入后台)

• jobs 命令
– 查看后台任务列表
• fg 命令
– 将后台任务恢复到前台运行
• bg 命令
– 激活后台被挂起的任务

[root@svr7 ~]# sleep 1000 &     #将进程正在运行放入后台
[root@svr7 ~]# jobs             #查看后台进程信息
[root@svr7 ~]# sleep 800
^Z                             #按Ctrl+z 暂停放入后台
[2]+  已停止               sleep 800
[root@svr7 ~]# jobs 

[root@svr7 ~]# bg 2    #将后台编号为2的进程,继续运行
[root@svr7 ~]# jobs 
[root@svr7 ~]# fg 1    #将后台编号为1的进程,恢复到前台运行
sleep 1000
^C                     #按Ctrl+c结束     
[root@svr7 ~]# jobs
[root@svr7 ~]# fg 2    #将后台编号为2的进程,恢复到前台运行
sleep 800
^C                     #按Ctrl+c结束  
###################################################

• 干掉进程的不同方法
– Ctrl+c 组合键,中断当前命令程序
– kill [-9] PID... 、kill [-9] %后台任务编号
– killall [-9] 进程名...
– pkill 查找条件

[root@svr7 ~]# sleep 100 &
[root@svr7 ~]# sleep 200 &
[root@svr7 ~]# sleep 300 &

[root@svr7 ~]# jobs -l
[root@svr7 ~]# kill 3573
[root@svr7 ~]# jobs 

[root@svr7 ~]# killall sleep
[root@svr7 ~]# jobs 

[root@svr7 ~]# sleep 400 &
[root@svr7 ~]# jobs 
[root@svr7 ~]# killall -9 sleep   #强制杀
[root@svr7 ~]# jobs 

 强制踢出一个用户(杀死一个用户开启的所有进程)

[root@svr7 ~]# killall -9 -u lisi

#################################################
日志管理

日志的功能
• 系统和程序的“日记本”
– 记录系统、程序运行中发生的各种事件
– 通过查看日志,了解及排除故障
– 信息安全控制的  依据

• 由系统服务rsyslog统一记录/管理
 
• 常见的日志文件
	/var/log/messages 记录内核消息、各种服务的公共消息
	/var/log/dmesg 	记录系统启动过程的各种消息
	/var/log/cron 	记录与cron计划任务相关的消息
	/var/log/maillog 	记录邮件收发相关的消息
	/var/log/secure 	记录与访问限制相关的安全消息

日志分析

• 通用分析工具
– tail、tailf、less、grep等文本浏览/检索命令
– awk、sed等格式化过滤工具

 tailf:实时跟踪日志消息
[root@svr7 ~]# echo 123 > /opt/1.txt
[root@svr7 ~]# cat /opt/1.txt
123
[root@svr7 ~]# tailf  /opt/1.txt
123
haha

• users、who、w 命令
– 查看已登录的用户信息,详细度不同

    pts/0:图形终端

• last、lastb 命令
– 查看最近登录成功/失败的用户信息
[root@svr7 ~]# users
[root@svr7 ~]# who
[root@svr7 ~]# w

[root@svr7 ~]# last -2    #最近登录成功的用户记录
[root@svr7 ~]# lastb -2   #最近登录失败的用户记录

################################################
日志消息的优先级
• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）          会导致主机系统不可用的情况
  1  ALERT（警告）          必须马上采取措施解决的问题
  2  CRIT（严重）	        比较严重的情况
  3  ERR（错误）	       运行出现错误
  4  WARNING（提醒）      可能会影响系统功能的事件
  5  NOTICE（注意）        不会影响系统但值得注意
  6  INFO（信息）	       一般信息
  7  DEBUG（调试）          程序或系统调试信息等

##################################################
使用journalctl工具
• 提取由 systemd-journal 服务搜集的日志
– 主要包括内核/系统日志、服务日志

• 常见用法
– journalctl | grep 关键词
– journalctl -u 服务名   [-p 优先级]
– journalctl -n 消息条数
– journalctl --since="yyyy-mm-dd HH:MM:SS" --
until="yyyy-mm-dd HH:MM:SS"

[root@svr7 ~]# journalctl -u httpd
[root@svr7 ~]# journalctl -xe
###############################################
systemctl控制

• Linux系统和服务管理器
– 是内核引导之后加载的第一个初始化进程(PID=1)
– 负责掌控整个Linux的运行/服务资源组合


systemd
• 一个更高效的系统&服务管理器
– 开机服务并行启动,各系统服务间的精确依赖

– 配置目录:/etc/systemd/system/
– 服务目录:/lib/systemd/system/
– 主要管理工具:systemctl


对于服务的管理
 systemctl restart  服务名    #重起服务
 systemctl start    服务名    #开启服务
 systemctl stop     服务名    #停止服务
 systemctl status   服务名    #查看服务当前的状态
 
 systemctl enable   服务名      #设置服务开机自启动
 systemctl disable  服务名      #设置服务不开机自启动


RHEL6 运行级别    
  
         0：关机    
         1：单用户模式（基本功能的实现，破解Linux密码）
	 2：多用户字符界面（不支持网络）    
	 3：多用户字符界面（支持网络）服务器默认的运行级别   
	 4：未定义
	 5：图形界面   
	 6：重起 
   
    切换运行级别：init  5  



RHEL7 运行模式 

   字符模式：multi-user.target
   图形模式：graphical.target

[student@room9pc01 ~]$ rht-vmctl reset classroom
classroom [OK]
域 classroom 已开始

[student@room9pc01 ~]$ rht-vmctl reset server
server [OK]
域 server 已开始





[root@svr7 /]# ls -l /lib/systemd/system/

当前直接切换到字符模式
[root@svr7 /]# systemctl isolate multi-user.target
当前直接切换到图形模式
[root@svr7 /]# systemctl isolate graphical.target

查看每次开机默认进入模式
[root@svr7 /]# systemctl get-default
graphical.target

设置永久策略，每次开机自动进入graphical.target
# systemctl set-default multi-user.target
# reboot 

#################################################

综合实验:
1.构建虚拟机C与虚拟机D的Web服务器
虚拟机C:
[root@svr10 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
  ServerName www.163.com
  DocumentRoot /var/www/163
</VirtualHost>
[root@svr10 ~]# mkdir /var/www/qq /var/www/163
[root@svr10 ~]# echo '<h1>Web1 QQ' > /var/www/qq/index.html
[root@svr10 ~]# echo '<h1>Web1 163' > /var/www/163/index.html

虚拟机D
[root@svr10 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
  ServerName www.163.com
  DocumentRoot /var/www/163
</VirtualHost>
[root@svr10 ~]# mkdir /var/www/qq /var/www/163
[root@svr10 ~]# echo '<h1>Web2 QQ' > /var/www/qq/index.html
[root@svr10 ~]# echo '<h1>Web2 163' > /var/www/163/index.html

2.虚拟机A构建DNS服务器
[root@svr7 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";
};

view "nsd" {
 match-clients {  192.168.4.7;  };
 zone "163.com" IN {
        type master;
        file "163.com.zone";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.zone";
  };
};
view "other" {
 match-clients {  any;  };
 zone "163.com" IN {
        type master;
        file "163.com.other";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.other";
  };
};
   
[root@svr7 ~]# cd /var/named/
[root@svr7 named]# vim qq.com.zone 
qq.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.10

[root@svr7 named]# vim qq.com.other 
qq.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.20

[root@svr7 named]# cp -p qq.com.zone 163.com.zone
[root@svr7 named]# vim 163.com.zone
163.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.10

[root@svr7 named]# cp -p 163.com.zone 163.com.other
[root@svr7 named]# vim 163.com.other
163.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.20
[root@svr7 /]# systemctl restart named

3.指定DNS服务器地址

[root@svr7 /]# echo 'nameserver 192.168.4.7'  > /etc/resolv.conf

[root@pc207 ~]# echo 'nameserver 192.168.4.7'  > /etc/resolv.conf

[root@svr10 ~]# echo 'nameserver 192.168.4.7'  > /etc/resolv.conf

[root@pc20 ~]# echo 'nameserver 192.168.4.7'  > /etc/resolv.conf

###################################################
部署DHCP服务器
• Dynamic Host Configuration Protocol
– 动态主机配置协议,由 IETF(Internet 网络工程师任
务小组)组织制定,用来简化主机地址分配管理

• 主要分配以下入网参数
– IP地址/子网掩码/广播地址
– 默认网关地址、DNS服务器地址

• DHCP地址分配的四次会话(以广播形式进行,先到先得)
– DISCOVERY --> OFFER --> REQUEST -->ACK

   在一个网络中,只能有一个DHCP服务器

• 服务端基本概念
– 租期:允许客户机租用IP地址的时间期限,单位为秒
– 作用域:分配给客户机的IP地址所在的网段
– 地址池:用来动态分配的IP地址的范围


虚拟机A:
1.安装dhcp软件包
[root@svr7 ~]# yum -y install dhcp
2.修改配置文件
[root@svr7 ~]# vim /etc/dhcp/dhcpd.conf     
末行模式下:
   :r /usr/share/doc/dhcp*/dhcpd.conf.example

subnet 192.168.4.0 netmask 255.255.255.0 {  #分配的网段
  range 192.168.4.100  192.168.4.200;     #分配的IP范围
  option domain-name-servers 192.168.4.7;  #分配DNS地址
  option routers 192.168.4.254;  #分配网关地址
  default-lease-time 600;
  max-lease-time 7200;
} 

3.重启dhcpd服务
[root@svr7 ~]# systemctl  restart dhcpd

###################################################
网络装机概述

网络装机的优势
• 规模化:同时装配多台主机
• 自动化:装系统、配置各种服务
• 远程实现:不需要光盘、U盘等物理安装介质

什么是PXE网络
• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装

• 工作模式
– PXE client 集成在网卡的启动芯片中
– 当计算机引导时,从网卡芯片中把PXE client调入内存
执行,获取PXE server配置、显示菜单,根据用户选
择将远程引导程序下载到本机运行

•服务端需要哪些服务组件
 – DHCP服务,分配IP地址、定位引导程序
 – TFTP服务,提供引导程序下载
 – HTTP服务,提供yum安装源


###################################################
在虚拟机A构建PXE网络装机服务器
一  配置DHCP服务器,指定下一个服务器地址
[root@svr7 ~]# vim /etc/dhcp/dhcpd.conf 
subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.100  192.168.4.200;
  option domain-name-servers 192.168.4.7;  #指定服务器地址
  option routers 192.168.4.254;  #网关
  default-lease-time 600;       #默认租赁时间
  max-lease-time 7200;        #最长租赁时间
  next-server  192.168.4.7;   #指定下一个服务器地址
  filename  "pxelinux.0";    #指定网卡引导文件名称
}

[root@svr7 ~]# systemctl restart dhcpd

 pxelinux.0:网卡引导文件 ,安装说明书,二进制文件
                      安装一个软件即可获得,默认生成的名字pxelinux.0

####################################################
二 构建tftp服务

  tftp:简单的文件传输协议                           
    端口默认为:69
    默认共享位置:/var/lib/tftpboot

1.安装软件包为tftp-server
[root@svr7 ~]# yum -y install tftp-server
2.重启服务
[root@svr7 ~]# systemctl restart tftp

3.部署pxelinux.0引导文件
]# yum  provides  */pxelinux.0  #查询那个包产生的该文件
]# yum -y install syslinux           
]# rpm -ql syslinux  | grep pxelinux.0  #查询软件包安装清单

]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/
]# ls /var/lib/tftpboot/

客户端----->DHCP---->next-server--->pxelinux.0
pxelinux.0---->/var/lib/tftpboot/pxelinux.cfg/default

4.部署默认菜单文件
首先关闭虚拟机A,图形添加一个光驱设备,放入光盘文件
[root@svr7 ~]# ls /dev/cdrom 
[root@svr7 ~]# mount /dev/cdrom  /mnt/
[root@svr7 ~]# ls /mnt/

]# mkdir /var/lib/tftpboot/pxelinux.cfg
]# cp /mnt/isolinux/isolinux.cfg  /var/lib/tftpboot/pxelinux.cfg/default

]# ls -l /var/lib/tftpboot/pxelinux.cfg/default


5.部署图形模块(vesamenu.c32)和背景图片(splash.png)
]# cp /mnt/isolinux/vesamenu.c32  /mnt/isolinux/splash.png  /var/lib/tftpboot/

]# ls /var/lib/tftpboot/
pxelinux.0  pxelinux.cfg  splash.png  vesamenu.c32

6.部署启动内核(vmlinuz)和驱动程序(initrd.img)
]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img /var/lib/tftpboot/

]# ls /var/lib/tftpboot/
initrd.img  pxelinux.cfg  vesamenu.c32
pxelinux.0  splash.png    vmlinuz

##################################################
总结:
 dhcp--->IP地址   next-server  filename
 tftp--->pxelinux.0
 pxelinux.0--->读取default菜单文件
 default--->vesamenu.c32 splash.png  vmlinuz  initrd.img

7.修改菜单文件内容
]# vim  /var/lib/tftpboot/pxelinux.cfg/default
末行模式 :set  nu
   1 default vesamenu.c32  #默认加载运行图形的模块
   2 timeout 600           #默认读秒时间  1/10秒

   10 menu background splash.png     #背景图片
   11 menu title NSD1904 PXE Server  #显示标题信息

  61 label linux
  62   menu label  Install CentOS7.5  #屏幕显示信息
  63   menu default                   #读秒结束后默认选项
  63   kernel vmlinuz                 #指定启动内核
  64   append initrd=initrd.img       #指定驱动程序
##################################################
[root@svr7 ~]# systemctl restart dhcpd
[root@svr7 ~]# systemctl restart tftp
##################################################
初步测试:
   新建一台全新的虚拟机
   1.安装方式选择:PXE网络引导安装
   2.内存必须2G   
   3.网络类型选择:private1

总结:
 dhcp--->IP地址   next-server  filename
 tftp--->pxelinux.0
 pxelinux.0--->读取default菜单文件
 default--->vesamenu.c32 splash.png  vmlinuz  initrd.img

#################################################
三 构建Web服务器,将光盘内容共享给客户端              
1.安装软件包
[root@svr7 ~]# yum -y install httpd

[root@svr7 ~]# mkdir /var/www/html/centos
[root@svr7 ~]# ls /var/www/html/centos

[root@svr7 ~]# mount /dev/cdrom  /var/www/html/centos
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 ~]# ls /var/www/html/centos
[root@svr7 ~]# systemctl restart httpd

[root@svr7 ~]# firefox http://192.168.4.7/centos

##################################################
四 部署无人值守安装,生成应答文件

1.安装一个system-config-kickstart图形化软件,生成应答文件
[root@svr7 ~]# yum -y install system-config-kickstart 

2.运行图形化工具
以英文语言进行运行
[root@svr7 ~]# LANG=en  system-config-kickstart
  
 点击 "软件包选择(Package Selection)" 查看是否可以进行选择
 需要Yum仓库的支持:指向光盘的内容仓库,标识必须为 [development]
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo 
[development]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[root@svr7 ~]# LANG=en  system-config-kickstart
 点击 "软件包选择(Package Selection)" 查看是否可以进行选择

[root@svr7 ~]# ls /root/ks.cfg           
/root/ks.cfg

[root@svr7 ~]# vim /root/ks.cfg

3.利用Web服务器共享应答文件
[root@svr7 ~]# cp /root/ks.cfg /var/www/html/
[root@svr7 ~]# ls /var/www/html/
centos  ks.cfg
[root@svr7 ~]# firefox http://192.168.4.7/ks.cfg

4.通过菜单文件,指定ks应答文件获取方式
]# vim /var/lib/tftpboot/pxelinux.cfg/default 
label linux
 menu label  Install CentOS7.5
 menu default
 kernel vmlinuz
 append initrd=initrd.img ks=http://192.168.4.7/ks.cfg

]# 
##################################################
总结:
 dhcp--->IP地址   next-server  filename
 tftp--->pxelinux.0
 pxelinux.0--->读取default菜单文件
 default--->图形模块  背景  内核  驱动   ks应答文件
 ks应答文件--->语言  分区  密码  时区 ...  指定获取软件包的方式
  获取软件包的方式---> --url="http://192.168.4.7/centos"

###################################################

总结:
 dhcp--->IP地址   next-server  filename
 tftp--->pxelinux.0
 pxelinux.0--->读取default菜单文件
 default--->图形模块  背景  内核  驱动   ks应答文件
 ks应答文件--->语言  分区  密码  时区 ...  指定获取软件包的方式
  获取软件包的方式---> --url="http://192.168.4.7/centos"
###################################################
rsync同步操作

rsync同步操作
• 命令用法
– rsync [选项...]   源目录     目标目录

• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据

同步控制
• rsync操作选项
– -n:测试同步过程,不做实际修改
– --delete:删除目标文件夹内多余的文档
– -a:归档模式,相当于-rlptgoD
– -v:显示详细操作信息
– -z:传输过程中启用压缩/解压


[root@svr7 ~]# mkdir   /dir01     /abc
[root@svr7 ~]# cp /etc/passwd /etc/fstab  /dir01
[root@svr7 ~]# ls /dir01

[root@svr7 ~]# rsync -avz   /dir01    /abc/  #同步目录本身
[root@svr7 ~]# ls /abc
[root@svr7 ~]# ls /abc/dir01/

[root@svr7 ~]# rsync -avz /dir01/   /abc/  #同步目录内容
[root@svr7 ~]# ls /abc/

[root@svr7 ~]# touch /dir01/1.txt
[root@svr7 ~]# ls /dir01/
[root@svr7 ~]# rsync -avz /dir01/   /abc/
[root@svr7 ~]# ls /abc/


[root@svr7 ~]# ls /dir01/
[root@svr7 ~]# ls /abc/
[root@svr7 ~]# touch /abc/haha.txt
[root@svr7 ~]# ls /abc/

[root@svr7 ~]# rsync -avz --delete  /dir01/  /abc/
[root@svr7 ~]# ls /abc/

[root@svr7 ~]# touch /abc/{1..5}.txt
[root@svr7 ~]# ls /abc/
[root@svr7 ~]# rsync -avz --delete  /dir01/  /abc/
[root@svr7 ~]# ls /abc/

###################################################
rsync+SSH同步

• 与远程的 SSH目录保持同步
– 下行:rsync [...]  user@host:远程目录      本地目录

– 上行:rsync [...]  本地目录   user@host:远程目录



虚拟机A:	
[root@svr7 ~]# rsync -avz --delete  /dir01/    root@192.168.4.207:/opt/

虚拟机B:
[root@pc207 ~]# ls /opt/

###################################################
虚拟机A:	
[root@svr7 ~]# touch /dir01/xixi.txt
[root@svr7 ~]# rsync -avz --delete  /dir01/ root@192.168.4.207:/opt/

虚拟机B:
[root@pc207 ~]# ls /opt

###################################################
实时同步

虚拟机A
一  生成公钥与私钥,实现ssh无密码验证
[root@svr7 ~]# ssh-keygen     #一路回车
[root@svr7 ~]# ls /root/.ssh/
authorized_keys(别的机器传递过来的公钥)  id_rsa(私钥)  id_rsa.pub(公钥) 

[root@svr7 ~]# ssh-copy-id root@192.168.4.207

[root@svr7 ~]# rsync -avz --delete  /dir01/ root@192.168.4.207:/opt/


二  监控目录内容的变化

安装inotify-tools工具                                         
真机上:
[student@room9pc01 ~]$ ls /linux-soft/01/
Cobbler.zip  tools.tar.gz
[student@room9pc01 ~]$ scp /linux-soft/01/tools.tar.gz    root@192.168.4.7:/root

1.让虚拟机A具备inotify-tools-3.13.tar.gz
[root@svr7 /]# ls /root/
[root@svr7 /]# mkdir /test
[root@svr7 /]# tar -xf /root/tools.tar.gz -C /test
[root@svr7 /]# ls /test
[root@svr7 /]# ls /test/tools/

步骤1:安装依赖关系包(安装开发工具)
]# yum -y install  gcc  make
步骤2:tar解包,释放源代码至指定目录
]# tar -xf /test/tools/inotify-tools-3.13.tar.gz -C /opt
]# ls /opt
]# cd /opt/inotify-tools-3.13/
]# ls
步骤3: ./configure 配置,指定安装目录/功能模块等选项
]# cd /opt/inotify-tools-3.13/
]# ./configure 
步骤4:make 编译,生成可执行的二进制程序文件
]# make
步骤5:make install 安装,将编译好的文件复制到安装目录
]# make install
]# ls /usr/local/bin/inotifywait 


inotifywait监控
• 基本用法
– inotifywait  [选项]  目标文件夹

• 常用命令选项
– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的 modify、move、create、delete、attrib等事件类别

三  书写Shell脚本

    for循环:适合有规定次数的循环
    while适合死循环:次数无限及无法确定

        while  [条件]
        do
                重复执行操作
        done

[root@svr7 /]# vim /opt/rsync.sh
#!/bin/bash
while  inotifywait  -rqq  /dir01 
do
 rsync -az --delete  /dir01/  root@192.168.4.207:/opt/
done

[root@svr7 /]# chmod +x /opt/rsync.sh

[root@svr7 /]# /opt/rsync.sh

#################################################

Cobbler装机平台,不同版本的多系统的安装

教学环境虚拟机3.1版本进行扩容
[root@svr7 ~]# df -h
文件系统        容量  已用  可用 已用% 挂载点
/dev/vda1       2.0G  1.8G  256M   88% /

[root@svr7 ~]# LANG=en growpart /dev/vda 1
[root@svr7 ~]# df -h
[root@svr7 ~]# xfs_growfs /dev/vda1

[root@svr7 ~]# df -h
文件系统        容量  已用  可用 已用% 挂载点
/dev/vda1        20G  1.8G   19G    9% /


一  具备一个CentOS虚拟机  
[root@svr7 ~]# cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 
                                     
二、虚拟机设置  
   1.设置防火墙为trusted
  ]# firewall-cmd  --set-default-zone=trusted 

   2.当前及永久设置SELinux状态为permissive
  ]# setenforce 0     #当前临时关闭
  ]# getenforce 
  ]# vim /etc/selinux/config 
  SELINUX=	


##################################################
[root@svr7 ~]# LANG=en growpart  /dev/vda   1  
[root@svr7 ~]# df -h
[root@svr7 ~]# xfs_growfs /dev/vda1
##################################################

三、利用scp真机传递cobbler.zip包到虚拟机192.168.4.7中
 # scp /home/student/桌面/cobbler.zip   root@192.168.4.7:/root/
 

##################################################

四、搭建Cobbler装机平台

  Cobbler概述软件，管理dhcp、tftp、Web服务
    自由的导入镜像与ks应答文件

1.解压cobbler.zip包
[root@svr7 ~]# yum -y install unzip 

[root@svr7 ~]# unzip /root/cobbler.zip -d /
[root@svr7 ~]# ls /cobbler/
cobbler_boot.tar.gz  cobbler_web.png
cobbler_rpm.zip
[root@svr7 ~]# 

[root@svr7 ~]# unzip /cobbler/cobbler_rpm.zip -d /opt/
[root@svr7 ~]# ls /opt/cobbler/

#####################################################
五、安装cobbler主程序、工具包等
]# yum -y install  dhcp  httpd  mod_ssl 

]# yum -y install  /opt/cobbler/*.rpm  

[root@svr7 ~]# rpm -q cobbler
cobbler-2.8.2-1.el7.x86_64
[root@svr7 ~]# 

################################################################
cobbler网络装机部署

1.安装软件 cobbler cobbler-web dhcp tftp-server pykickstart httpd  tftp-server 

 cobbler         #cobbler程序包
 cobbler-web     #cobbler的web服务包
 pykickstart     #cobbler检查kickstart语法错误
 httpd           #Apache web服务
 dhcp            #dhcp服务
 tftp-server     #tftp服务




2.配置cobbler
[root@svr7 /]# vim  /etc/cobbler/settings

 next_server:   192.168.4.7    #设置下一个服务器还为本机
 server:   192.168.4.7         #设置本机为cobbler服务器
 manage_dhcp:   1              #设置cobbler管理dhcp服务
 pxe_just_once:   1            #防止客户端重复安装操作系统

 开机启动项： 匹配及停止  
     1.硬盘启动     2.光驱设备     3.U盘     4.网络引导  


3.配置cobbler的dhcp
[root@svr7 /]# vim  /etc/cobbler/dhcp.template 

  :%s  /旧/新/g      #全文替换
  :%s  /192.168.1/192.168.4/g    #全文替换

    5 次替换，共 4 行   


4.绝对路径解压cobbler_boot.tar.gz    #众多的引导文件
# tar -tf  /cobbler/cobbler_boot.tar.gz   #查看包里面内容
# tar -xPf  /cobbler/cobbler_boot.tar.gz  #绝对路径释放
# ls  /var/lib/cobbler/loaders/

5.启动相关服务
  ]# systemctl restart cobblerd     
  ]# systemctl enable cobblerd

  ]# systemctl restart httpd
  ]# systemctl enable httpd

  ]# systemctl restart tftp
  ]# systemctl enable tftp

  ]# systemctl restart rsyncd   #同步服务
  ]# systemctl enable rsyncd

6.同步刷新cobbler配置
[root@svr7 /]# cobbler sync    #检测所有配置是否正确
......
*** TASK COMPLETE ***


]# firefox https://192.168.4.7/cobbler_web

   用户名：cobbler
   密码：cobbler                                         
 



##########################################################################################################
cobbler应用

  cobbler import  --path=挂载点   --name=导入系统命名（随意起）
导入安装镜像数据
# mkdir /dvd
# mount /dev/cdrom  /dvd
# ls /dvd/

# cobbler import --path=/dvd  --name=CentOS7

cobbler导入的镜像放在：/var/www/cobbler/ks_mirror


[root@cobbler /]# cobbler list    #查看有哪些系统
distros:
   CentOS7-x86_64        #安装客户端至少2G内存

profiles:
   CentOS7-x86_64

##############################################
删除
# cobbler list 
# cobbler profile remove --name=CentOS7-x86_64  #删除菜单信息
# cobbler distro remove --name=CentOS7-x86_64  #删除镜像信息


###########################################

# umount /dvd/
# mount /dev/cdrom  /dvd   将光盘换成RHEL7
# ls /dvd/

  安装完成机器 默认root  密码  cobbler

############################################################################################################
自定义应答文件：开头注释行删除

[root@cobbler ~]# system-config-kickstart  #生成ks文件

必须默认kickstart文件存放位置：/var/lib/cobbler/kickstarts/

[root@cobbler ~]# cobbler list

修改kickstart文件：
[root@cobbler ~]# cobbler profile edit --name=CentOS7  --kickstart=/var/lib/cobbler/kickstarts/自定义.cfg

[root@cobbler ~]# cobbler profile report
[root@cobbler ~]# cobbler sync  #同步配置

############################################################
###################################################
#################################################
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
#################################################
##################################################
#################################################
网络的功能:
1,数据通讯
2,资源共享
3,提高可靠
4,提高系统处理能力

网络历史
60年代,分组交换,可以提高数据传输成功率,降低服务器负担
70~80,TCP/IP
90~至今,web技术

iso 国际标准化组织
ieee 电子与电气工程师学会

WAN  几十公里     internet
LAN  1公里以内   办公室,教室,宿舍

企业级
思科  华为
路由器 交换机

拓扑结构:
1,点对点 , 适用范围是广域网
2,星形,适用范围是局域网,优点是容易扩展,易实现,易于故障排查
3,网状,适用范围是局域网,高可靠

osi七层参考模型(理论框架)
物理层,数据链路层,网络层,传输层,会话层,表示层,应用层
tcp\ip五层模型(实际使用)
物理层,数据链路层,网络层,传输层,应用层
 网卡    交换机   路由器  防火墙  PC

PDU协议数据单元:(不同层次数据在传输时用的单位)
物理层--比特流
数据链路层--数据帧
网络层--数据包
传输层--数据段

进入win2008系统
密码:tedu
==========================
运行脚本,教学环境需要:
172.40.50.115
pub目录下找kvm.sh
1,要用root执行(需要添加执行权限)
2,关闭所有虚拟机
成功后看到ok字样
==========================

网络设备命令行视图
1, 用户视图   >  system-view 
    系统视图 ]
    接口视图 g0/0/1]
    协议视图

quit   //返回上一视图
return 或者 快捷键ctrl +z  //返回到用户视图

模块 / 子卡/接口号

<Huawei>system-view             //进入系统视图
[Huawei]interface GigabitEthernet0/0/1    //进入接口视图
[Huawei-GigabitEthernet0/0/1]quit    //返回上一视图
[Huawei]
[Huawei]interface GigabitEthernet0/0/1    //再次进入接口视图
[Huawei-GigabitEthernet0/0/1]return     //返回用户视图
<Huawei>

修改主机名
[Huawei]sysname SW1    //在系统视图下将名字修改为SW1
[Huawei]display current-configuration  //查看当前配置
[Huawei]display this   //查看当前视图配置
[Huawei]display version   //查看系统版本,硬件型号等信息

配置用户名和密码:
<Huawei>system-view 
[Huawei]aaa          //进入aaa认证,此视图支持用户的创建
[Huawei-aaa]local-user admin01 password cipher 123    //创建账户叫admin01,密码123       
[Huawei-aaa]quit
[Huawei]user-interface console 0     //进入控制台接口视图   
[Huawei-ui-console0]authentication-mode aaa    //激活配置
然后使用快捷键 ctrl + ]   //退出系统,测试账户密码的配置

<Huawei>save    //保存配置,途中按y
<Huawei>reboot   //重启,途中按y

ip地址,相当于住址
MAC地址  (硬件地址  物理地址) ,相当于身份证号,全球唯一,不可更改

bit 比特(位) 二进制   0  1

0 1 

1+1     10

0123456789     10 
0123456789ABCDEF    10

十六进制
52:54:00:35:6e:56
5254:0035:6e56
52-54-00-35-6e-56

1对1       单播通讯
1对多      组播通讯
1对所有   广播通讯

MTU  最大传输单元,通常是1500字节

MAC地址长度48位,前24位记录了厂商标识,后24位记录了产品序号

交换机: 组建局域网的基本设备,可以智能的通过数据帧中的MAC地址
进行数据传递,因此交换机工作在数据链路层.

交换机工作原理
1,学习,学习源mac地址
2,广播,对除了数据来源的所有接口发送广播信息
3,转发,1对1通讯
4,更新,超过300秒无任何数据通讯,交换机会清除对应的mac地址记录
	   交换机接口设备关机或更换将会立刻删除对应mac地址记录

[Huawei]display mac-address    //查看mac地址表
[Huawei]in e0/0/1    //进入e0/0/1接口
[Huawei-ethernet0/0/1]shutdown   //关闭接口
[Huawei-ethernet0/0/1]undo shutdown   //打开接口

#######################################################################

网络功能, 资源共享 ,数据通讯,提高可靠,提高系统处理能力
60,分组交换
70~80 ,tcp/ip
90, web技术

iso 
osi
物理层 ,数据链路层,网络层,传输层 应用层
  网卡,     交换机,    路由器, 防火墙, PC
   比特流,  数据帧  ,  数据包,  数据段

拓扑结构
1,点对点 , 广域网
2,星形
3,网状

用户视图,系统视图,接口视图,协议视图  quit 
MAC,物理地址,硬件地址   
48位   前24位 厂商标识, 后24位厂商赋予的产品序号
交换机的工作原理
学习,广播,转发,更新

广播泛滥

vlan  虚拟局域网
1,控制广播
2,提高安全
3,提高带宽利用
4,降低数据传输延迟

4096个   0~4095    1000+ 

广播域, 相同广播域中的主机可以接收到来自本域的所有广播
1个广播域=1个部门=1个vlan=相同网段

vlan 2   //创建vlan 2
undo vlan 2   //删除vlan 2
vlan batch 2 6  //创建vlan2和vlan6
vlan batch 2 to 6  //创建vlan2,vlan3,vlan4,vlan5,vlan6
dispaly vlan   //查看vlan列表

in e0/0/3    //进入3接口
port link-type access    //接口类型修改为access
port default vlan 2      //将此接口加入vlan2
in e0/0/4    //进入4接口
port link-type access    //接口类型修改为access
port default vlan 2      //将此接口加入vlan2

或

[Huawei]port-group 1    //进入1号组
[Huawei-port-group-1]group-member Ethernet0/0/3 Ethernet0/0/4   //添加3接口与4接口到该组
[Huawei-port-group-1]port link-type access  //对全组接口修改类型
[Huawei-port-group-1]port default vlan 2 //将全组接口加入vlan2  

vlan3:
[Huawei]port-group 2    //进入2号组
[Huawei-port-group-2]group-member Ethernet0/0/5 Ethernet0/0/6   //添加5接口与6接口到该组
[Huawei-port-group-2]port link-type access  //对全组接口修改类型
[Huawei-port-group-2]port default vlan 3 //将全组接口加入vlan3 
最后使用 display vlan  查看配置

SW1
in e0/0/7
port link-type access    //接口类型修改为access
port default vlan 3      //将此接口加入vlan3

SW2
in e0/0/7
port link-type access    //接口类型修改为access
port default vlan 3      //将此接口加入vlan3
in e0/0/3
port link-type access    //接口类型修改为access
port default vlan 3      //将此接口加入vlan3

access 接入链路   承载1个vlan,通常在链接了终端设备(PC)的接口配置
trunk  中继链路   承载多个vlan,通常在两台交换机之间的链路配置

clear configuration interface Ethernet 0/0/7   //在系统视图,清空7接口所有配置,注意清空后接口自动关闭
in e0/0/7    //进入7接口
undo shutdown     //开启接口
port link-type trunk   //继续在7口中配置中继链路
port trunk allow-pass vlan all   //允许所有vlan通过
display this  //检查配置

配置思路:
1,规划vlan,需要多少创建多少
2,将对应的接口加入vlan
3,交换机之间的链路配置为trunk
最后pc配置好ip做ping测试

单点故障


链路聚合,提高链路可靠,提高链路带宽
注意:配置之前检查接口是否为默认状态,否则要清空配置
clear configuration interface Ethernet 0/0/7 
in e0/0/7
undo shutdown
1,找到要捆绑的接口,至少2个以上
2,创建链路聚合接口
interface Eth-trunk 1    //创建1号链路聚合接口
3,将物理接口加入链路聚合接口
trunkport ethernet 0/0/7  0/0/8   //将7口8口加入并捆绑在一起
port link-type trunk    //继续将1号链路聚合口配置为中继链路
port trunk allow-pass vlan all   //放行所有vlan

<Hhuawei>undo terminal monitor  //在用户视图下关闭某些信息提示
 
A 1~127   /8
255.0.0.0
B 128~191   /16
255.255.0.0
C 192~223     /24
255.255.255.0
192.168.0.1

172.25.0.10 /24     172.25.0.1~172.25.0.254
255.255.255.0

172.25.0.10 /16     172.25.0.1~172.25.255.254    172.25.0.255  172.25.1.0
255.255.0.0


c类地址可用范围,比如192.168.1.0网段 就是192.168.1.1~192.168.1.254

某网段中 第一个地址是网络ID,最后一个地址是广播地址

172.16.16.16    172.16.0.1~ 172.16.255.254
255.255.0.0

使用路由器链接不同网段
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/1]ip address 192.168.1.254 24
[Huawei-GigabitEthernet0/0/1]quit
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.254 24

网关:终端设备访问其他网段的出口,通常网关由一台三层设备承担,比如路由器
PC1 的ip 192.168.1.1 /24 网关192.168.1.254
PC2 的ip 192.168.2.1 /24 网关192.168.2.254

路由器可以将不同网段的数据进行传递,依靠路由表来选路
路由表指明当前设备可以前往的区域(网段)

路由表中具体可以前往的目的地可以由以下方式获得
1,直连路由 : 在设备接口配置好ip地址并且打开后 自动产生
2,静态路由 : 由管理员手工设置,小规模网络使用
ip route-static 目标网络id 目标网络子网掩码  下一跳地址

R1
[Huawei]ip route-static 192.168.3.0 24 192.168.2.2    //管理员人工指定(增加)该设备可以前往的网段是3.0, 只要将目的地址是3.0的数据扔向2.2即可
[Huawei]ip route-static 192.168.4.0 24 192.168.2.2
R2
[Huawei]ip route-static 192.168.1.0 24 192.168.2.1

#####################################################################

三层交换机= 三层路由 + 二层交换

使用三层交换机
可以先关闭信息提示避免干扰
<Huawei>undo terminal monitor
1,创建所需vlan
[Huawei]vlan batch 2 3
2,将接口加入对应vlan
interface g0/0/2
port link-type access
port default vlan 2
interface g0/0/3
port link-type access
port default vlan 3
3,在三层交换机虚拟接口配置ip,作为终端设备的网关
三层交换机配置ip需要在vlan虚拟接口进行
in vlan 1
ip address 192.168.1.254 24
in vlan 2
ip address 192.168.2.254 24
in vlan 3
ip address 192.168.3.254 24

添加普通交换机合理利用三层交换机的接口
1,新添加S3700一台
2,在S3700中创建vlan2 ,vlan3
3,将e0/0/2接口加入vlan2,e0/0/3接口加入vlan3

在两台交换机之间的链路配置trunk并放行所有vlan
S3700
in e0/0/22
port link-type trunk
port trunk allow-pass vlan all
S5700
in g0/0/1
port link-type trunk
port trunk allow-pass vlan all

为S5700的g0/0/2接口赋予ip的方式:
vlan 4  //创建vlan4
in vlan 4    //进入vlan4的虚拟接口
ip address 192.168.4.1 24   //为此接口配ip
in g0/0/2    //进入2口
port link-type access   //设置类型
port default vlan 4   //加入vlan4

dis ip interface brief  //查看所有配置过的ip
dis vlan    //可以在接口后面看到U代表开启D代表关闭

路由 指路
路由设备依靠路由表来传输不同网段数据

1,直连路由,接口配置ip并开启,自动生成
2,静态路由
3,动态路由,是由某些动态路由协议实现,适合大型网络
4,默认路由,是特殊的静态路由,可以访问任意网络
		  通常配置在末梢网络或网关出口设备

ospf 开放最短路径优先
宣告,告知其他设备自身所连接的网段

S5700:
ospf    //进入ospf协议视图
area 0   //进入区域0,小规模网络只需要一个区域,且必须从0开始
network 192.168.1.0 0.0.0.255   //宣告所在网段
network 192.168.2.0 0.0.0.255
network 192.168.3.0 0.0.0.255
network 192.168.4.0 0.0.0.255

路由器:
ospf
area 0
network 192.168.5.0 0.0.0.255
network 192.168.4.0 0.0.0.255

使用默认路由访问外部网段
1,删除路由器5网段的宣告
ospf
area 0
undo network 192.168.5.0 0.0.0.255
2,在三层交换机中配置默认路由(0.0.0.0 0 代表任意网络)
ip route-static 0.0.0.0 0 192.168.4.2    

传输层,定义了端口号,实现了端到端的链接

端口总数65536个
范围0~65535
1~1023  知名端口号

TCP 可靠,效率低,面向连接
UDP 不可靠, 效率高,无连接

TCP协议中比较重要的三个标志位
ACK 确认
SYN 打算与对方建立连接
FIN 打算与对方断开链接

三次握手  syn---ack,syn---ack
四次断开  fin---ack---fin---ack

ACL  访问控制列表
高级ACL  3000~3999   源ip  目标ip 源端口  目标端口  协议
基本ACL  2000~2999   源ip
1,创建acl条目
2,在接口应用

255.255.255.0
11111111.11111111.11111111.00000000

192.168.2.100

192.168.2.1 0.0.0.0
0严格匹配
1(8个1就是255) 不匹配
deny    拒绝
permit  允许

使用acl实现禁止192.168.2.1与192.168.1.1通讯 
在路由器上配置:
[Huawei]acl 2000  //创建acl2000
[Huawei-acl-basic-2000]rule deny source 192.168.2.1 0   //定义规则,禁止源地址是192.168.2.1的数据通过
[Huawei]interface G0/0/1  //进入1接口
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000    //在接口使用acl2000过滤进入的数据

最后验证使用2.1无法与1.1互通,而2.2可以

只允许2.1与1.1通讯,其他主机无法连通1.1
acl 2001  //创建acl2001 
[Huawei-acl-basic-2001]rule permit source 192.168.2.1 0   //允许2.1通过
[Huawei-acl-basic-2001]rule deny source any  //禁止任何人通过
[Huawei]interface G0/0/1  //进入1接口
[Huawei-GigabitEthernet0/0/1]undo traffic-filter inbound   //在接口删除之前启用的acl
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2001  //在接口应用新的acl
*注意:acl条目讲究顺序,匹配即立场,上述实验acl的规则不能写反!
display acl 2001   //查看配置的acl

通过高级acl的配置,禁止2.1访问1.1的网站,其他业务不受影响
acl 3000
rule deny tcp source 192.168.2.1 0 destination 192.168.1.1 0 destination-port eq 80
interface G0/0/1  //进入1接口
undo traffic-filter inbound   //在接口删除之前启用的acl(如果已经删除了,不用再删除,使用display this验证即可)
traffic-filter inbound acl 3000  //在接口应用新的acl
最后使用2.1访问1.1,效果是能ping通,却访问不了网站

交换机工作在数据链路层, 传输数据帧,可以智能的依靠MAC地址查找目的主机
路由器工作在网络层,传输数据包,依靠路由表完成数据转发
传输层可以实现端到端的数据传递
TCP 高可靠,效率低,面向连接
三次握手,四次断开
UDP 不可靠,效率高,无连接

ACL 基本 2000~2999 对源ip控制   deny permit
        高级 3000~3999 对源ip,目的ip,源端口,目的端口,协议
21 ftp tcp
22 ssh tcp
53 dns tcp/udp
80 http tcp
443 https tcp
69  tftp  udp
110 pop3 tcp
25  smtp tcp

nat  网络地址转换,可以将内部的私有ip地址与公有ip进行转换

A 1~127
B 128~191
C 192~223

私有ip地址范围
A 10.0.0.0~10.255.255.255
B 172.16.0.0~172.31.255.255
C 192.168.0.0~192.168.255.255

ipv4   42亿
100M  500~800  动态公网ip
100M  50000 静态公网ip      www.baidu.com  100.0.0.1
	    2000
ipv6   海量

配置方式
1,静态nat,一对一转换,一般用在服务器对外网发布服务时使用
2,easy ip,一对多转换,通常对只需要访问外网的设备配置
192.168.0.1 100.0.0.1 >                     < 100.0.0.2 192.168.0.1
路由器配置
in g0/0/0
ip add 192.168.2.254 24
in g0/0/1
ip add 100.0.0.1 8
进入外网接口配置nat:
nat static global 100.0.0.2 inside 192.168.2.1   //使用静态nat将外部地址100.0.0.2与内部地址192.168.2.1进行一对一绑定
nat static global 100.0.0.3 inside 192.168.2.2

静态nat使用1对1的方式,可以方便的让内外网互访,但成本较高
192.168.2.1 = 100.0.0.2  >         < 100.0.0.10
192.168.2.2 = 100.0.0.3  >         < 100.0.0.10
easy ip可以让内部多个私有地址通过一个公网ip出门,能最大程度节约公网ip,但如果先在外网向内网发送数据是无法通讯的.
192.168.2.1:2000= 100.0.0.1:2000  >         < 100.0.0.10         
192.168.2.2:2001 =100.0.0.1:2001  >         < 100.0.0.10     

使用easy ip让内部主机都通过一个外网的接口ip出门,可以达到节约公网ip的目的
acl 2000
rule permit source any     //使用acl定义任何内部地址 
进入路由器公网接口
nat outbound 2000    //让内部任何主机都可以利用g0/0/1(外网接口)的ip访问外网

STP 生成树协议,可以避免网络环路产生的广播风暴,达到保护网络的效果,还可以具有备份链路的作用

VRRP 虚拟路由冗余协议 
用来实现网关备份,通过虚拟路由器自动分配正真转发数据的节点(某台物理网关设备)
VRRP 成员
1, 主路由器,正在负责数据转发的设备
2, 备份路由器,处于监视状态,主路由器出现故障后立刻被其替代
3, 虚拟路由器,真正充当客户机网关的设备

MS1(左边的S5700)
in vlan 1  //进vlan1接口
ip add 192.168.1.252 24  //配ip
vlan 2   //创建vlan2
in vlan 2   //进vlan2接口
ip add 192.168.2.2 24  //配ip
in g0/0/1   //进接口
port link-type access
port default vlan 2  //加入vlan2
MS2
in vlan 1  //进vlan1接口
ip add 192.168.1.253 24  //配ip
vlan 3   //创建vlan3
in vlan 3   //进vlan3接口
ip add 192.168.3.2 24  //配ip
in g0/0/1   //进接口
port link-type access
port default vlan 3  //加入vlan3

dispaly ip interface brief  //查看ip

MS1
ospf
area 0
network 192.168.1.0 0.0.0.255
network 192.168.2.0 0.0.0.255
MS2
ospf
area 0
network 192.168.1.0 0.0.0.255
network 192.168.3.0 0.0.0.255
R(路由器)
ospf
area 0
network 192.168.2.0 0.0.0.255
network 192.168.3.0 0.0.0.255
network 192.168.4.0 0.0.0.255

使用查看路由表命令验证结果
可以只查看含有/24的行
display ip routing-table | include /24
可以临时让1.1使用1.252或者1.253作为网关
可以ping通4.1即可

在两台s5700配置vrrp功能
in vlan 1
vrrp vrid 1 virtual-ip 192.168.1.254   //
配置vrrp功能,组号1,虚拟路由器ip为192.168.1.254

display vrrp brief   //查看vrrp状态,两台设备
				应该是一主(master)一备(backup)
最后将1.1的网关设置为1.254测试全网互通即可

新增加vlan(部门)
MS1
vlan 10
in vlan 10
ip add 192.168.10.252 24
MS2
vlan 10
in vlan 10
ip add 192.168.10.253 24

将三层交换机与新部门之间的链路配置为trunk
MS1与MS2以及新部门交换机(SW2)相连的接口
in g0/0/3
port link-type trunk
port trunk allow-pass vlan all

SW2
vlan 10    
in e0/0/3
port link-type access
port default vlan 10
使用10.1去ping192.168.10.252与10.253都可以通

在 MS1与MS2宣告10网段
ospf
area 0
network 192.168.10.0 0.0.0.255

开启vlan10的vrrp功能
MS1与MS2
in vlan 10
vrrp vrid 10 virtual-ip 192.168.10.254

使用vrrp实现负载均衡
最终需要使MS1成为vlan1的主,MS2成为vlan10的主
MS1
in vlan 1   //进入MS1的vlan1接口
vrrp vrid 1 priority 105   //修改优先级为105,立刻成为vlan1的主
MS2
in vlan 10  //进入MS2的vlan10接口
vrrp vrid 10 priority 105  //修改优先级为105,立刻成为vlan10的主

**********************************************************************

vlan trunk 链路聚合  stp ospf 静态路由  默认路由  acl vrrp nat

组建大型企业网络

1,规划vlan,每台交换机分别创建vlan10 20 30 40
	vlan batch 10 20 30 40
2,将每台主机链接的交换机接口加入所在的vlan
   sw1 进入0/0/1接口加入vlan10
	    in e0/0/1
		port link-type access
		port default vlan 10
3,将交换机与三层设备链接的链路配置为trunk
	sw1~sw3
	port-group 1  //创建接口组,为了方便在多个接口实现相同命令
	group-member ethernet 0/0/21 ethernet 0/0/22
	port link-type trunk
	port trunk allow-pass vlan all
	sw4
	interface eth-trunk 1   //创建链路聚合接口1
	trunkport ethernet 0/0/19 0/0/20  //将19和20号口捆一起
	port link-type trunk  //将聚合接口1配置为trunk
	port trunk allow-pass vlan all  //允许所有vlan通过
	interface eth-trunk 2   //创建链路聚合接口2
	trunkport ethernet 0/0/21 0/0/22  //将21和22号口捆一起
	port link-type trunk
	port trunk allow-pass vlan all

4,添加2台三层交换机,重命名ms1 与 ms2,同时创建之前的4个vlan
	sysname ms1
   	vlan batch 10 20 30 40
    port-group 1  //创建接口组,为了方便在多个接口实现相同命令
	group-member g0/0/1 to g0/0/3 g0/0/6  //添加了4个口
	port link-type trunk    //给这个4个口都配成trunk
	port trunk allow-pass vlan all
	ms1与ms2
	interface eth-trunk 1   //创建链路聚合接口1
	trunkport gigabitethernet 0/0/4 0/0/5  //将4和5号口捆一起
	port link-type trunk
	port trunk allow-pass vlan all	

5,为三层交换机配置ip,并测试
	ms1配置252 , ms2都把252改成253
	in vlan 10  
	ip add 192.168.10.252 24
	in vlan 20  
	ip add 192.168.20.252 24
	in vlan 30  
	ip add 192.168.30.252 24
	in vlan 30  
	ip add 192.168.40.252 24

display ip interface brief    //查看所有配置的ip地址

6,配置vrrp实现虚拟网关
ms1成为vlan10与20的主
	in vlan 10
	vrrp vrid 10 virtual-ip 192.168.10.254
	vrrp vrid 10 priority 105  //提高优先级,在vlan10保持主的身份
	in vlan 20
	vrrp vrid 20 virtual-ip 192.168.20.254
	vrrp vrid 20 priority 105  //提高优先级,在vlan20保持主的身份
	in vlan 30
	vrrp vrid 30 virtual-ip 192.168.30.254
	in vlan 40
	vrrp vrid 40 virtual-ip 192.168.40.254
ms2成为vlan30与40的主
	in vlan 10
	vrrp vrid 10 virtual-ip 192.168.10.254
	in vlan 20
	vrrp vrid 20 virtual-ip 192.168.20.254
	in vlan 30
	vrrp vrid 30 virtual-ip 192.168.30.254
	vrrp vrid 30 priority 105  //提高优先级,在vlan30保持主的身份
	in vlan 40
	vrrp vrid 40 virtual-ip 192.168.40.254
	vrrp vrid 40 priority 105  //提高优先级,在vlan40保持主的身份

排错: 1,首先检查所有ip,子网掩码与网关 , 然后查看所有交换机是否都创建了4个vlan, 所有交换机之间所链接的链路是否全是trunk

7,为三层交换机外网出口配置ip
	ms1
	vlan batch 50 60
	in vlan 50
	ip add 192.168.50.2 24
	in g0/0/7
	port link-type access
	port default vlan 50
	in vlan 60
	ip add 192.168.60.2 24
	in g0/0/8
	port link-type access
	port default vlan 60
	ms2
	vlan batch 70 80
	in vlan 70
	ip add 192.168.70.2 24
	in g0/0/7
	port link-type access
	port default vlan 70
	in vlan 80
	ip add 192.168.80.2 24
	in g0/0/8
	port link-type access
	port default vlan 80

8,同时为路由器配置对应ip
9,为三层交换机开启ospf
	ms1
	ospf
	area 0
	network 192.168.10.0 0.0.0.255
	network 192.168.20.0 0.0.0.255
	network 192.168.30.0 0.0.0.255
	network 192.168.40.0 0.0.0.255
	network 192.168.50.0 0.0.0.255
	network 192.168.60.0 0.0.0.255
	ms2
	ospf
	area 0
	network 192.168.10.0 0.0.0.255
	network 192.168.20.0 0.0.0.255
	network 192.168.30.0 0.0.0.255
	network 192.168.40.0 0.0.0.255
	network 192.168.70.0 0.0.0.255
	network 192.168.80.0 0.0.0.255
	R1
	ospf
	area 0
	network 192.168.50.0 0.0.0.255
	network 192.168.70.0 0.0.0.255
	R2
	ospf
	area 0
	network 192.168.60.0 0.0.0.255
	network 192.168.80.0 0.0.0.255
10,添加外部网络,外网设备使用3700交换机
	路由器链接外网的接口配置ip
	然后配置默认路由
	R1与R2
	ip route-static 0.0.0.0 0 100.0.0.10  //配置默认路由
	ospf
	default-route-advertise   //对外通告默认路由
11,配置nat让内外互通
	R1与R2
	acl 2000   //创建acl确定谁可以访问外网的主机
	rule permit source any   //任何人都可以
	in g0/0/2
	nat outbound 2000  //进入接口开启nat,列表2000中是所有人

************************************************************************
************************************************************************
************************************************************************
************************************************************************
************************************************************************
************************************************************************
************************************************************************
************************************************************************
************************************************************************

200行

cat /etc/shells    //查看本机可用解释器

准备环境
rht-vmctl reset classroom
rht-vmctl reset desktop
rht-vmctl reset server

进入desktop或者server中:
yum -y install ksh   //安装新解释器

bash优点:
历史记录,tab键,快捷键,管道, 重定向

一个标准的shell脚本包含:
1, 声明解释器
2, 注释,脚本功能,变量的含义等
3,执行指令(脚本内容)

#!/bin/bash
#这是一个测试脚本
echo "你好"

执行脚本的方式
1,添加完x权限后,使用完整路径
	chmod +x 脚本.sh
	/opt/脚本.sh
2,bash 脚本.sh
3,source  脚本.sh

bash 执行脚本时开启子进程
source 执行脚本不开启子进程
		pstree可以看到进程树
测试用以下脚本:

#!/bin/bash
mkdir abcd
cd abcd

bash看不到进入目录的效果,新开启的bash进程进入目录后的效果随着脚本结束而消失
source可以看到,因为不开启子进程,只使用当前解释器的进程


编写自动配置yum仓库的脚本:
#!/bin/bash
rm -rf /etc/yum.repos.d/*.repo
echo "[test]
name=abcdefg
baseurl=http://172.25.0.254/content/rhel7.0/x86_64/dvd/
enabled=1
gpgcheck=0" > /etc/yum.repos.d/test.repo

执行脚本后,使用yum repolist检查

编写自动安装ftp并设置开机自启的脚本:
#!/bin/bash
yum -y install vsftpd  &> /dev/null   //安装过程不显示
systemctl start vsftpd
systemctl enable vsftpd

systemctl stop firewalld  //运行脚本后关闭防火墙用真机链接虚拟机的ftp测试
vim /etc/vsftpd/vsftpd.conf   //ftp的配置文件可以根据需要开启匿名上传,修改第29行, 另外/var/ftp/pub需要给写权限
anon_upload_enable=YES    //创建文件
anon_mkdir_write_enable=YES   //创建目录
如果要测试写入权限,需要修改配置后重启服务,并关掉selinux
systemctl restart vsftpd
setenforce 0

变量,使用变量名代替未知量,大大增加脚本灵活
变量名的定义,使用字母,数字,下划线,不能以数字开头,不能用特殊符号
User=10   //等号两边不要出现空格
User=20   //再次给变量赋值会覆盖之前的值
unset User   //删除变量

变量种类:
1,自定义变量
2,系统变量,包含
	环境变量 PWD,HOME,UID,HOSTNAME,PATH,USER,SHELL,PS1,PS2
	位置变量 $1   $2   $3 ....
	预定义变量 $0   $?    $$    $*    $#

#!/bin/bash
echo $1
echo $2
echo $3
echo $0  显示脚本名
echo $*	 所有参数
echo $#  参数的个数
echo $?  上一任务是否成功,0成功,非0失败
echo $$  显示进程号(PID)

编写脚本实现   创建用户abc,并配置密码123

#!/bin/bash
useradd abc
echo 123 | passwd --stdin abc

改良版
#!/bin/bash
useradd $1
echo $2 | passwd --stdin $1

env  显示所有环境变量
set  显示所有变量


''    界定范围,屏蔽特殊符号的效果
""   界定范围
touch  a b   // 创建2个文件
touch  "a b"  //创建1个文件
touch  'a b'  //创建1个文件
a=10
echo $a     //显示变量内容
echo "$a"   //显示变量内容
echo '$a'	//显示$a  ,$的特殊含义被单引号屏蔽

``  获取命令结果
mv a `date +%Y%m%d`    //将a文件改名为当天日期
tar -czf log-`date +%Y%m%d`.tar.gz   /var/log  //备份日志改名为log-当天日期.tar.gz


编写创建用户配置密码的脚本:
#!/bin/bash
read -p "请输入用户名" User
useradd $User
stty -echo
read -p "请输入密码" Pass
stty echo 
echo $Pass | passwd --stdin $User


stty -echo  //关闭回显,屏蔽用户输入的内容,不影响系统弹出的信息
stty echo  //开启回显

export 发布全局变量,使子进程可以使用父进程定义的变量
		通常没有发布全局变量时,定义的变量为局部效果

测试:
a=10     //定义局部变量
export a   //修改为全局变量
export b=20   //新定义+发布全局变量
bash    //进入子进程
echo $a   //检测全局变量是否可用
echo $b
exit	//退出子进程
export -n a    //取消变量a的全局效果,恢复局部变量效果
bash   //进入子进程
echo $a  //检测效果,发现无内容

shell中的运算
方法一:
expr  +  -  \*  /   %求模(取余数)
注意,运算符号两边必须加空格,乘号需要使用\(转义符号)或者''(单引号)取消原本含义
方法二:使用$[]或$(())表达式
echo $[1+1] 或 echo $((1+1)) 
echo $[2-1] 
echo $[2*2] 
echo $[4/2] 
echo $[10%3] 
方法三:使用let命令,let在运算时不显示结果,可以方便的对变量进行自增减
let a=a+10 相当于 a+=10,后面是主流写法
	a=a-10  	a-=10
	a=a+1   	a++
	a=a-1  		a--
	a=a*10  	a*=10
	a=a/10  	a/=10
	a=a%10 	    a%=10

验证可以用echo $a

方法四: bc,可以进行小数运算,scale可以确定小数点后面位数
[root@desktop0 opt]# echo "1+1" | bc
2
[root@desktop0 opt]# echo "11.1+1" | bc
12.1
[root@desktop0 opt]# echo "10/3" | bc
3
[root@desktop0 opt]# echo "scale=3;10/3" | bc
3.333
[root@desktop0 opt]# echo "scale=3;10/3;1+1" | bc
3.333
2

**********************************************************************

bash  快捷键,tab,管道,历史记录,重定向
1,声明解释器 2注释脚本功能,重要变量的含义  3脚本代码
1,自定义变量  
2,系统变量,包含环境变量 PWD HOSTNAME USER  HOME  UID PATH PS1 PS2 SHELL ,位置变量 $1 $2 $3.... ,预定义变量 $0 $* $# $? $$
''   ""   ``   read -p  stty  -echo    stty  echo
export a=10   export -n    unset
运算,1 expr  +  -  \(转义)*  /  %
	2 echo $[1+1]
	3 let  a*=10   a=a*10
			a++  a--

条件测试:   使用“test 表达式”或者[ 表达式 ]都可以

1,字符串匹配   
[ a == a ]	//判断a是否等于a
echo $?   	//结果为0,正确
[ a != a ]  //判断a是否不等于a
echo $?  	//结果为非0,错误
[ $USER == root ]  //判断当前用户是不是管理员

&& 且,前置命令成功后才执行后面命令
|| 或,前置命令失败后才执行后面命令
[ a == a ] && echo ok  
[ a == b ] && echo ok
[ a == a ] || echo "前置任务失败了"
[ a == b ] || echo "前置任务失败了"

[ -z $a  ]  //测试变量a是否为空,是空返回0
[ ! -z $a  ] 或  [  -n $a  ]  //测试变量a,不是空的时候返回0

多个逻辑符号连用时:
&& 且, 前后任务都成功,才算成功
|| 或 ,前后任务有一个成功,就算成功
[ -z $a ] && echo "a是空的"  ||  echo "a不是空的"
[ ! -z $a  ] && echo "a不是空的"  ||  echo "a是空的"  


2,比较整数值的大小
-eq等于   -ne不等于   -ge大于等于    -gt大于    -le小于等于    -lt小于

X=20  	//定义一个测试变量
[ $X -eq 20 ] && echo "相等" || echo "不相等"
[ $X -eq 30 ] && echo "相等" || echo "不相等"
[ $X -ne 20 ] && echo "不等于" || echo "等于"
[ $X -ne 30 ] && echo "不等于" || echo "等于"
[ $X -gt 10 ] && echo "大于" || echo "否"
[ $X -gt 20 ] && echo "大于" || echo "否"
[ $X -gt 30 ] && echo "大于" || echo "否"


写一个脚本,实现:
每2分钟检测服务器登录用户的数量,如果超过3人,则发邮件给管理员报警

素材:
crontab
who | wc -l
[ -gt 3 ]   &&  echo "报警"  |  mail -s test root


#!/bin/bash
n=`who | wc -l`    //定义变量n,为目前登录账户的数量
[ $n -gt 3 ]  &&  echo "报警"  |  mail -s test root   //用变量n与3对比,如果大于3,则发邮件给管理员,邮件标题是test,内容是"报警"  

n=`who | wc -l` 与  [ $n -gt 3 ] 也可以写成[ `who | wc -l` -gt 3 ]
可以提前准备邮件文本,使用输入重定向,邮件内容就是文本内容
mail -s test root < txt

脚本写完后 添加x权限
并在计划任务中添加具体执行时间与脚本位置
crontab -e
*/2 * * * * /opt/test1.sh    //每2分钟执行一次脚本

/var/spool/mail/root    //管理员所有邮件所在的文件,测试前可以先删除此文件

3,识别文件/目录的状态
-r读    -w写    -x执行
-e存在   -f存在且是文件    -d存在且是目录

[ -r  txt  ]  //测试当前用户对文件txt有没有读权限(对root无效)
[ -w  txt  ]  //测试当前用户对文件txt有没有写权限(对root无效)
[ -x  txt  ]  //测试当前用户对文件txt有没有执行权限
[ -e  txt  ]  //txt是否存在,不在乎文件类型
[ -f  txt  ]  //txt是否存在,还必须是文件
[ -d  txt  ]  //txt是否存在,还必须是目录

4,多个条件/操作的逻辑组合
&&        ||     

==    !=    -z    ! -z (-n)   -eq   -ne   -gt  -ge  -lt  -le   -r  -w  -x   -e  -f   -d

if判断

单分支
if 条件测试;then
	执行指令
fi


if 条件测试
then
	执行指令
fi


双分支
if 条件测试;then
	命令序列1
else
	命令序列2
fi

ping 

使用if双分支编写脚本,测试与其他主机的链接情况: 
ping命令可以使用选项增加工作效率  
-c 定义ping的次数   -i 定义ping的间隔时间,单位秒  -W 定义反馈结果的时间,单位秒

#!/bin/bash
ping -c 3 -i 0.2 -W 1 $1  &> /dev/null
if [ $? -eq 0 ];then
    echo "通了"
else
    echo "不通"
fi

#!/bin/bash
[ -z $1 ] && echo "请在脚本名后输入ip" && exit
ping -c 3 -i 0.2 -W 1 $1  &> /dev/null
if [ $? -eq 0 ];then
    echo "通了"
else
    echo "不通"
fi

#!/bin/bash
read -p "请输入ip地址"  ip
ping -c 3 -i 0.2 -W 1 $ip  &> /dev/null
if [ $? -eq 0 ];then
    echo "通了"
else
    echo "不通"
fi


多分支
if 条件测试;then
	命令序列1
elif 条件测试;then
	命令序列2
else
	命令序列3
fi

使用RANDOM获取随机数字,编写猜大小脚本
#!/bin/bash
x=$[RANDOM%11]   //使用随机数除11,取余数范围在0-10之间,为变量x
read -p "请输入一个数字(0-10)"  n   //用户提供一个数字,为变量n  
if [ $n -eq $x ];then    //利用if多分支将x与n进行对比,如果相等
	echo "猜对啦"        //反馈信息
elif [ $n -gt $x ];then    //如果用户给的数字大于随机数
	echo "猜大了"	//反馈信息
else
	echo "猜小了"        //最后一种情况
fi

for循环

for 变量名  in 参数1 参数2 参数3......
do
	任务指令
done


1,与变量有关,而且关心循环次数
2,只关心循环次数

#!/bin/bash
for i in {1..8}
do
    echo nb
done

#!/bin/bash
for i in `seq 8`
do
    echo nb
done

#!/bin/bash
x=5
for i in `seq $x`
do
    echo nb
done

利用文本创建账户,账户数量由文本决定
#!/bin/bash
for i in `cat user`  //查看文本user后,将内容依次交给i循环
do
	useradd $i   //第一次循环创建的是文本中的第一个用户,以此类推
done

vim /etc/vimrc
set ts=4    //ts是tabstop,vim编辑器中每次tab间隔4个空格,默认8个

编写脚本实现,一次检测12台主机172.25.0.1~172.25.0.12的网络状况,仅仅显示结果
#!/bin/bash
x=0
y=0
for i in {1..12}
do
    ping -c 3 -i 0.2 -W 1 172.25.0.$i  &> /dev/null
    if [ $? -eq 0 ];then
        echo "172.25.0.$i 通了"
        let x++			//每通一台,x就+1
    else
        echo "172.25.0.$i 不通"
        let y++			//每不通一台,y就+1
    fi
done
echo "$x台通了,$y台不通"



while 条件测试
do
	任务序列
done

使用while循环编写猜数脚本,猜对为止,并统计猜的次数
#!/bin/bash
x=$[RANDOM%101]
c=0
while :
do
    read -p "请输入一个数字(0-100)" n
    let c++
    if [ $n -eq $x ];then
        echo "猜对了,猜了$c次"
        exit
    elif [ $n -gt $x ];then
        echo "猜大了"
    else
        echo "猜小了"
    fi
done

#######################################################################


&&   ||    if
case分支,简化版本ｉｆ，功能不如ｉｆ强大，代码比ｉｆ简洁

case 变量  in
模式1)
	命令序列1;;
模式2)
	命令序列2;;
模式3)
	命令序列3;;
*)
	命令序列4
esac

httpd nginx

编写一键源代码编译安装nginx软件的脚本
源码安装Nginx需要提前安装依赖包软件gcc,openssl-devel,pcre-devel

#!/bin/bash
yum -y install gcc openssl-devel pcre-devel
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make
make install

运行脚本后执行:
/usr/local/nginx/sbin/nginx   //开启nginx服务
systemctl stop firewalld      //关闭防火墙后,用真机浏览器测试虚拟机的web服务是否正常  http://172.25.0.10  


netstat -ntulp | grep nginx
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）

编写方便使用nginx服务的工具脚本
#!/bin/bash
case $1 in
start)
	netstat -ntulp | grep -q nginx
	[ $? -eq 0 ] && echo "服务已经开启"   &&  exit
	/usr/local/nginx/sbin/nginx;;	//开启服务
stop)
	/usr/local/nginx/sbin/nginx -s stop;;   //关闭服务
re)
	/usr/local/nginx/sbin/nginx -s stop    //先关闭再开启
	/usr/local/nginx/sbin/nginx;;		  可以实现重启效果
status)
	netstat -ntulp | grep -q nginx		//检查服务状态
	[ $? -eq 0 ] && echo "服务开启"   ||  echo "服务未开启";;
*)
	echo "start | stop | re | status"
esac



在Shell脚本中，将一些需重复使用的操作，定义为公共的语句块，即可称为函数。通过使用函数，可以使脚本代码更加简洁，增强易读性，提高Shell脚本的执行效率

格式1：
function  函数名 {
    命令序列
    .. ..
}

格式2：
函数名() {
    命令序列
    .. ..
}

#!/bin/bash
a(){			//定义函数,名为a
echo abc		//函数中的指令,可以是多条
echo xyz
}

a	//执行函数
a	//再次执行函数,多次执行可以体现函数优势


#!/bin/bash
cecho(){
echo -e "\033[$1m$2\033[0m"
}

cecho 31 ABCDEFG
cecho 32 ABCDEFG
cecho 33 ABCDEFG
cecho 34 ABCDEFG
cecho 35 ABCDEFG
cecho 36 ABCDEFG



break	  //终止循环,继续执行循环之后的任务
continue  //终止本次循环,继续下一次循环
exit     //直接退出脚本

编写为用户提供的数字求和脚本,0是结束
#!/bin/bash
x=0
while :
do
	read -p "请输入一个数字(0是结束)"  n
	[ $n -eq 0 ]  && break
	let x+=n

done
echo "总和是 $x"


编写脚本,找出1~20中谁是6的倍数

#!/bin/bash
for i in {1..20}
do
	x=$[i%6]	//依次用数字除6取余数
	[ $x -ne 0 ] && continue  //余数不等于0的话,结束本次循环
	echo $i						进入下一次循环
done


字串处理
1,字串截取

${变量名:起始位置:长度} 
a=abcdef
echo ${a:0:2}    //截取变量a中的字串,从第一位开始截取2位
echo ${a::2} 	//0可以省略
echo ${a:3:1} 	//截取第4位字符

获取1位随机字符
n=$[RANDOM%62]
echo ${x:n:1}

如何获取8位?
编写获取8位随机字符的脚本
#!/bin/bash
x=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQR
STUVWXYZ0123456789
for i in {1..8}
do
    n=$[RANDOM%62]		//求出随机数,范围是0~61之间
    txt=${x:n:1}		//截取出对应的字符
    pass=$pass$txt		//累加放在变量pass里面
done
echo $pass			//循环结束后,得出结果


2,字串替换
${变量名/old/new} 

a=111
echo ${a/1/a}    //将1个1替换为a
echo ${a//1/a}   //将所有1都替换为a
echo ${a/11/aa}  //将11替换为aa
echo ${a//1/}    //替换为空,等于删除

3,字串删除
掐头
${变量名#被删除内容}        //从左往右删除

a=`head -1 /etc/passwd`     //准备素材
echo ${a#root}			//从左往右删除到root
echo ${a#x}			//从左往右删除到x,无效,因为第一个字符不是x
echo ${a#root:x}	//手工输入需要删除的内容
echo ${a#*x}		//使用通配符删除到x以及x左边所有内容,效果同上
echo ${a##*root}    //从左往右删除删除到最后一个root,以及root左边所有内容
echo ${a#*:root}   //从左往右删除到第一个:root,以及左边所有

去尾
echo ${变量名称%被删除的内容}

echo ${a%bash}      //去尾,删除到第一个bash
echo ${a%root*}     //删除到第一个root,以及此root右边所有
echo ${a%%root*}	//删除到最后一个root,以及此root右边所有
echo ${a%%:*}		//删除到最后一个:  ,以及右边所有

利用字串删除功能编写脚本,用来实现批量修改扩展名
将所有.txt 文件 修改为 .doc
#!/bin/bash
for i in `ls *.txt`    //找到所有.txt文件 依次交给for循环
do
        n=${i%.*}      //把找到的每个文件去尾,得到无扩展名的文件名
        mv $i $n.doc   //修改文件,将名称与.doc组合
done

改良
#!/bin/bash
for i in `ls *.$1` 
do
        n=${i%.*}  
        mv $i $n.$2
done


定义变量初值(备用值)
aa=			//aa等于空
echo ${aa:-123}     //定义初值,如果aa是空,则a的内容就是123
								     非空的话,则显示具体内容
aa=10		//aa非空
echo ${aa:-123}    //不会显示123

编写创建用户并配置密码的脚本,如果用户没有输入密码直接回车,则统一使用123,如果用户输入了密码则不使用123
#!/bin/bash
read -p "请输入用户名"   n
useradd  $n
read -p "请输入密码"  p
echo ${p:-123} | passwd --stdin $n

##############################################################

case 变量 in
模式1)
	命令序列1;;
模式2)
	命令序列2;;
模式3)
	命令序列3;;
*)
	命令序列4
esac

netstat -ntulp 

函数名称(){

}

break  终止循环,继续执行循环之后的任务
continue   结束本次循环,继续下一次循环
exit   直接退出脚本

字串处理:

${变量名:}    截取
${变量名/}   替换
${变量名#}   掐头   
${变量名%}   去尾
${变量名:-}    定义初值


正则表达式,用来查找过滤文档的工具符号
grep "root" user    //在user文档中查找有单词root的行
grep "^root"  user  //在user文档中查找以单词root开头的行
grep "bash$"  user  //在user文档中查找以单词bash结尾的行
grep "^$"  user    //查找空行
grep "^ "  user    //查找以空格开头的行
grep "[rot]"  user  //查找字母r或者o或者t
grep "roo[tn]" user  //查找root或者roon
grep "[^rot]"  user  //查找字母r或者o或者t之外的内容
grep "[a-z]"  user  //查找小写字母
grep "[A-Z]"  user  //查找大写字母
grep "[a-Z]"  user  //查找所有字母
grep "[0-9]"  user  //查找数字

grep "r..t" user  //查找以r开头t结尾中间有2个任意字符的单词
grep "ro*" user   //查找以r开头后面有或没有字母o的单词,o可以出现任意次
grep  "o\{1,2\}"   user   //查找o出现1次到2次的行
grep  "o\{2,3\}"   user   //查找o出现2次到3次的行
grep  "o\{2\}"   user   //查找o出现2次的行
grep "o\{1,\} "  user  //查找o出现1次以及1次以上
grep  "\(:0\)\{2\}"  user  //查找:0(数字零)连续出现2次的行
扩展正则
egrep  "o+"  user  //查找o出现1次以及1次以上
egrep  "o?"  user  //查找o出现0次或1次
egrep  "o{1,2}"  user  //查找o出现1次到2次的行
egrep  "o{2,3}"  user   //查找o出现2次到3次的行
egrep  "o{2}"   user   //查找o出现2次的行
egrep  "o{1,}"  user  //查找o出现1次以及1次以上
egrep  "(:0){2}"  user  //查找:0(数字零)连续出现2次的行
egrep  "bash|nologin"  user  //查找bash或者nologin
egrep  "\bthe\b"  a  //查找单词the,前后是空格或者特殊符号


vim 交互式文本编辑工具
sed 流式编辑器,能对文档执行增删改查等操作,逐行操作,非交互式
sed使用方式:
前置命令  |  sed 选项  (定址符)指令
sed 选项  (定址符)指令   文档
选项
-n 屏蔽默认输出
-i 写入到文件
-r 使用扩展正则
指令
p 输出文档内容
d 删除
s 替换
sed -n 'p'  user   //使用sed输出user文档中所有行
sed -n '1p' user   //使用sed输出user文档中第1行
sed -n '1,3p' user   //使用sed输出user文档中第1行到第3行
sed -n '1,+3p' user  //输出user文档中第1行以及后面的3行
sed -n '1p;4p' user  //输出第1行和第4行
sed -n '1~2p' user  //输出奇数行
sed -n '2~2p' user  //输出偶数行
使用正则做定址符
sed -n '/root/p' /etc/passwd    //指令前面添加2个斜杠,中间使用正则,查找有root单词的行
sed -n '/bash$/p' /etc/passwd
sed -rn '/bash|nologin/p' user  //竖线"|" 是扩展正则,要加-r选项
sed -n '=' user   //显示行号
sed -n '$=' user   //显示最后一行的行号
sed  'd'  user   //使用sed删除user文档中所有行
sed  '1d' user   //使用sed删除user文档中第1行
sed  '1,3d' user   //使用sed删除user文档中第1行到第3行
sed  '1,+3d' user  //使用sed删除user文档中第1行以及后面3行

替换:
s/旧内容/新内容/ 或者 s$旧内容$新内容$  等符号
sed 's/2017/AAAA/' test.txt   //替换所有行的第1个2017为AAAA
sed 's/2017/AAAA/g' test.txt  //替换所有行的所有2017为AAAA
sed 's/2017/AAAA/2' test.txt  //替换所有行的第2个2017为AAAA
sed '1s/2017/AAAA/' test.txt  //替换第1行的第1个2017为AAAA
sed '2s/2017/AAAA/2' test.txt  //替换第2行的第2个2017为AAAA
sed '3s/2017/AAAA/3;3s/2017/AAAA/2;' test.txt   //替换第3行的第3个, 然后在替换第3行的第2个
sed '3s/2017/AAAA/2;3s/2017/AAAA/2;' test.txt   //效果同上

如何将 /bin/bash 替换为 /sbin/sh
sed 's#/bin/bash#/sbin/sh#' user

\(\)
()
保留=复制          \1   \2   \3


sed 's/.//2 ; s/.$//' nssw.txt    //利用替换功能,删除文档中每行的第2个字符和最后一个字符
sed -r 's/^(.)(.*)(.)$/\3\2\1/' nssw.txt   //将每行的首个字符和最后一个字符互换,首先利用^(.)复制行首字符,定义为\1 , 然后复制行尾字符 (.)$ ,定义为\3   ,中间的字符无论多少都使用(.*)涵盖,定义为\2, 然后根据需求粘贴.

sed -r 's/^(.)(.)(.)(.)$/\4\3\2\1/'  aa    //aa文档中有abcd,将abcd 换成  dcba  

sed 's/[0-9]//g' nssw.txt     //删除所有数字
sed -r 's/([A-Z])/[\1]/g' nssw.txt   //将所有大写字母添加中括号
  
编写一键部署ftp服务的脚本,要求ftp具备匿名上传功能
vim /etc/vsftpd/vsftpd.conf
#anon_upload_enable=YES
#anon_mkdir_write_enable=YES
sed 's/^#anon_/anon_/'


#!/bin/bash
yum -y install vsftpd  &> /dev/null
sed -i 's/^#anon_/anon_/'  /etc/vsftpd/vsftpd.conf
systemctl restart vsftpd
systemctl enable vsftpd
systemctl stop firewalld
setenforce 0
chmod o+w /var/ftp/pub 
虚拟机执行脚本后,使用真机访问虚拟机的ftp,可以在pub目录中成功上传文件即可,关闭防火墙为了测试此脚本,生产环境中不可关闭

#############################################################

前置指令 | sed 选项  (定址符)指令
sed 选项  (定址符)指令    文件
-n    -r    -i
/ /p    2d     3s

a行后追加     i行前插入    c替换整行

sed '1a AAAA'  user   //在第1行的后面追加AAAA
sed '/^bin/a AAAA'  user   //在以bin开头的行的后面追加AAAA
sed '1i AAAA'  user   //在第1行的前面追加AAAA
sed '/^bin/i AAAA'  user   //在以bin开头的行的前面追加AAAA
sed '1c AAAA'  user   //把第1行替换成AAAA
sed '/^bin/c AAAA'  user   //把bin开头的行替换成AAAA
sed '$a 1.1.1.1 www.baidu.com'  /etc/hosts   //在hosts文件的最后一行后面追加ip地址与域名


sed  修改,查找 文件 
awk  查找输出文件的内容 

awk使用方式: 
1,   前置命令 | awk 选项  条件{指令} 
2, awk 选项  条件{指令}   文件

指令 :   print  $1  $2  $3
选项 :    -F  分隔符

awk '{print $1}'  nssa   //在nssa文件中查找所有行的第1列并输出
awk '{print}'  nssa  //输出文档所有内容
awk -F: '{print $6}'  /etc/passwd  //以冒号做分隔符,输出第6列,相当于显示所有用户的家目录

提取网卡流量:
ifconfig eth0 | sed -rn '/RX p|TX p/p' | awk -F[\(\)] '{print $2}'     //首先使用前置命令查看eth0网卡所有信息, 然后使用sed过滤显示有RX p(接收的流量)和TX p(发送的流量)的行, 最后使用awk 定义小括号为分隔符 ,并输出第2列

ifconfig eth0 | awk -F[\(\)] '/RX p|TX p/{print $2}'  //awk也支持正则, 效果同上

awk支持常量输出,放在双引号中间即可
df -h | awk '/vda1/{print "当前主机根分区剩余空间是"$4}'  //配合常量输出

awk '/Failed/{print "登录本机失败的IP地址",$11}' /var/log/secure    //在安全日志文件中利用awk筛选出访问本机失败的ip,可加逗号做空格

awk的内置变量: 
$0显示所有      $1 $2 $3...      NR显示行号    NF显示列号

awk处理的时机: 相当于逐行任务之外的任务
BEGIN{print  }    //在逐行任务之前添加任务,执行1次
{print}			 //逐行任务,执行n次
END{print }		//在逐行任务之后添加任务,执行1次

awk 'BEGIN{print "早上好"}{print}END{print "再见"}' nssw 

awk '{print}END{print NR}' nssw   //显示所有内容,以及最后一行的行号

awk -F: 'BEGIN{print "User\tUid\tHome"}{print  $1"\t"$3"\t"$6}END{print "总计" NR "行"}' user     //使用awk处理时机,输出表头,内容,和结尾

awk  'BEGIN{x=0}{x++}END{print x}'  user

awk处理条件:
1,使用正则
awk -F: '/root/{print}'  /etc/passwd  //输入有root的行
awk -F: '$1~/root/{print}'  /etc/passwd  //输入第一列包含root的行
awk -F: '$1!~/root/{print}'  /etc/passwd  //输入第一列不包含root的行

2,使用字符或数字做条件,可以配合符号 ==  !=   >   <    >=   <=
awk -F: '$1=="root"{print}' user   //找第1列是root的行
awk -F: 'NR==1{print}' user    //找第一行
awk -F: '$3>=1000{print $1,$3}'  /etc/passwd   //找第3列大于等于1000的行,并输出第1列与第3列
awk -F: '$3<10{print $1,$3}'  /etc/passwd   //找第3列小于10的行,并输出第1列与第3列
awk -F: '$3==10{print $1,$3}'  /etc/passwd  //找第3列等于10的行,找不到则无任何显示

3,使用逻辑符号    && 且     || 或

awk -F: '$3>10 && $3<20{print}' /etc/passwd    //找第3列大于10并且第3列小于20的行,  {print}可以省略不写
awk -F: '$1=="root" ||$1=="bin"{print}' /etc/passwd   //找第1列是root或是bin的行
awk -F: '$1=="rootabc" ||$1=="bin"{print}' /etc/passwd  //找第1列是rootabc或是bin的行
awk -F: '$1=="root" && $1=="bin"{print}' /etc/passwd  //找第1列既是root又是bin的行,逻辑错误,找不到
awk -F: '$3>100 && $3<10{print}' /etc/passwd   //逻辑错误找不到
awk -F: '$3>10 || $3<1000print}' /etc/passwd  //找所有行

4,运算
awk 'BEGIN{print 1+1}'
awk 'BEGIN{print 1.1+1.1}'
awk 'BEGIN{print 2*2}'
awk 'BEGIN{print 2/2}'
awk 'BEGIN{print 2%2}'
awk 'BEGIN{x=2;y=5;print x+y}'

列出UID间于1~1000的用户详细信息
输出/etc/hosts映射文件内以127或者192开头的记录
列出100以内整数中7的倍数或是含7的数
seq 100 | awk '$1%7==0 || $1~/7/'
方法一:
#/bin/bash
A=$(awk -F:  '/bash$/{print $1}' /etc/passwd)	
for i in $A
do
		grep $i /etc/shadow | awk -F: '{print $1,"-->",$2}'				
done

方法二:
#!/bin/bash
u=`awk -F: '/bash$/{print $1}' /etc/passwd`
for i in $u
do
        awk -F: -v a=$i '$1==a{print $1,"-->" ,$2}' /etc/shadow
done

##########################################################################

awk  选项             条件                                                  指令
   -F -v	正则,字符和数字,逻辑符号&& ||,运算	      {print $1 $2}
变量只可以存储一个值,再次赋值时,上一个值会被覆盖
a=10
a=20
数组可以利用多个下标,仅仅使用一个数组名存储多个值
数组名[下标]=值
a[0]=10
a[1]=20
awk 'BEGIN{a[0]=10;a[1]=20;print a[1],a[0]}'    //首先定义1个数组,名称a,再定义多个下标对应的值, 然后输出
awk 'BEGIN{a[0]="a";a[1]="b";print a[1],a[0]}'  //除了数字,还可以使用字符,注意要使用双引号
awk 'BEGIN{a["abc"]=10;a["xyz"]=20;print a["abc"],a["xyz"]}'

awk 'BEGIN{a[0]++;a[1]++;a[1]++;print a[0],a[1]}'

awk 'BEGIN{a[0]=0;a[1]=11;a[2]=22; for(i in a){print i,a[i]}}'    //使用awk数组+for循环显示数组的所有内容

首先准备素材: 
abc
abc
xyz
qqq
xyz
abc

awk '{cba[$1]++}END{for(i in cba){print cba[i],i}}' abc
			//使用数组+for循环, 输出该文档中每行的第1列是什么内容,出现了几次. 首先定义数组名为cba,下标是每行的第1列, 然后执行++运算,逐行执行,都执行完后得到结果:
cba[abc]=3
cba[xyz]=2
cba[qqq]=1
然后这个结果再交给for循环处理,循环显示的变量i是下标.

ip[192.168.0.2]=3
ip[192.168.0.1]=2
ip[172.25.0.1]=1
ip[8.8.8.8]=1

awk '{ip[$1]++}END{for(i in ip){print i,ip[i]}}'  abc  | sort -rk 2     //将最后处理的结果交给sort排序, -k是定义按照哪列排序, -r是降序排列

netstat -ntulp | grep :80

使用awk统计网站访问者的ip与点击量
1,安装httpd与测试工具
   yum -y install httpd elinks
2,开启httpd服务
3,使用测试工具访问本机网站
   elinks -dump 127.0.0.1
4,查看httpd访问量日志
   vim /var/log/httpd/access_log
    再使用其他主机访问此http服务(注意关闭防火墙),再次查看日志发现增加了新记录
5,使用awk查看最终结果
awk '{ip[$1]++}END{for(i in ip){print ip[i],i}}'  /var/log/httpd/access_log  | sort -r 
6,可以配合脚本增加访问次数再次检测
#!/bin/bash
for i in {1..5000}
do
	elinks -dump 172.25.0.10 &> /dev/null
done




编写监控脚本,可以方便查看主机的若干参数

#!/bin/bash
while :
do
uptime |awk '{print "cpu平均负载:"$10,$11,$12}'
ifconfig eth0 |awk -F[\(\)] '/RX p/{print "网卡eth0接收的数据量是:"$2}'
ifconfig eth0 |awk -F[\(\)] '/TX p/{print "网卡eth0发送的数据量是:"$2}'
free -m | awk '/^Mem:/{print "主机剩余内存容量是:"$4"m"}'
df -h | awk '/vda1/{print "磁盘剩余空间是:"$4}'
u=`cat /etc/passwd | wc -l`
echo "计算机账户数量是:$u"
user=`who | wc -l`
echo "当前登录的用户数量是:$user"
p=`ps -aux | wc -l`
echo "目前开启的进程数量是:$p"
r=`rpm -qa | wc -l`
echo "目前安装的软件包数量是:$r"
sleep 2
clear
done

使用awk找出安全日志中对本机访问失败的ip记录与次数统计
awk '/Failed/{ip[$11]++}END{for(i in ip){print ip[i],i}}' /var/log/secure


#!/bin/bash
abc=`awk '/Failed/{ip[$11]++}END{for(i in ip){print ip[i]","i}}' /var/log/secure`
for i in $abc
do
	aa=${i%,*}
	bb=${i#*,}
	[ $aa -ge 10 ] && echo "$bb猜错10次以上密码了,赶紧收拾他" | mail -s test root
done

\w   匹配数字字母下划线  a-z  A-Z  0-9
\W   取反
grep "\w"  aaaa   //在aaaa文件中找所有的数字字母下划线
\s   各种空白,如空格,tab制表符等
\S	 取反

开子shell与不开子shell的区别就在于，环境变量的继承关系，如在子shell中设置的当前变量，不做特殊通道处理的话，父shell是不可见的。
而在当前shell中执行的话，则所有设置的环境变量都是直接生效可用的。

ftp
/etc/vsftpd/vsftpd.conf
第二十九行 匿名上传功能开关



一级提示符

\u@\h \W]\$
[root@server0 ~]#
二级提示符
>



echo $0                  //脚本的名称
echo $1                  //第一个参数
echo $2                  //第二个参数
echo $*                  //所有参数
echo $#                  //所有的综合
echo $$                  //当前进程的进程号
echo $?                  //上一个程序的返回状态码

-z 判断变量空位真 
! -z 判断变量有值真

wc -l #查看行数


[ -n $a ]    当a没赋值是等于     [  -n ]

正确输入:  [  -n "$a" ]
vim /etc/vimrc
set ts=4 //ts是tabstop
netstat -ntlup  | grep nginx #差看服务状态

uptime 查看CPU负载
ifconfig eht0 查看网卡流量
free (默认单位KB) -m(单位M)  查看内存空间
df -h   查看磁盘空间
who | wc -l 当前登录的用户数量
cat /etc/passwd | wc -l  查看所有用户数量
ps | wc -l  查看当前的进程数量
rpm -qa | wc -l 查看已经安装的软件包数量

\b  边界
\w  匹配数字字母下划线  a-z A-Z 0-9
\W  不匹配数字字母下划线  a-z A-Z 0-9
\s  各种空白,如空格,tab制表符
\S  取反各种空白,如空格,tab制表符

定义函数之后可以多线程进行

man 软件包名 查找主配置文件

cp  -p  #保留文件原属性不变  

[root@server0 ~]# ls /boot/vmlinuz-*   #查看内核文件
/boot/vmlinuz-0-rescue-946cb0e817ea4adb916183df8c4fc817
/boot/vmlinuz-3.10.0-123.1.2.el7.x86_64
/boot/vmlinuz-3.10.0-123.el7.x86_64

root@server0 ~]# yum-config-manager --add http://content.example.com/rhel7.0/x86_64/dvd
[root@server0 ~]# vim /etc/yum.conf

sealert #查看SElinux警告日志


Linux chattr命令用于改变文件属性。
这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：
a：让文件或目录仅供附加用途。
b：不更新文件或目录的最后存取时间。
c：将文件或目录压缩后存放。
d：将文件或目录排除在倾倒操作之外。
i：不得任意更动文件或目录。
s：保密性删除文件或目录。
S：即时更新文件或目录。
u：预防意外删除。
语法
chattr [-RV][-v<版本编号>][+/-/=<属性>][文件或目录...]
参数
　　-R 递归处理，将指定目录下的所有文件及子目录一并处理。
　　-v<版本编号> 设置文件或目录版本。
　　-V 显示指令执行过程。
　　+<属性> 开启文件或目录的该项属性。
　　-<属性> 关闭文件或目录的该项属性。
　　=<属性> 指定文件或目录的该项属性。
实例
用chattr命令防止系统中某个关键文件被修改：
chattr +i /etc/resolv.conf
lsattr /etc/resolv.conf
会显示如下属性
----i-------- /etc/resolv.conf
让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件：
chattr +a /var/log/messages


达内教学环境公钥
 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCv3uPUOnpaaE9/l5jkUEp5K3ZsP3    dgrRfkJur5UkmPvgGoz4UGV4vd2Dna1R6En2mmTDEwFyqmpJs59Hgfw8rTF8EbDRep    J7N4+mm3sUYnFy9BJgafJkK84ZdQ1yA/A64LzVg02PwHqmSO5eLnAtWmeToIlDvyow    aZou6YJqSdYflJDTu6793PshxhwdTFyK1NqIS4mfHHpWgm/oObXRCmqbvB4EiACuas    vXN46JKTpa0COezdjUKDmyVspSMFdN7jpEuWZPMPSnOyv/FDSYjEbqoZpiIQMSRBVD    bNsz7E+mViP1yDi5nJ/9nmbIZLgbykEU0gEOAxKSZXvjbDXn2p root@weekend9pc    01.tedu.cn

###########################################################################################
******************************************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////////////////


Web 服务器:httpd  nginx  lighttpd         #php,Python语言
	    tomcat\weblogic\websphere     #java语言    
常用 :  nginx   (功能最全)
  	tomcat  (免费)

niginx  -->优化---> 淘宝  Tengine(配置文件:nginx.conf)
是俄罗斯人编写,高性能http和反向代理服务器
同时是一个IMAP POP3 SMTP代理服务器
官网:http://nginx.org


权限都是针对账户rwx
admin   a.txt
程序QQ{发送文件}
谁运行的这个程序 root,admin ---> QQ
nginx ---> nginx[面向全网提供服务]
		/etc/passwd /etc/shadow
如root启用这个nginx, 那么nginx则有root权限
若nginx有漏洞, 则可以通过漏洞得root权限
输入命令是root执行命令,以普通用户的身份启动
 
安装nginx-1.10.3版本时，需要使用如下参数：
--with-http_ssl_module：提供SSL加密功能    --with=,模块指定  --without-名称
--user：指定账户
--group：指定组

现代化软件都是模块化设计
软件公司:100个功能
	打包:100个功能全部打包
	模块化(默认模块): 软件模块化分为100个功能,看需求,不指定模块执行默认模块

步骤一：构建Nginx服务器
使用源码包安装nginx软件包nginx的rewrite伪静态匹配规则用到正则，pcre就用来干这个。
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包                                                           (加密依赖包)
[root@proxy ~]# useradd -s /sbin/nologin nginx
[root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
[root@proxy ~]# cd  nginx-1.10.3
[root@proxy nginx-1.10.3]# ./configure   \
> --prefix=/usr/local/nginx   \                //指定安装路径
> --user=nginx   \                            //指定用户
> --group=nginx  \                            //指定组
> --with-http_ssl_module                        //开启SSL加密功能
[root@proxy nginx-1.10.3]# make && make install    //编译并安装

-devel后缀 源码编译包

2）nginx命令的用法
[root@proxy ~]# /usr/local/nginx/sbin/nginx                    //启动服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            //关闭服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx                    //启动服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        //重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看软件信息
[root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/        //方便后期使用

netstat 
netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）

1.旧版本有问题
2.模块(默认20模块, 没法单独添加模块需要升级)
 nginx1.10.3 ---> nginx1.12.2

/usr/local/nginx/conf 配置文件
/usr/local/nginx/html 网页文件
/usr/local/nginx/conf 日志文件
/usr/local/nginx/sbin 程序

备份(防止出现错误或继续使用老版本)
mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginxold


步骤二：升级Nginx服务器



1）编译新版本nginx软件
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --prefix=/usr/local/nginx   \ 
> --user=nginx   \ 
> --group=nginx  \ 
> --with-http_ssl_module
[root@proxy nginx-1.12.2]# make            

2) 备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
[root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  \
>/usr/local/nginx/sbin/nginxold
[root@proxy nginx-1.12.2]# cp objs/nginx  /usr/local/nginx/sbin/         //拷贝新版本
[root@proxy nginx-1.12.2]# make upgrade                            //升级  (经常出错杀不死  程序本身问题)
#或者使用killall nginx杀死进程后再启动nginx。
/usr/local/nginx/sbin/nginx -t
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
sleep 1
test -f /usr/local/nginx/logs/nginx.pid.oldbin
kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
[root@proxy ~]# /usr/local/nginx/sbin/nginx –v                //查看版本


步骤三：客户端访问测试

1）分别使用浏览器和命令行工具curl测试服务器页面
如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。
[root@client ~]# firefox http://192.168.4.5
[root@client ~]# curl http://192.168.4.5

**************************************************************************************************

2：用户认证

步骤一：修改Nginx配置文件

1）修改/usr/local/nginx/conf/nginx.conf
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;          //相当于httpd里的servername   服务域名
        auth_basic "Input Password:";    //认证提示符信息 需要认证时添加
        auth_basic_user_file "/usr/local/nginx/pass";   //认证的密码文件 需要认证时添加
        location / {
           root   html;  //相当于httpd里的ducumentroot #相对路径  网页读取路径 /usr/local/nginx/html
            index  index.html index.htm;    #index 设置默认首页 从左往右匹配
        }
  }



2）生成密码文件，创建用户及密码
使用htpasswd命令创建账户文件，需要确保系统中已经安装了httpd-tools。
[root@proxy ~]# yum -y install  httpd-tools
[root@proxy ~]# htpasswd -c /usr/local/nginx/pass   tom        //创建密码文件
New password: 
Re-type new password: 
Adding password for user tom
[root@proxy ~]# htpasswd  /usr/local/nginx/pass   jerry      //追加用户，不使用-c选项
New password: 
Re-type new password: 
Adding password for user jerry
[root@proxy ~]# cat /usr/local/nginx/pass

虚拟主机:基于域名 基于IP 基于端口
用一台主机一个软件,实现很多个网站



3）重启Nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload    //重新加载配置文件    
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directo



步骤二：客户端测试

1）登录192.168.4.10客户端主机进行测试
如果使用firefox火狐浏览器，注意在ssh远程的时候一定要加-X选项。
或者直接使用真实主机的火狐也可以。
[root@client ~]# firefox http://192.168.4.5                    //输入密码后可以访问
***************************************************************************************************

虚拟主机:基于域名 基于IP 基于端口
用一台主机一个软件,实现很多个网站



步骤一：修改配置文件

1）修改Nginx服务配置，添加相关虚拟主机配置如下
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;                                      //端口
        server_name  www.a.com;                                //域名
auth_basic "Input Password:";                        //认证提示符
        auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
location / {
            root   html;                                    //指定网站根路径
            index  index.html index.htm;
       }
       
}
… …
    server {
        listen  80;                                        //端口
        server_name  www.b.com;                                //域名
	 charset utf-8;				#使用的编码解释
location / { 
root   www;                                 //指定网站根路径
index  index.html index.htm;
}
}

2）创建网站根目录及对应首页文件
[root@proxy ~]# mkdir /usr/local/nginx/www
[root@proxy ~]# echo "www" > /usr/local/nginx/www/index.html

3）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
步骤二：客户端测试

1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
 [root@client ~]# vim /etc/hosts
192.168.4.5    www.a.com  www.b.com

2）登录192.168.4.10客户端主机进行测试
注意：请先关闭真实机的firefox，再SSH -X远程连接调用虚拟机的firefox。
[root@client ~]# firefox http://www.a.com            //输入密码后可以访问
[root@client ~]# firefox http://www.b.com            //直接访问
提示：或者直接使用真实主机做客户端主机验证，修改真实主机的/etc/hosts文件，直接使用真实主机的火狐浏览器访问也可以。
步骤三：扩展课外实验：其他类型的虚拟主机

1.基于端口的虚拟主机（参考模板）
server {
        listen       8080;                        //端口
        server_name  web1.example.com;          //域名
        ......
}
    server {
        listen       8000;                         //端口
        server_name  web1.example.com;           //域名
      .......
}
2.基于IP的虚拟主机（参考模板）
server {
        listen       192.168.0.1:80;              //IP地址与端口
        server_name  web1.example.com;          //域名
  ... ...
}
    server {
        listen       192.168.0.2:80;             //IP地址与端口
        server_name  web1.example.com;
... ...
}

****************************************************************************************
变量 $OLDPWD 上一次所在的目录  echo $OLDPWD 输出上一次所在的目录  差点 cd $OLDPWD 进入上一次所在的目录
###############################################################################
1.源码安装
2.用户认证
3.虚拟主机

http协议是明文协议
		tom,123456
client--------------------server

http+ssl=https(秘钥)

源码安装Nginx时必须使用--with-http_ssl_module参数，启用加密模块，对于需要进行SSL加密处理的站点添加ssl相关指令（设置网站需要的私钥和证书）。
加密算法一般分为对称算法、非对称算法、信息摘要。
对称算法有：AES、DES，主要应用在单机数据加密。
非对称算法有：RSA、DSA，主要应用在网络数据加密。
信息摘要：MD5、sha256，主要应用在数据完整性校验。

对称加密:
	123-----123
非对称加密: (加密的密码叫公钥,解密的秘钥叫私钥 私钥也叫证书)   
	123---s8.
信息摘要:(命令:md5sum 文件) 用来数据的校验 内容不变,值不变 

对称加密算法适用于双方都知道密码的小范围人群

互联网上主要的加密方式都是非对称算法

信息摘要可以检验自己的文件有没有被人修改(主要应用在配置文件) 可以写一个脚本,先备份一份,有序要可以用来校验

#!/bin/bash
for i in `ls /etc/*.conf`
do 
	md5sum $i >>  bak.log
done
#########################################################################################

ASCII编码  英文   0-127   后来所有的编码都是在ASCII基础上编的,所以英文出不了乱码
GB2312编码   中文   
apple    联合了十几家公司  制定了unicode(utf-8)编码(万国编码,包含了很多国家的编码)

server {
        listen       80;
        server_name  www.d.com;
        charset uft-8;       #选择用那个编码     
        location / {
            root   www;
            index  index.html index.htm;
        }
    }


*fonts* 大部分国家字体(包含中文)二进制编译软件包,软件比较大400多个包,不建议在虚拟机装yum安装包

###################################################################################
所有浏览器都不支持个人生成的证书(公私钥) 与利益有关 加密网页可以找与浏览器有合作的公司

1）生成私钥与证书
[root@proxy ~]# cd /usr/local/nginx/conf                //进入目录再生成 
]# openssl genrsa > cert.key                            //生成私钥 文件名可以根据自己更改 和配置文件要一致
          (req请求)     (-x509固定格式) 
]# openssl req -new -x509 -key cert.key > cert.pem      //生成证书 文件名可以根据自己更改 和配置文件要一致

Country Name (2 letter code) [XX]:CN		
#国名(2个字母代码)
State or Province Name (full name) []:NB	
#省/市/自治区名称（全名）
Locality Name (eg, city) [Default City]:SH
#地点名称（例如，城市）[默认城市]
Organization Name (eg, company) [Default Company Ltd]:NN
#组织名称（例如，公司）[默认公司有限公司]
Organizational Unit Name (eg, section) []:mk
#组织单位名称（例如，部门）
Common Name (eg, your name or your server's hostname) []:asd
#公用名（例如，您的名称或服务器的主机名）
Email Address []:q@163.com		#邮箱


2）修改Nginx配置文件，设置加密网站的虚拟主机
/usr/local/nginx/conf/cert.key  #私钥的文件路径
/usr/local/nginx/conf/cert.pem  #公钥的文件路径

[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
… …    
server {
        listen       443 ssl;
        server_name            www.c.com;
        ssl_certificate      cert.pem;         #这里是证书文件
        ssl_certificate_key  cert.key;         #这里是私钥文件
        ssl_session_cache    shared:SSL:1m;    #
        ssl_session_timeout  5m;               #等待时长
        ssl_ciphers  HIGH:!aNULL:!MD5;         #不允许没有密码和MD5加密方式
        ssl_prefer_server_ciphers  on;         #
        location / {
            root   html;
            index  index.html index.htm;
        }
    }
3）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

步骤二：客户端验证
1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
[root@client ~]# vim /etc/hosts
192.168.4.5    www.c.com  www.a.com   www.b.com
2）登录192.168.4.10客户端主机进行测试
[root@client ~]# firefox https://www.c.com            //信任证书后可以访问


###############################################################################3
部署LNMP环境
LNMP  (linux+nginx+mysql+php(Python)),
LAMP  (linux+(http)Apache+mysql+php(Python))
静态
动态 
	web:/var/www/htm/文件
	    /usr/local/nginx/html/网页文件
需要的软件包:
nginx
mariadb、mariadb-server、mariadb-devel  不可能用一个文档保存, 太大会打不开,不安全
php、php-fpm、php-mysql

备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。

sicket:进程管理器 

1）使用yum安装基础依赖包
[root@proxy ~]# yum -y install gcc openssl-devel pcre-devel

2）源码安装Nginx（如果前面课程中已经安装Nginx，则忽略这一步）
[root@proxy ~]# useradd -s /sbin/nologin  nginx
[root@proxy ~]# tar -xvf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --user=nginx   --group=nginx \
> --with-http_ssl_module
[root@proxy ~]# make && make install
.. ..

3）安装MariaDB
Mariadb在新版RHEL7光盘中包含有该软件，配置yum源后可以直接使用yum安装：
[root@proxy ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
4）php和php-fpm
[root@proxy ~]# yum -y  install  php   php-mysql
[root@proxy ~]# yum -y  install php-fpm



步骤二：启动服务

1）启动Nginx服务（如果已经启动nginx，则可以忽略这一步）
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@proxy ~]# systemctl stop httpd                //如果该服务存在则关闭该服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx             //启动Nginx服务
[root@proxy ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         

2）启动MySQL服务
[root@proxy ~]# systemctl start  mariadb           //启动服务器
[root@proxy ~]# systemctl status mariadb           //查看服务状态
[root@proxy ~]# systemctl enable mariadb           //设置开机启动

3）启动PHP-FPM服务
[root@proxy ~]# systemctl start php-fpm           //启动服务
[root@proxy ~]# systemctl status php-fpm          //查看服务状态
[root@proxy ~]# systemctl enable php-fpm          //设置开机启动
 
net -ntlaup | grep ....    #查看服务端口
mysql服务端口:3306
php-fpm服务端口:9000

实现动静分离(nginx.conf),做判断
静态数据可以直接给用户
动态脚本应该在服务器上执行脚本后给用户
如果用户访问的是静态文件,则直接返回
如果用户访问的是PHP脚本,则把脚本转发给9000端口

location语句是匹配用户的地址栏(从域名后面开始)
location支持正则  ~:正则比较匹配
没有~则精确匹配

location / {
	allow 1.1.1.1;		#运行1.1.1.1
	deny all;			#禁止所有
	找文件,直接返回;
}
location ~ \.php$ {
	找文件,转发给9000;
}

PHP是多进程的软件
程序program:(静态的代码  占用磁盘空间)
进程procese:(动态执行的代码  占用CPU  内存)
多进程:一个程序同时多个进行 比如浏览器多开
线程:通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。
多线程:在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。

最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也不可能只有一节车厢。多线程的出现就是为了提高效率。


线程共享一个进程,优点:节省内存 缺点:进程崩了,线程也崩了
程序
    -进程(20M)
	-线程
	-线程
	-线程
    -进程(20M)
	-线程
	-线程
	-线程

for i in {1..10}
do 
ping -c 1 192.168.4.$1  & (放进后台多线程执行)
done

步骤一： php-fpm配置文件

1）查看php-fpm配置文件（实验中不需要修改该文件）
[root@proxy etc]# vim /etc/php-fpm.d/www.conf
[www]
listen = 127.0.0.1:9000            //PHP端口号
pm.max_children = 32                //最大进程数量
pm.start_servers = 15                //最小进程数量
pm.min_spare_servers = 5            //最少需要几个空闲着的进程
pm.max_spare_servers = 32            //最多允许几个进程处于空闲状态

步骤二：修改Nginx配置文件并启动服务

[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
#设置默认首页为index.php，当用户在浏览器地址栏中只写域名或IP，不说访问什么页面时，服务器会把默认首页index.php返回给用户
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;    #将请求转发给本机9000端口，PHP解释器
            fastcgi_index  index.php;
            #fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;       #加载其他配置文件
        }
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

fastcgi.conf:特指nginx的变量定义



步骤三：创建PHP页面，测试LNMP架构能否解析PHP页面

1）创建PHP测试页面1，可以参考lnmp_soft/php_scripts/test.php：
[root@proxy ~]# vim /usr/local/nginx/html/test.php
<?php
$i="This is a test Page";
echo $i;
?>

2）创建PHP测试页面,连接并查询MariaDB数据库。
可以参考lnmp_soft/php_scripts/mysql.php:
[root@proxy ~]# vim /usr/local/nginx/html/mysql.php
<?php
$mysqli = new mysqli('localhost','root','密码','mysql');
//注意：root为mysql数据库的账户名称，密码需要修改为实际mysql密码，无密码则留空即可
//localhost是数据库的域名或IP，mysql是数据库的名称
if (mysqli_connect_errno()){
    die('Unable to connect!'). mysqli_connect_error();
}
$sql = "select * from user";
$result = $mysqli->query($sql);
while($row = $result->fetch_array()){
    printf("Host:%s",$row[0]);
    printf("</br>");
    printf("Name:%s",$row[1]);
    printf("</br>");
}
?>

3）客户端使用浏览器访问服务器PHP首页文档，检验是否成功：
[root@client ~]# firefox http://192.168.4.5/test.php
[root@client ~]# firefox http://192.168.4.5/mysql.php


1.安装软件7个
2.启动服务 nginx,php-fpm,mariadb
3.修改配置location ~ /.php$ {
}
4.nginx -s reload
5.firefox http://www.a.com/test.php

LNMP user---nginx---php(test.php)--mysql


LNMP常见问题
Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
PHP默认错误日志文件为/var/log/php-fpm/www-error.log
如果动态网站访问失败，可用参考错误日志，查找错误信息。
syntax error :语法错误
[root@proxy conf]# tailf /usr/local/nginx/logs/error.log  #动态查看日志
如果php脚本出现错误, 那么打开网页则是空白页

地址重写

步骤一：修改配置文件(访问a.html重定向到b.html)

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html;            
location / {
    root   html;
index  index.html index.htm;
}
}
[root@proxy ~]# echo "BB" > /usr/local/nginx/html/b.html
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
3）客户端测试
[root@client ~]# firefox  http://192.168.4.5/a.html
步骤二：访问a.html重定向到b.html（跳转地址栏）

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html  redirect;            
location / {
    root   html;
index  index.html index.htm;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（仔细观察浏览器地址栏的变化）
[root@client ~]# firefox  http://192.168.4.5/a.html
步骤三：修改配置文件(访问192.168.4.5的请求重定向至www.tmooc.cn)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/  http://www.tmooc.cn/;  #(/代表/usr/local/nginx/html)
location / {
    root   html;
index  index.html index.htm;
# rewrite /a.html  /b.html  redirect;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5

步骤四：修改配置文件(访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite ^/(.*)$  http://www.tmooc.cn/$1;
location / {
    root   html;
index  index.html index.htm;
}
}
2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
[root@room9pc01 ~]# firefox  http://192.168.4.5/test
步骤五：修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
1) 创建网页目录以及对应的页面文件：
[root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
[root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
[root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html
2) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
location / {
    root   html;
index  index.html index.htm;
}

#这里，~符号代表正则匹配，*符号代表不区分大小写
if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
rewrite ^(.*)$  /firefox/$1;
}
}
3）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
4）客户端测试
[root@client ~]# firefox  http://192.168.4.5/test.html
[root@client ~]# curl     http://192.168.4.5/test.html


5）地址重写格式【总结】
rewrite 旧地址 新地址 [选项];
选项:
last 不再读其他rewrite
break 不再读其他语句，结束请求
redirect 临时重定向
permament 永久重定向

rewrite /旧地址   /新地址   #旧地址支持正则表达
#########################################################################

HTTP状态码分类
分类	分类描述
1**	信息，服务器收到请求，需要请求者继续执行操作
2**	成功，操作被成功接收并处理
3**	重定向，需要进一步的操作以完成请求
4**	客户端错误，请求包含语法错误或无法完成请求
5**	服务器错误，服务器在处理请求的过程中发生了错误
重点内容:
HTTP 400 - 请求无效 
HTTP 401.1 - 未授权：登录失败 
HTTP 401.2 - 未授权：服务器配置问题导致登录失败 
HTTP 401.3 - ACL 禁止访问资源 
HTTP 401.4 - 未授权：授权被筛选器拒绝 
HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败 
HTTP 403 - 禁止访问 
HTTP 403 - 对 Internet 服务管理器 的访问仅限于 Localhost 
HTTP 403.1 禁止访问：禁止可执行访问 
HTTP 403.2 - 禁止访问：禁止读访问 
HTTP 403.3 - 禁止访问：禁止写访问 
HTTP 403.4 - 禁止访问：要求 SSL 
HTTP 403.5 - 禁止访问：要求 SSL 128 
HTTP 403.6 - 禁止访问：IP 地址被拒绝 
HTTP 403.7 - 禁止访问：要求客户证书 
HTTP 403.8 - 禁止访问：禁止站点访问 
HTTP 403.9 - 禁止访问：连接的用户过多 
HTTP 403.10 - 禁止访问：配置无效 
HTTP 403.11 - 禁止访问：密码更改 
HTTP 403.12 - 禁止访问：映射器拒绝访问 
HTTP 403.13 - 禁止访问：客户证书已被吊销 
HTTP 403.15 - 禁止访问：客户访问许可过多 
HTTP 403.16 - 禁止访问：客户证书不可信或者无效 
HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 
HTTP 404.1 -无法找到 Web 站点 
HTTP 404- 无法找到文件 
HTTP 405 - 资源被禁止 
HTTP 406 - 无法接受 
HTTP 407 - 要求代理身份验证 
HTTP 410 - 永远不可用 
HTTP 412 - 先决条件失败 
HTTP 414 - 请求 - URI 太长 
HTTP 500 - 内部服务器错误 
HTTP 500.100 - 内部服务器错误 - ASP 错误 
HTTP 500-11 服务器关闭 
HTTP 500-12 应用程序重新启动 
HTTP 500-13 - 服务器太忙 
HTTP 500-14 - 应用程序无效 
HTTP 500-15 - 不允许请求 global.asaError 501 - 未实现 
HTTP 502 - 网关错误 
###################################################################################


LNMP动态网站
	nginx
	mariadb mariadb-server maridb-devel 
	php php php-fpm php-mysql
	nginx:80
	mariadb:3306
	php-fpm:9000
nginx实现动静分离
	如果用户访问的是静态数据,则nginx直接返回
	如果用户访问的是PHP脚本,则把脚本转发给9000端口
URL:地址栏,全球唯一定位标识
URI:IMS用户的身份标识
user---nginx---PHP(执行脚本)---mariadb

#!/bin/bash
vim test.sh
read -p "请输入搜索内容" wd
mysqli(ip,root,pass,数据库)

访问192.168.4.5/子页面,调整到www.tomooc.cn.相同页面
rewrite /(.*) httpd://www/tmooc.cn/$1;    #$1相当于粘贴了(.*)  #正则表达()保留  

不同的浏览器访问相同的页面返回的结果不同
1.让开发设计两套页面(手机电脑curl,firefox)
www.sina.com.cn
ie www.sina.com.cn
uc www.sina.com.cn

修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
#这里，~符号代表正则匹配，*符号代表不区分大小写
if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
rewrite ^(.*)$  /firefox/$1;
}

/usr/local/nginx/conf/nginx.cong
192.168.4.254 - - [17/Jun/2019:11:30:50 +0800] "GET / HTTP/1.1" 302 161 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"

$remote_addr       :与$http_x_forwarded_for 用以记录客户端的ip地址；  
 $remote_user      ：用来记录客户端用户名称；  
 $time_local       ：用来记录访问时间与时区；    
 $request          ：用来记录请求的url与http协议；  
 $status           ：用来记录请求状态；成功是200，  
 $body_bytes_sent  ：记录发送给客户端文件主体内容大小；  
 $request_body     :请求体  
 $http_referer     ：用来记录从那个页面链接访问过来的；  
 $http_user_agent  ：记录客户浏览器的相关信息；

参数                           说明                                            示例
$remote_addr             客户端地址                                    211.28.65.253
$remote_user             客户端用户名称                                --
$time_local              访问时间和时区                                18/Jul/2012:17:00:01 +0800
$request                 请求的URI和HTTP协议                           "GET /article-10000.html HTTP/1.1"
$http_host               请求地址，即浏览器中你输入的地址（IP或域名）     www.wang.com 192.168.100.100
$status                  HTTP请求状态                                  200
$upstream_status         upstream状态                                  200
$body_bytes_sent         发送给客户端文件内容大小                        1547
$http_referer            url跳转来源                                   https://www.baidu.com/
$http_user_agent         用户终端浏览器等信息                           "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;
$ssl_protocol            SSL协议版本                                   TLSv1
$ssl_cipher              交换数据中的算法                               RC4-SHA
$upstream_addr           后台upstream的地址，即真正提供服务的主机地址     10.10.10.100:80
$request_time            整个请求的总时间                               0.205
$upstream_response_time  请求过程中，upstream响应时间                    0.002

####################################################################################################################

nginx 可以做web服务器 也可以做代理服务器
功能:
调度器(轮询) 调度多个服务器,使服务器们负载均衡,提高并发量
健康检查 当一台服务器坏了, 会自动让访问去到另一台



搭建nginx反向代理web服务器/web调度器(http协议)
步骤一：部署实施后端Web服务器
1）部署后端Web1服务器
后端Web服务器可以简单使用yum方式安装httpd实现Web服务，为了可以看出后端服务器的不同，可以将两台后端服务器的首页文档内容设置为不同的内容。
[root@web1 ~]# yum  -y  install  httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# setenforce 0
2）部署后端Web2服务器
[root@web2 ~]# yum  -y  install  httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# setenforce 0


步骤二：配置Nginx服务器，添加服务器池，实现反向代理功能
1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
###使用upstream定义后端服务器集群，集群名称任意(如webserver)
###使用server定义集群中的具体服务器和端口
upstream webserver {
                server 192.168.2.100:80;
                server 192.168.2.200:80;
        }
.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
####通过proxy_pass将用户的请求转发给webserver集群
            proxy_pass http://webserver;
        }
}
配置过程中upstream定义的web服务器集群位与http的节点内，与server同级。proxy_pass转发请求位于location节点内
#通过proxy_pass将用户的请求转发给webserver集群
#pass优先级高于根,可以放在server下任意位置


2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
轮询：nginx反向代理时，默认使用轮询的负载均衡策略，当客户机第一次访问时，获得的时web1的页面，第二次访问时获得的时web2的页面，依次类推。



步骤二：配置upstream服务器集群池属性

1）设置失败次数，超时时间，权重
weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                server 192.168.2.101 down;
        }



#weight设置服务器权重值，默认值为1
#max_fails设置最大失败次数
#fail_timeout设置失败超时时间，单位为秒
#down标记服务器已关机，不参与集群调度


.. ..
server {
        listen        80;
        server_name  localhost;
            location / {
            proxy_pass http://webserver;
        }
}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）关闭一台后端服务器（如web1）
[root@web1 ~]# systemctl stop httpd

4）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

5）再次启动后端服务器的httpd（如web1）
[root@web1 ~]# systemctl start httpd

6）客户端再次使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

步骤三：配置upstream服务器集群的调度算法

1）设置相同客户端访问相同Web服务器
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
.. ..
upstream webserver {
#通过ip_hash设置调度规则为：相同客户端访问相同服务器
                 ip_hash;
                server 192.168.2.100 weight=1 max_fails=2 fail_timeout=10;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=10;
        }
.. ..
server {
        listen        80;
        server_name  www.tarena.com;
            location / {
            proxy_pass http://webserver;
        }
}
2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果


Nginx的TCP/UDP调度器
Nginx的TCP/UDP调度器(nginx版本至少1.9以上,默认不开启这个功能,需要开启增需
要开启次模块)

步骤一：部署支持4层TCP/UDP代理的Nginx服务器

1）部署nginx服务器
编译安装必须要使用--with-stream参数开启4层代理模块。
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
[root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                                //开启SSL加密功能
> --with-stream                                       //开启4层反向代理功能
[root@proxy nginx-1.12.2]# make && make install           //编译并安装
步骤二：配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能


1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
stream {
            upstream backend {
               server 192.168.2.100:22;            //后端SSH服务器的IP和端口
               server 192.168.2.200:22;
}
            server {
                listen 12345;                    //Nginx监听的端口
                proxy_connect_timeout 1s;         //连接的超时时间，可选配置
                proxy_timeout 3s;
                 proxy_pass backend;
             }
}
http {
.. ..
}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）客户端使用访问代理服务器测试轮询效果
[root@client ~]# ssh 192.168.4.5 -p 12345            //使用该命令多次访问查看效果

Nginx常见问题处理

如何自定义返回给客户端的404错误页面
如何查看服务器状态信息
如果客户端访问服务器提示“Too many open files”如何解决
如何解决客户端访问头部信息过长的问题
如何让客户端浏览器缓存数据
日志切割
开启gzip压缩功能，提高数据传输效率
开启文件缓存功能

步骤一：自定义报错页面

1）优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面

2）修改Nginx配置文件，自定义报错页面
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
            .. ..
        charset utf-8;                    //仅需要中文时需要改选项，可选项
error_page   404  /404.html;              //自定义错误页面
.. ..
[root@proxy ~]# vim /usr/local/nginx/html/404.html       //生成错误页面或直接拖入照片
Oops,No NO no page …
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面或照片
[root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面

###################################################################################################################

nginx服务器
谁在访问你?
访问量有多少?
并发量有多少?
PV是多少? page view 点击量
UV是多少? user view 访问量 页面访问人数 一台客户端为一个访客
有没有等待用户?有多少?

如何查看服务器状态信息（非常重要的功能）

1）编译安装时使用--with-http_stub_status_module开启状态页面模块
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                        //开启SSL加密功能
> --with-stream                                //开启TCP/UDP代理模块
> --with-http_stub_status_module                //开启status状态页面
[root@proxy nginx-1.12.2]# make && make install    //编译并安装

在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。

[root@proxy ~]# /usr/local/nginx/sbin/nginx
[root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
[root@proxy ~]# ss  -anptu  |  grep nginx
2）启用Nginx服务并查看监听端口状态
ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。


3）修改Nginx配置文件，定义状态页面
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
… …
location /status {
                stub_status on;
                 #allow IP地址;
                 #deny IP地址;
        }
… …
[root@proxy ~]# nginx


4）优化后，查看状态页面信息
[root@proxy ~]# curl  http://192.168.4.5/status
Active connections: 1 
server accepts handled requests
 10 10 3 
Reading: 0 Writing: 1 Waiting: 0



Active connections：当前活动的连接数量。
Accepts：已经接受客户端的连接总数 `量。
Handled：已经处理客户端的连接总数量。
（一般与accepts一致，除非服务器限制了连接数量）。
Requests：客户端发送的请求数量。
Reading：当前服务器正在读取客户端请求头的数量。
Writing：当前服务器正在写响应信息的数量。
Waiting：当前多少客户端在等待服务器的响应。

tcp:有3次握手4次断开
以前http:一次连接一次握手
keepalive:一次连接多次请求 设置tiomeout超出时长无回应则自动断开
(3 3 6 当许久没有请求或关掉网页, 再刷新则更新为4 4 7 )

PV量:/usr/local/nginx/logs/access.log | wc 
UV量:awk '{IP[$1]++} END{for(i in IP){print IP[i],i}}'  /usr/local/nginx/logs/access.log


步骤三：优化Nginx并发量

1）优化前使用ab高并发测试
[root@proxy ~]# ab -n 1000 -c 1000 http://192.168.4.5/  #-c多少人一起访问     -n一共访问次数
Benchmarking 192.168.4.5 (be patient)
socket: Too many open files (24)                //提示打开文件数量过多

2）修改Nginx配置文件，增加并发量
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
worker_processes  2;                    //与CPU核心数量一致 (启动两个进程)
events {
worker_connections 65535;        //每个worker最大并发连接数
}
.. ..
[root@proxy ~]# nginx -s reload

静态数据
100个人访问-------[nginx 1kjpg,MP3,]
#并发量与网卡有关

动态数据
100个人访问--------[nginx,php]		
#并发量与cpu,代码质量有关, cpu来解析脚本


[root@proxy ~]# ulimit -a 		#用户限制
open files                      (-n) 1024  #默认1024, 文件最多开1024
max user processes(进程)      (-u) 5569	#最多开多少个程序
 							(命令选项)
[root@proxy ~]# ulimit -Hn 100000		#设置硬限制（临时规则)
[root@proxy ~]# ulimit -Sn 100000		#设置软限制（临时规则）
 								#soft	软限制		超过没事,警告
 								#hard	硬限制		底线
[root@proxy ~]# ulimit -a 
open files                      (-n) 100000	
[root@proxy ~]# ab -c 20001 -n 20001 http://192.168.4.5/
ab: Invalid Concurrency [Range 0..20000]		#这台测试不能超过2w

[root@proxy ~]# vim /etc/security/limits.conf	#永久生效, 需重启计算机
.. ..
添加以下
*               soft    nofile            100000
*               hard    nofile            100000
#该配置文件分4列，分别如下：
#用户或组    硬限制或软限制    需要限制的项目   限制的值
工作环境:临时和永久一起做

[root@proxy ~]# cd /root/lnmp_soft/
[root@proxy lnmp_soft]# ./buffer.sh 
[root@proxy lnmp_soft]# cat ./buffer.sh
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}				#循环5000次,生成一个长的URL地址栏
do
	URL=${URL}v$i=$i			
done
curl $URL

192.168.4.5v1=1
192.168.4.5v1=1v2=2
192.168.4.5v1=1v2=2v3=3
192.168.4.5v1=1v2=2v3=3.......v5000=5000

[root@proxy lnmp_soft]# ./buffer.sh
.. ..
<center><h1>414 Request-URI Too Large</h1></center>        
#提示头部信息过大
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
client_header_buffer_size    1k;        #默认请求包头信息的缓存    
large_client_header_buffers  4 1m;     #4 个1m
#4k在工作环境已经足够,实验环境1m
#大请求包头部信息的缓存个数与容量
 								#buffer:缓存  large:大的 client:客户机
.. ..
}
[root@proxy ~]# nginx -s reload
[root@proxy lnmp_soft]# ./buffer.sh 
<h1>Welcome to nginx!</h1>


浏览器有缓存功能
存什么,存多久,由服务端决定
 	动态数据不能让其缓存
 	静态数据可以让其缓存(视频,图片,音频)
location ~\.(jpg|png|....)$		#location相当于如果, 看需求添加缓存内容
expires	15d;	缓存15天  expire:过期时间


[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
expires        30d;            //定义客户端缓存时间为30天
}
}
[root@proxy lnmp_soft]# nginx -s reload
[root@proxy lnmp_soft]# cp /usr/share/backgrounds/day.jpg  /usr/local/nginx/html/



在firefox地址栏内输入about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。
disk
Number of entries: 	6				#缓存的数目
Maximum storage size: 	358400 KiB
Storage in use: 	946 KiB
Storage disk location:				#保存的路径
 	/root/.cache/mozilla/firefox/qy5fcjl3.default/cache2 
List Cache Entries				#点击有惊喜


日志切割
日志文件越来越大怎么办？单个文件10G? 如何切割？（非常常见的面试题）
文件有id号, 文件读id号
[root@proxy ~]# ll -h /usr/local/nginx/logs/access.log 
-rw-r--r-- 1 root root 4.6M 6月  18 14:10 /usr/local/nginx/logs/access.log

[root@proxy ~]# cd /usr/local/nginx/logs/
[root@proxy logs]# cat nginx.pid 			#查看进程PID号
3923
步骤：1. 把旧的日志重命名
[root@proxy logs]# mv access.log access2.log 
[root@proxy logs]# ls 
access2.log  error.log  nginx.pid
[root@proxy logs]# kill -USR1 3923			#会生成一个新的access.log
[root@proxy logs]# ls
access2.log  access.log  error.log  nginx.pid

[root@proxy logs]# kill -l		#查看kill后可选选项,可以用对应数字

[root@proxy ~]# vim /usr/local/nginx/logbak.sh
#!/bin/bash
date=`date +%Y%m%d`
logpath=/usr/local/nginx/logs
mv $logpath/access.log $logpath/access-$date.log
mv $logpath/error.log $logpath/error-$date.log
kill -USR1 $(cat $logpath/nginx.pid)					#
[root@proxy ~]# crontab -e
03 03 * * 5  /usr/local/nginx/logbak.sh

作用:给nginx进程传递信号
kill -l #查看kill功能
不加选项默认15
kill  选项 进程号
linux kill信号列表
$ kill -l
1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT 17) SIGCHLD
18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN
22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO
30) SIGPWR      31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1
36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4  39) SIGRTMIN+5
40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8  43) SIGRTMIN+9
44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13
52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9
56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6  59) SIGRTMAX-5
60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2  63) SIGRTMAX-1
64) SIGRTMAX列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。
下面我们对编号小于SIGRTMIN的信号进行讨论。
1) SIGHUP
本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。
登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进 程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也 能继续下载。
此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。
2) SIGINT
程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。
3) SIGQUIT
和SIGINT类似, 但由QUIT字符(通常是Ctrl-\)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。
4) SIGILL
执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。
5) SIGTRAP
由断点指令或其它trap指令产生. 由debugger使用。
6) SIGABRT
调用abort函数生成的信号。
7) SIGBUS
非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。
8) SIGFPE
在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。
9) SIGKILL
用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。
10) SIGUSR1
留给用户使用
11) SIGSEGV
试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.
12) SIGUSR2
留给用户使用
13) SIGPIPE
管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。
14) SIGALRM
时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.
15) SIGTERM
程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。
17) SIGCHLD
子进程结束时, 父进程会收到这个信号。
如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情 况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。
18) SIGCONT
让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符...
19) SIGSTOP
停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.
20) SIGTSTP
停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号
21) SIGTTIN
当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.
22) SIGTTOU
类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.
23) SIGURG
有"紧急"数据或out-of-band数据到达socket时产生.
24) SIGXCPU
超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。
25) SIGXFSZ
当进程企图扩大文件以至于超过文件大小资源限制。
26) SIGVTALRM
虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.
27) SIGPROF
类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.
28) SIGWINCH
窗口大小改变时发出.
29) SIGIO
文件描述符准备就绪, 可以开始进行输入/输出操作.
30) SIGPWR
Power failure
31) SIGSYS
非法的系统调用。
在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP
不能恢复至默认动作的信号有：SIGILL,SIGTRAP
默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ
默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM
默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU
默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH
此外，SIGIO在SVR4是退出，在4.3BSD中是忽略；SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞


步骤七：对页面进行压缩处理, 把网站压缩功能打开
在带宽不变的情况下, 压缩之后,速度更快,消耗流量小
1）修改Nginx配置文件
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
http {
.. ..
gzip on;                            //开启压缩
gzip_min_length 1000;                
#小文件不压缩, 越压越大, 至少满足1k字节
gzip_comp_level 4;         #压缩比率1-9
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                #对特定文件压缩，类型参考mime.types
.. ..
}

nginx自动压缩功能
所有浏览器都有自动解压功能
支持gzip解压(免费 开源)

许多浏览器都支持gzip压缩, 免费开源, 不支持RAR压缩, 因为要钱
压缩比率 1-9 数字越大压缩效果越好, 也消耗cpu,压缩时间过长 常用4
特别大的文件也能压缩, 比如大的视频, 压缩耗时间, 体验不好

[root@proxy logs]# vim /usr/local/nginx/conf/mime.types
第一列就是配置文件要写的内容
第二列扩展名

步骤八：服务器内存缓存

1）如果需要处理大量静态文件，可以将文件缓存在内存，下次访问会更快。
http { 
open_file_cache          max=2000  inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;
#设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
#文件句柄的有效时间是60秒，60秒后过期
#只有访问次数超过5次会被缓存
#如果cache有报错时, 不报错
} 

nginx的模板
[root@proxy logs]# vim /root/lnmp_soft/nginx.conf
 

步骤五：部署测试页面

1）部署测试页面(Web1服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web1 ~]# cd lnmp_soft/php_scripts/
[root@web1 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web1 php_scripts]# cd php-memcached-demo
[root@web1 php-memcached-demo]# cp -r  *  /usr/local/nginx/html/

2）浏览器直接访问后端服务器的测试页面（Web1服务器）。
[root@web1 ~]# firefox http://192.168.2.100            //填写账户信息
[root@web1 ~]# cd /var/lib/php/session/            
//查看服务器本地的Session信息
[root@web1 ~]# ls
sess_ahilcq9bguot0vqsjtd84k7244                        
//注意这里的ID是随机的
[root@web1 ~]# cat sess_ahilcq9bguot0vqsjtd84k7244

注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=blue>。

3）部署测试页面(Web2服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web2 ~]# cd lnmp_soft/php_scripts/
[root@web2 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web2 php_scripts]# cd php-memcached-demo
[root@web2 php-memcached-demo]# cp -a  *  /usr/local/nginx/html/

session共享

性能
cpu缓存>内存>磁盘>数据库
价格
cpu缓存>内存>磁盘>数据库


memcached(数据库)
KV数据库K=key V=value
key=value
是高性能的分布式缓存服务器
--用来集中缓存数据库查询结果,减少数据库访问次数
以提高动态web应用的响应速度
在工作环境有需要则最好再开一个服务器装这个软件
优点:很快
缺点:重启后所有数据丢失

web1
创建session(文件名=状态)
创建session(连接memcached(d35fg664=”状态”))
client再次访问proxy轮询转发给web2(client表示有cookied35fg664)

目录:/usr/lib/systemd/system/能不能起服务取决于这个目录下有没有文件

[root@proxy ~]# yum -y install memcached
[root@proxy ~]# cat /usr/lib/systemd/system/memcached.service 
[Unit]								#查看这个文档, 不需要修改
Description=Memcached 			#我是memcached
Before=httpd.service
After=network.target

[Service]
Type=simple
EnvironmentFile=-/etc/sysconfig/memcached	
#以下变量值定义在这个环境变量文件, -代表有文件就读, 没有就不读
ExecStart=/usr/bin/memcached -u $USER哪个用户起 -p $PORT端口 -m $CACHESIZE内存 -c $MAXCONN最多多少人连 $OPTIONS

[Install]
WantedBy=multi-user.target


[root@proxy ~]# cat /etc/sysconfig/memcached	#工作有需要可以进来改
PORT="11211"				#端口
USER="memcached"		#哪个用户起
MAXCONN="1024"			#最多多少人连
CACHESIZE="64"			#内存
OPTIONS=""


3）启动服务并查看网络连接状态验证是否开启成功：
netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。

[root@proxy ~]# systemctl  start  memcached
[root@proxy ~]# systemctl  status  memcached
[root@proxy ~]# netstat  -anptu  |  grep memcached
tcp    0    0 0.0.0.0:11211        0.0.0.0:*        LISTEN        2839/memcached      
tcp    0    0 :::11211            :::*                LISTEN        2839/memcached      
udp    0    0 0.0.0.0:11211        0.0.0.0:*                    2839/memcached      
udp    0    0 :::11211            :::*                            2839/memcached
[root@proxy ~]# setenforce 0
[root@proxy ~]# firewall-cmd --set-default-zone=trusted


步骤二：使用telnet访问memcached服务器
1）使用yum安装telnet
[root@proxy ~]# yum -y install telnet		#远程管理软件
[root@proxy ~]# telnet 192.168.2.5 11211
set key 0 180 3
#set定义变量 key#变量名0#不压缩 180#只缓存180秒 3#3个字节

set key 0 180 3						#定义了3个字节
mima								#变量值,字母数量等于定义的字节数
CLIENT_ERROR bad data chunk		#报错mima是4个字节
ERROR
set key 0 180 4						#定义4个字节
mima
STORED							#成功了
get key								#查看key变量
VALUE key 0 4						
mima
END

add myname 0 180 10            #新建，myname不存在则添加，存在则报错
set myname 0 180 10            #添加或替换变量
replace myname 0 180 10       #替换，如果myname不存在则报错
get myname                    #读取变量

set a 0 160 2
12
STORED
append a 0 60 3				#向变量中追加数据
345
STORED
get a 
VALUE a 0 5
12345

delete myname                 #删除变量
flush_all                        #清空所有
quit                            #退出登录   


实现此案例需要按照如下步骤进行。
步骤一：创建PHP页面，使用PHP语言测试memcached服务

1）部署测试页面
创建PHP首页文档/usr/local/nginx/html/index.php，测试页面可以参考lnmp_soft/php_scripts/mem.php。
注意：192.168.2.5是memcached数据库。

[root@web1 ~]# cd lnmp_soft/php_scripts/
[root@web1 php_scripts]# cp mem.php /usr/local/nginx/html/mem.php
 [root@web1 ~]# vim /usr/local/nginx/html/mem.php
<?php
$memcache=new Memcache;                #创建memcache对象
$memcache->connect('192.168.2.5',11211) or die ('could not connect!!');
$memcache->set('key','test');             #定义变量
$get_values=$memcache->get('key');        #获取变量值
echo $get_values;
?>

2）客户端测试（结果会失败）
客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
[root@web1 ~]# firefox http://192.168.2.100/mem.php
注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。

3）为PHP添加memcache扩展
[root@web1 php_scripts]# yum list | grep memca		#查看软件包 
php-pecl-memcache.x86_64    3.0.8-4.el7      local_repo 

[root@web1 ~]# yum -y install  php-pecl-memcache
[root@web1 ~]# systemctl restart php-fpm

4）客户端再次测试（结果会成功显示数据结果）
[root@web1 ~]# firefox http://192.168.2.100/mem.php

4 案例4：PHP实现session共享

修改PHP-FPM配置文件，并重启服务
注意，因为后端两台web服务器(web1,web2)都需要修改配置文件(下面也web1为例)。
[root@web1 ~]# vim  /etc/php-fpm.d/www.conf            //修改该配置文件的两个参数

#文件的最后2行
修改前效果如下:
php_value[session.save_handler] = files
php_value[session.save_path] = /var/lib/php/session
#原始文件，默认定义Sessoin会话信息本地计算机（默认在/var/lib/php/session）

修改后效果如下:
php_value[session.save_handler] = memcache				#存什么类型?
php_value[session.save_path] = "tcp://192.168.2.5:11211"	#存的具体位置
#定义Session信息存储在公共的memcached服务器上，主机参数中为memcache（没有d）
#通过path参数定义公共的memcached服务器在哪（服务器的IP和端口）
[root@web1 ~]# systemctl  restart  php-fpm

真机测试:
谷歌网页测试:192.168.4.5/index.php
登录					#实验成功只需登录一次
Welcome : kk 
Logged In : true
Session ID: 0cqtcroukshvmfjmsrdohc2hi0
ID号就是数据库里变量名key
[root@proxy ~]# telnet 192.168.2.5 11211			#在proxy查看数据库
get 0cqtcroukshvmfjmsrdohc2hi0
VALUE 0cqtcroukshvmfjmsrdohc2hi0 0 78
login_user|s:2:"kk";logged_in|s:4:"true";id|s:26:"0cqtcroukshvmfjmsrdohc2hi0";
END

静态数据(图片,视频,音频,文档)
动态数据(脚本)
php,java,python,perl,ruby,shell
httpd,nginx 不皮套java

java简介
-java是一种跨平台的,面向对象的程序设计语言,Java技术具有卓越的通用性,高效性,平台移植性和安全性.
-java体系
-Java SE(标准版)
-Java EE(企业版)
-java ME(移动版)
JDK简介
JDK是sun针对java开发者推出的java语言的软件开发工具包
JDK是整个java的核心
-包括了java运行环境
-java工具(如编译,排错,打包等工具)
-java基础的类库
JRE()
JRE包括
-Java虚拟机(jvm)
-java核心库和支持文件
-不包括开发工具(JDK)--编译器,调试器和其他工具

java:跨平台的开发语言
(Windows linux 电视 ) 
代码几乎不用改变就可以在不同平台使用
因为java自带虚拟机,代码运行在java的虚拟机上
缺点:运行代码前,先运行jvm,吃内存

java servlet
servlet是Java扩展web服务器功能的组件规范
常见servlet容器
-IBM		websphere
-oracle		weblogic
-Apache	tomcat(发展最好,免费开源)
-Redhat		jboss
用这些软件时,要确认电脑要java解释器,因为这些软件是java写的

上课用第三方的	openjdk
openjre

1）使用RPM安装JDK环境
[root@web1 ~]# yum -y install  java-1.8.0-openjdk     	   #安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless  #安装JDK
[root@web1 ~]# java -version                                #查看JAVA版本
[root@web1 ~]# rpm -ql java-1.8.0-openjdk | less

安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）
[root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
[root@web1 ~]# ls /usr/local/tomcat
bin/                   					#主程序目录
lib/         							#库文件目录
logs/                         			#日志目录  
temp/                          			#临时目录
work/                 					#自动编译目录jsp代码转换servlet
conf/									#配置文件目录
webapps/ 								#页面目录

3）启动服务(需要大量的随机数据,内存数据多,就起来了,内存少就起来慢)
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
[root@web1 tomcat]# cat /dev/random				
#空白为内存数据不够, 有一大堆垃圾数据出来就可以启服务
[root@web1 tomcat]# strings /dev/random
#空白为内存数据不够
[root@web1 tomcat]# strings /dev/urandom 
#有大量随机数, 刺激

[root@web1 ~]# mv /dev/random  /dev/bak			#备份更改random
[root@web1 ~]# ln -s /dev/urandom  /dev/random		
#将/dev/urandom 以快捷方式代替原来的random
[root@web1 ~]# ll /dev/random 
lrwxrwxrwx 1 root root 12 6月  19 14:56 /dev/random -> /dev/urandom


[root@web1 ~]# /usr/local/tomcat/bin/startup.sh 
Using CATALINA_BASE:   /usr/local/tomcat
Using CATALINA_HOME:   /usr/local/tomcat
Using CATALINA_TMPDIR: /usr/local/tomcat/temp
Using JRE_HOME:        /usr
Using CLASSPATH:       /usr/local/tomcat/bin/bootstrap.jar:/usr/local/tomcat/bin/tomcat-juli.jar
Tomcat started.
[root@web1 ~]# netstat -antupl | grep java
tcp6       0      0 127.0.0.1:8005    :::*      LISTEN      5130/java           
tcp6       0      0 :::8009            :::*      LISTEN      5130/java           
tcp6       0      0 :::8080            :::*      LISTEN      5130/java    
#8005 8009 8080看到这几端口,服务起来了

[root@web1 tomcat]# ls bin/shutdown.sh 
bin/shutdown.sh

创建测试JSP页面
[root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
<html>
<body>
<center>
Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
</center>
</body>
</htm

重启服务
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

真机测试
http://192.168.2.100:8080/test.jsp

[root@web1 conf]# pwd
/usr/local/tomcat/conf
[root@web1 conf]# ls server.xml 		#主配置文件
server.xml

[root@web1 conf]# vim server.xml 		#严格区分大小写
<Server>
   <Service>
     <Connector port=8080 />			#一般常用8080
...
     <Connector port=8009 />
...
     <Engine name="Catalina" defaultHost="localhost">
...
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">									#是否自动解包
</Host>

<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>
… …

压缩java文件常用压缩格式
jar  -cf  myjava.war  myjava
jar  -xf  myjava.war  #解压, 实际也不需要解压, 配置文件可以自动解包

[root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT	#页面都在ROOT下
[root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
[root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.htm
重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh


使用docBase参数可以修改默认网站首页路径
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path=""  docBase="base"/>		#docBase默认值是ROOT
</Host>
… …
[root@web1 ~]# mkdir  /usr/local/tomcat/b/base
[root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh


1）当用户访问http://www.a.com/test打开/var/www/html目录下的页面
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />	#path跳转
</Host>

<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
</Host>
… …
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh
[root@web1 ~]# firefox http://www.a.com:8080/test	#测试


connector决定一个端口

1）创建加密用的私钥和证书文件
[root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore                //提示输入密码为:123456
//-genkeypair     生成密钥对
//-alias tomcat     密钥别名
//-keyalg RSA     定义密钥算法为RSA算法(还有一种DSA)
//-keystore         定义密钥文件存储在:/usr/local/tomcat/keystore

输入密钥库口令:  
再次输入新口令: 
您的名字与姓氏是什么?
  [Unknown]:  hxb
您的组织单位名称是什么?
  [Unknown]:  nbbb
您的组织名称是什么?
  [Unknown]:  cjnbbb
您所在的城市或区域名称是什么?
  [Unknown]:  gz
您所在的省/市/自治区名称是什么?
  [Unknown]:  sd
该单位的双字母国家/地区代码是什么?
  [Unknown]:  cn
CN=hxb, OU=nbbb, O=cjnbbb, L=gz, ST=sd, C=cn是否正确?
  [否]:  y
输入 <tomcat> 的密钥口令
	(如果和密钥库口令相同, 按回车):  
再次输入新口令: 
Warning:

2)再次修改server.xml配置文件，创建支持加密连接的Connector
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
… …
<Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
  150个线程          开启ssl           使用https访问    
keystoreFile="/usr/local/tomcat/keystore"   keystorePass="123456" 
#添加此行
clientAuth="false" sslProtocol="TLS" />
#备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可
#<!- -  被注释的东西  - ->

重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh  
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh 

############################################################################
############################################################################
###########################################################################

开机执行文件:
/etc/rc.local(主开机文件)
/etc/bashrc
/etc/profile 
/etc/sysconfig/network-scripts/网卡

java开发出来直接就是war包,把war包cp到网站根目录
tomcat 可以自动解压war包

tomcat的logs日志文件每天都会主动按照日期生成一个新文件
/usr/local/tomcat/logs/
报错信息查看:catalina.2019-06-19.log
猫网站访问日志:localhost_access_log.2019-06-19.txt

<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
#从默认localhost虚拟主机中把Valve这段复制过来，适当修改下即可
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix=" a_access" suffix=".txt"  #设置日志文件名
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />  #生成文件的日期格式
</Host>


###################################################################################################

nginx[代理+缓存]
varnish代理软件
varnish[代理+缓存](CDN (content delivery network)(内容分发网络))

client---------varnish(缓存)-------------Web

DNS 分离解析

使用Varnish加速后端Web服务
代理服务器可以将远程的Web服务器页面缓存在本地
远程Web服务器对客户端用户是透明的
利用缓存机制提高网站的响应速度
使用varnishadm命令管理缓存页面
使用varnishstat命令查看Varnish状态

步骤二：部署Varnish缓存服务器192.168.4.5

1）编译安装软件
[root@proxy ~]# yum -y install gcc readline-devel    //安装软件依赖包
[root@proxy ~]# yum -y install python-docutils         //安装软件依赖包
 [root@proxy ~]# useradd -s /sbin/nologin varnish                //创建账户
[root@proxy ~]# tar -xf varnish-5.2.1.tar.gz
[root@proxy ~]# cd varnish-5.2.1
[root@proxy varnish-5.2.1]# ./configure
[root@proxy varnish-5.2.1]# make && make install

2）复制启动脚本及配置文件
[root@proxy varnish-5.2.1]# cp  etc/example.vcl #主配置文件模板  /usr/local/etc/default.vcl #路径可以自己定义

3）修改代理配置文件
[root@proxy ~]# vim  /usr/local/etc/default.vcl
backend default {        #默认后台
     .host = "192.168.2.100";
     .port = "80";
 }

4）启动服务
 [root@proxy ~]# varnishd  -f /usr/local/etc/default.vcl 
//varnishd命令的其他选项说明如下： 
//varnishd -s malloc,128M        定义varnish使用内存作为缓存，空间为128M
//varnishd -s file,/var/lib/varnish_storage.bin,1G 定义varnish使用文件作为缓存
[root@proxy ~]# varnishd  -s file,/var/lib/varnish_storage.bin,1G  -f /usr/local/etc/default.vcl 
  不写-s则默认varnishd -s malloc,128M

1）客户端开启浏览器访问
[root@client ~]# curl http://192.168.4.5
步骤四：其他操作

1）查看varnish日志
[root@proxy ~]# varnishlog                        //varnish实时日志
[root@proxy ~]# varnishncsa                    //实时访问日志

2）更新缓存数据，在后台web服务器更新页面内容后，用户访问代理服务器看到的还是之前的数据，说明缓存中的数据过期了需要更新（默认也会自动更新，但非实时更新）。
[root@proxy ~]# varnishadm  
varnish> ban req.url ~ .*
//清空缓存数据，支持正则表达式

varnish会自动更新缓存(大约两分钟左右)


##################################################################################
##################################################################################
##################################################################################




版本控制软件（共享仓库）
主要用途：
开发代码（更新存储）
                          集中版本控制SVN(subversion)
                  分布式版本控制系统（git）




步骤一：部署Git服务器（作为远程git服务器）

１．安装Git软件
２．初始化一个仓库:
  mkdir   /var/git　　＃创建一个目录
 git 　init　/var/git/project　--bare (初始化空的var/git/为仓库）
常用命令表格：


客户端：
 　　　　（clone克隆服务器仓库到本地。）
１．安装Git软件
2. git clone root@ＩＰ地址：/var/git/project     #将远程服务端的仓库克隆到本机
（project/.git本地仓库）
        git status    #查看仓库中的数据状态 
 3 git add .    #添加到暂存区（建索引）

４．git commit -m "注释说明" ＃添加注释并保存到本地仓库
补充：本地工作区对数据进行增删改查(必须要先进入仓库再操作数据）．添加保存到本地仓库第一次时会报错，需要填写邮件和名字，此处不可省略，但可以随便输入，命令会在报错上面可直接复制,输入后会在家目录中生成一个文件．　 cat ~/.gitconfig ）
５．ｇit push #将本地仓库中的数据推送到远程服务器
（输入服务器root密码）
git  pull    #将远程服务器上的文件拉到本地仓库
备注：可能其他人也在修改数据并提交服务器，就会导致自己的本地数据为旧数据，使用pull就可以将服务器上新的数据更新到本地。
			
最常用的命令：
     add .  #将文件提交到本地缓存区
   commit　＃提交文件到本地仓库
    push　　＃将文件提交到远程服务器
    pull　　　＃将远程服务器的文件下载到本地仓库
    git log --pretty=oneline    #查看版本日志
     git reflog　　#也可以查看版本日志





注：客户端也可以使用图形程序访问服务器。Windows需要安装git和tortoiseGit。
查看Git版本信息​
 git reflog​       #查看版本历史信息
git log --oneline​    #查看版本历史信息​

移动HEAD指针，将数据还原到任意版本。​
提示：当前HEAD指针为HEAD@{0}。​
 git reflog​    #会显示HEAD＠号　．​ git log --oneline​则不显示

git reset --hard​+仓库代码　　＃恢复该文件的所有数据




步骤一：部署Git服务器（192.168.2.100作为远程git服务器）

1）YUM安装Git软件。
[root@web1 ~]# yum -y install git
[root@web1 ~]# git --version

2)初始化一个空仓库。
[root@web1 ~]# mkdir /var/git
[root@web1 ~]# git init /var/git/project --bare 
[root@web1 ~]# ls /var/git/
config  description  HEAD  hooks  info  objects  refs   
步骤二：客户端测试(192.168.2.200作为客户端主机)

使用git常用指令列表如表-1所示。
表－1 git常用指令列表

1) clone克隆服务器仓库到本地。
[root@web2 ~]# yum -y install git
[root@web2 ~]# git clone root@192.168.2.100:/var/git/project 
[root@web2 ~]# cd project
[root@web2 ~]# ls 

2) 修改git配置。
[root@web2 project]# git config --global user.email "you@example.com"
[root@web2 project]# git config --global user.name "Your Name"
[root@web2 project]# cat ~/.gitconfig 
[user]
    email = you@example.com
    name = Your Name

3） 本地工作区对数据进行增删改查(必须要先进入仓库再操作数据)。
[root@web2 project]# echo "init date" > init.txt
[root@web2 project]# mkdir demo
[root@web2 project]# cp /etc/hosts demo

4） 查看仓库中数据的状态。
[root@web2 project]# git status   

5） 将工作区的修改提交到暂存区。
[root@web2 project]# git add .

6) 将暂存区修改提交到本地仓库。
[root@web2 project]# git commit  -m  "注释，可以为任意字符"
[root@web2 project]# git status

7） 将本地仓库中的数据推送到远程服务器(web2将数据推送到web1)。
[root@web2 project]# git config --global push.default simple
[root@web2 project]# git push
root@192.168.2.100's password:  输入服务器root密码
[root@web2 project]# git status

8) 将服务器上的数据更新到本地（web1的数据更新到web2）。
备注：可能其他人也在修改数据并提交服务器，就会导致自己的本地数据为旧数据，使用pull就可以将服务器上新的数据更新到本地。
[root@web2 project]# git pull

9) 查看版本日志。
[root@web2 project]# git log
[root@web2 project]# git log --pretty=oneline
[root@web2 project]# git log --oneline
[root@web2 project]# git reflog
备注：客户端也可以使用图形程序访问服务器。
Windows需要安装git和tortoiseGit。

Git支持按功能模块、时间、版本等标准创建分支，分支可以让开发分多条主线同时进行，每条主线互不影响
常见的分支规范如下：
MASTER分支（MASTER是主分支，是代码的核心）。
DEVELOP分支（DEVELOP最新开发成果的分支）。
RELEASE分支（为发布新产品设置的分支）。
HOTFIX分支（为了修复软件BUG缺陷的分支）。
FEATURE分支（为开发新功能设置的分支）。

步骤一：查看并创建分支

1）查看当前分支。
[root@web2 project]# git status
# On branch master
nothing to commit, working directory clean
[root@web2 project]# git branch -v
* master 0dc2b76 delete init.txt

2）创建分支。
[root@web2 project]# git branch hotfix   #创建分支
[root@web2 project]# git branch feature  #创建分支
[root@web2 project]# git branch -v       #查看分支
  feature 0dc2b76 delete init.txt
  hotfix  0dc2b76 delete init.txt
* master  0dc2b76 delete init.txt
步骤二：切换与合并分支

1）切换分支。
[root@web2 project]# git checkout hotfix     #切换指针指向hotfix
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
* hotfix  0dc2b76 delete init.txt
master  0dc2b76 delete init.txt

2）在新的分支上可以继续进行数据操作（增、删、改、查）。
[root@web2 project]# echo "fix a bug" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "fix a bug"

3）将hotfix修改的数据合并到master分支。
注意，合并前必须要先切换到master分支，然后再执行merge命令。
[root@web2 project]# git checkout master
[root@web2 project]# cat new.txt        #默认master分支中没有hotfix分支中的数据
[root@web2 project]# git merge hotfix    #合并分区
Updating 0dc2b76..5b4a755
Fast-forward
 new.txt | 1 ++
 1 file changed, 1 insertions(+)

4）将所有本地修改提交远程服务器。
[root@web2 project]# git push

步骤二：解决版本分支的冲突问题

1）在不同分支中修改相同文件的相同行数据，模拟数据冲突。

[root@web2 project]# git checkout hotfix
[root@web2 project]# echo "AAA" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by hotfix"
[root@web2 project]# git checkout master
[root@web2 project]# echo "BBB" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by master"
自动合并 a.txt
冲突（添加/添加）：合并冲突于 a.txt
自动合并失败，修正冲突然后提交修正的结果。

2）查看有冲突的文件内容，修改文件为最终版本的数据，解决冲突。
[root@web2 project]# cat a.txt                #该文件中包含有冲突的内容
<<<<<<< HEAD
BBB
=======
AAA
>>>>>>> hotfix
[root@web2 project]# vim a.txt              #修改该文件，为最终需要的数据，解决冲突
BBB
[root@web2 project]# git add .
[root@web2 project]# git commit -m "resolved"

########################################################################################
#######################################################################################
ssh-keygen -f /root/.ssh/id_rsa -N '   #非交互式生成秘钥
ssh-copy-id  192.168.2.100      #传输公钥给对方
######################################################################################
######################################################################################

Git支持很多服务器协议形式，不同协议的Git服务器，客户端就可以使用不同的形式访问服务器。创建的服务器协议有SSH协议、Git协议、HTTP协议。 

基于SSH服务和基于git服务(客户端必须安装git软件)
基于HTTP服务(有浏览器就能看 只有读权限没有写权限)


步骤一：SSH协议服务器（支持读写操作）

1）创建基于密码验证的SSH协议服务器（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_ssh
Initialized empty Git repository in /var/git/base_ssh/

2)客户端访问的方式（web2主机操作）。
[root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
[root@web2 ~]# rm -rf base_ssh

3）客户端生成SSH密钥，实现免密码登陆git服务器（web2主机操作）。
[root@web2 ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
[root@web2 ~]# ssh-copy-id  192.168.2.100
[root@web2 ~]# git clone root@192.168.2.100:/var/git
[root@web2 ~]# git push


步骤二：Git协议服务器（只读操作的服务器）

1）安装git-daemon软件包（web1主机操作）。
[root@web1 ~]# yum -y install git-daemon

2）创建版本库（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_git
Initialized empty Git repository in /var/git/base_git/

3）修改配置文件，启动git服务（web1主机操作）。
[root@web1 ~]# vim /usr/lib/systemd/system/git@.service
修改前内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git 
--export-all --user-path=public_git --syslog --inetd –verbose
修改后内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git 
--export-all --user-path=public_git --syslog --inetd –verbose
[root@web1 ~]# systemctl  start  git.socket

4）客户端访问方式（web2主机操作）
[root@web2 ~]# git clone git://192.168.2.100/base_git

#################################################################################
#################################################################################
#################################################################################

步骤三：HTTP协议服务器（只读操作的服务器）

1）安装gitweb、httpd软件包（web1主机操作）。
[root@web1 ~]# yum -y install httpd gitweb

2）修改配置文件，设置仓库根目录（web1主机操作）。
[root@web1 ~]# vim +11 /etc/gitweb.conf 
$projectroot = "/var/git";                        #添加一行

3) 创建版本仓库（web1主机操作）
[root@web1 ~]# git init --bare /var/git/base_http

4）启动httpd服务器
[root@web1 ~]# systemctl start httpd

5）客户端访问方式（web2主机操作）
注意：调用虚拟机中的firefox浏览器，需要在远程时使用ssh -X 服务器IP，并且确保真实主机的firefox已经关闭。
[root@web2 ~]# firefox http://192.168.2.100/git/

#################################################
#老师的资料:地址https://github.com/redhatedu/course#
#################################################

RPM是一个压缩包 
首先需要在自己电脑上源码包编译一遍
把/usr/local/nginx打包压缩nginx.rpm
rpm -ivh  nginx.rpm
/usr/local/nginx 
yum -y install  nginx

SOURCES目录放源码软件

步骤一：安装rpm-build软件

1）安装rpm-build软件包
[root@web1 ~]# yum -y install  rpm-build

2）生成rpmbuild目录结构
[root@web1 ~]# rpmbuild -ba nginx.spec                //会报错，没有文件或目录
[root@web1 ~]# ls /root/rpmbuild                    //自动生成的目录结构
BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS

3）准备工作，将源码软件复制到SOURCES目录
[root@web1 ~]# cp nginx-1.12.2.tar.gz /root/rpmbuild/SOURCES/

4）创建并修改SPEC配置文件
[root@web1 ~]# vim /root/rpmbuild/SPECS/nginx.spec 
Name:nginx                                        #源码包软件名称
Version:1.12.2                                    #源码包软件的版本号
Release:    10                                        #制作的RPM包版本号
Summary: Nginx is a web server software.            #RPM软件的概述    
License:GPL                                        #软件的协议
URL:    www.test.com                                    #网址
Source0:nginx-1.12.2.tar.gz                        #源码包文件的全称
#BuildRequires:                                    #制作RPM时的依赖关系
#Requires:                                        #安装RPM时的依赖关系
%description
nginx [engine x] is an HTTP and reverse proxy server.    #软件的详细描述
%post
useradd nginx                               #非必需操作：安装后脚本(创建账户)
%prep
%setup -q                                #自动解压源码包，并cd进入目录
%build
./configure
make %{?_smp_mflags}
%install
make install DESTDIR=%{buildroot}
%files
%doc
/usr/local/nginx/*                    #对哪些文件与目录打包
%changelog

yum install (a b  c d ):一个一个装
yum groupinstall {abcd} : 一次装完

步骤二：使用配置文件创建RPM包

1）安装依赖软件包
[root@web1 ~]# yum -y install  gcc  pcre-devel openssl-devel
2）rpmbuild创建RPM软件包
[root@web1 ~]# rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec
[root@web1 ~]# ls /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
[root@web1 ~]# rpm -qpi RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
Name        : nginx        Relocations: (not relocatable)
Version     : 1.12.2        Vendor: (none)
Release     : 10            Build Date: Mon 02 May 2016 02:30:53 AM PDT
Install Date: (not installed)            Build Host: localhost
Group       : Applications/Internet        Source RPM: nginx-1.8.0-1.src.rpm
Size        : 721243                    License: GPL
Signature   : (none)
URL         : www.nginx.org
Summary     : Nginx is a web server software.
Description :
nginx [engine x] is an HTTP and reverse proxy server.
[root@web1 ~]# rpm -qpl nginx-1.12.2-10.x86_64.rpm 
/usr
/usr/local
/usr/local/nginx
/usr/local/nginx/conf
/usr/local/nginx/conf/fastcgi.conf
/usr/local/nginx/conf/fastcgi.conf.default
/usr/local/nginx/conf/fastcgi_params
/usr/local/nginx/conf/fastcgi_params.default
/usr/local/nginx/conf/koi-utf
/usr/local/nginx/conf/koi-win
/usr/local/nginx/conf/mime.types
/usr/local/nginx/conf/mime.types.default
/usr/local/nginx/conf/nginx.conf
/usr/local/nginx/conf/nginx.conf.default
/usr/local/nginx/conf/scgi_params
/usr/local/nginx/conf/scgi_params.default
/usr/local/nginx/conf/uwsgi_params
/usr/local/nginx/conf/uwsgi_params.default
/usr/local/nginx/conf/win-utf
/usr/local/nginx/html
/usr/local/nginx/html/50x.html
/usr/local/nginx/html/index.html
/usr/local/nginx/logs
/usr/local/nginx/sbin
/usr/local/nginx/sbin/nginx
步骤三：安装、卸载软件

[root@web1 ~]# rpm -ivh RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
[root@web1 ~]# rpm -qa |grep nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web1 ~]# curl http://127.0.0.1/



GPL协议:随意下载随意修改随意发布

git版本控制软件
git init --bare /project
git clone root@ip:/project
当前目录/project工作目录(最后的版本)
/project/.git(本地仓库,所有版本)
修改文件
git add.
git commit -m “注释” 提交到本地仓库
git push			提交远程仓库
看日志
git log
git log --oneline
git reflog
git reset --hard		版本号

git branch 分支名称(新)
git checkout 分支
修改代码
git branch master
git branch 新分支
合并
gti branch master
git merge 分支名称   合并

分支就一个指针箭头
分支可以创很多个
HEAD指针, 只能有一个, 指向当前正在使用的分支和版本

RPM
先在自己的电脑先源码编译安装一遍,把安装后的结果目录打包rpm
yum -y install rpm-build
rpmbuil -ba xx.spec
cp 源码 /root/rpmbuild/SOURCES
vim /root/rpmbuild/SPECS/nginx.spec
填空
1)基本信息(3个跟软件名称与版本)name version source
2)编译安装,打包
a)./configure
b)%post
c)装后命令
d)%file
e)/usr/local/nginx

day 7
配置GRE VPN
vpn虚拟专用网络
--在公用网络上建立专用私有网络, 进行加密通讯
--多用于为集团公司的各地子公司建立链接
--连接完成后,各个地区的子公司可以像局域网一样通讯
--在企业网络中广泛应用
--偶尔可用于翻墙(私用没事,盈利犯法哦)
--目前主流的vpn技术(GRE PPTP L2TP+IPSec SSL)

公网ip                      公网ip
A--------------电信/联通----------B
    |__ _ __ __ _ _ _ _ _ ___ _ _ __|
   专用私有网络, 且网络厂商无法抓包

难度
GRE<PPTP<l2tp+ipsec
安全
GRE<PPTP<l2tp+ipsec


整个linux都是模块化设计
linux支持GRE 
Windows不支持

client eth3 201.1.2.10/24
proxy eth3  201.1.2.5/24

[root@proxy ~]# lsmod		#查看模块
Module                  Size  Used by
iosf_mbi               14990  0 
kvm_intel             174841  0 
kvm                   578518  1 kvm_intel
irqbypass              13503  1 kvm
...
[root@proxy ~]# lsmod | wc -l
39							#激活了39个模块

[root@client ~]# lsmod  | grep ip_gre  
#确定是否加载了gre模块,没有则执行下面的命令
加载模块ip_gre
[root@client ~]# modprobe  ip_gre 			#激活gre模块

查看模块信息
[root@client ~]# modinfo ip_gre				#查看模块信息
filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
#模块位置
alias:          netdev-gretap0
...

[root@proxy kernel]# cd /lib/modules/3.10.0-862.el7.x86_64/kernel
[root@proxy kernel]# find ./ -name "*ko*" | wc -l #有2456个模块,目前激活了39个
2456

Client主机创建VPN隧道
1）创建隧道
[root@client ~]# ip tunnel help
[root@client ~]# ip tunnel add tun0 mode gre remote 201.1.2.5 local 201.1.2.10
#ip 隧道 创建 名字tun0 使用gre模式  对方ip 201.1.2.5  自己ip 201.1.2.10

//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址

[root@client ~]# ip link show 
[root@client ~]# ip link show tun0		#查看网卡, 多了一张tun0
8: tun0@NONE: <POINTOPOINT,NOARP> mtu 1476 qdisc noop state DOWN mode DEFAULT group default qlen 1000						#默认DOWN关闭
    link/gre 201.1.2.10 peer 201.1.2.5

启用该隧道（类似与设置网卡up）
[root@client ~]# ip link show
[root@client ~]# ip link set tun0 up         #让tun0 UP
[root@client ~]# ip link show
8: tun0@NONE: <POINTOPOINT,NOARP,UP,LOWER_UP> mtu 1476 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/gre 201.1.2.10 peer 201.1.2.5

为VPN配置隧道IP地址
[root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.10/24）
//隧道对面的主机IP的隧道IP为10.10.10.5/24
#peer一对的意思

[root@client ~]# ip addr  show tun0                      #查看IP地址
8: tun0@NONE: <POINTOPOINT,NOARP,UP,LOWER_UP> mtu 1476 qdisc noqueue state UNKNOWN group default qlen 1000
    link/gre 201.1.2.10 peer 201.1.2.5
    inet 10.10.10.10 peer 10.10.10.5/24 scope global tun0
       valid_lft forever preferred_lft forever

[root@client ~]# ip a s					#可以看到其他网卡


在墙外服务器开启路由转发
linux天生是软路由
开启路由转发、关闭防火墙
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
#若是1则是路由器 是0则不是路由器
#vim改不了, 必须用重定向
[root@proxy ~]# firewall-cmd --set-default-zone=trusted
利用linux电脑装两个不同网段的网卡, 可以简单代替路由器


创建PPTP VPN
部署VPN服务器
1）安装软件包（软件包参考lnmp_soft）
[root@proxy vpn]# pwd
/root/lnmp_soft/vpn
[root@proxy vpn]# yum -y install pptpd-1.4.0-2.el7.x86_64.rpm
[root@proxy vpn]# rpm -qc pptpd 				#查看有什么配置文件
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd

修改配置文件
[root@proxy ~]# vim /etc/pptpd.conf
.. ..
localip 201.1.2.5                      				#服务器本地IP
remoteip 192.168.3.1-50                  			#分配给客户端的IP池(范围)
不连续的话用”,”隔开,有模板

[root@proxy ~]# vim /etc/ppp/options.pptpd
require-mppe-128                           		
#使用MPPE的128位秘钥加密数据,gre的数据不加密
ms-dns 8.8.8.8                     				#DNS服务器,解析域名, 翻墙需要

[root@proxy ~]# vim /etc/ppp/chap-secrets            //修改账户配置文件
# client    server      secret     IP addresses
jacob         *       123456         *
abc          *        123456         *
//用户名    服务器标记    密码      客户端
设置了客户端 则只允许某个ip访问
设置了服务器(名字必须与/etc/ppp/options.pptpd的name一样)则只允许访问这个服务器
[root@proxy vpn]# systemctl start pptpd
[root@proxy vpn]# systemctl enable pptpd

翻墙设置（非必需操作）
[root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.10
#把私网ip201.1.2.10转换成公网ip 192.168.3.0.

在Windows里设置vpn 
pptpd里的IP地址

ping测试

创建L2TP+IPSec VPN
部署IPSec服务
1）安装软件包
[root@client ~]# yum -y install libreswan

[root@client vpn]# pwd 
/root/lnmp_soft/vpn
[root@client vpn]# cp myipsec.conf  /etc/ipsec.d/
[root@client vpn]# ls /etc/ipsec.d/
myipsec.conf  policies

[root@client ~]# cat /etc/ipsec.conf                //仅查看一下该主配置文件
.. ..
include /etc/ipsec.d/*.conf                    //加载该目录下的所有配置文件

[root@client ~]# vim /etc/ipsec.d/myipsec.conf    #里面都是秘钥,算法
//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
conn IDC-PSK-NAT
    rightsubnet=vhost:%priv                        //允许建立的VPN虚拟网络
    also=IDC-PSK-noNAT
conn IDC-PSK-noNAT
    authby=secret                                    //加密认证
        ike=3des-sha1;modp1024                        //算法
        phase2alg=aes256-sha1;modp2048                //算法
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=3h
    type=transport
    left=201.1.2.10                                //重要，服务器本机的外网IP
    leftprotoport=17/1701
    right=%any                                    //允许任何客户端连接
    rightprotoport=17/%any

创建IPSec预定义共享密钥
[root@client ~]# cat /etc/ipsec.secrets              	#仅查看，不要修改该文件
include /etc/ipsec.d/*.secrets
#存放预共享秘钥
[root@client ~]# vim /etc/ipsec.d/mypass.secrets     	#新建该文件
201.1.2.10   %any:    PSK    "randpass"           	#randpass为预共享密钥
自己的ip    客户端ip            预共享秘钥     	#201.1.2.10是VPN服务器的IP
PSK: pre share key  预先  共享  秘钥

启动IPSec服务
[root@client ~]# systemctl start ipsec        
[root@client ~]# netstat -ntulp |grep pluto
udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto          
udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto          
udp6       0      0 ::1:500                 :::*                 3148/pluto

启动的端口4500 500


部署XL2TP服务
安装软件包（软件包参考lnmp_soft）
[root@client ~]# yum -y (local)install xl2tpd-1.3.8-2.el7.x86_64.rpm
(locat ? )

xl2tpd 约等于 pptpd

修改xl2tp配置文件（修改3个配置文件的内容）
[root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf    		#修改主配置文件
[global]
.. ..    
[lns default]
.. ..
ip range = 192.168.3.128-192.168.3.254        		#分配给客户端的IP池
local ip = 201.1.2.10                            		#VPN服务器的IP地址
...

[root@client ~]# vim /etc/ppp/options.xl2tpd        	#认证配置
require-mschap-v2                              		
#取消注释，强制要求认证,顶头写,否则无效
#crtscts                 		#注释或删除该行, 不识别此语句
#lock                     		#注释或删除该行, 不识别此语句
[root@client ~]# vim /etc/ppp/chap-secrets     		#修改密码文件
jacob            *       123456    *                
#账户名称   服务器标记    密码    客户端IP

启动服务
[root@client ~]# systemctl start xl2tpd
[root@client ~]# netstat  -ntulp |grep xl2tpd        
udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tp
#启用1701端口

设置路由转发，防火墙
[root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@client ~]# firewall-cmd --set-default-zone=trusted

翻墙设置（非必需操作）
[root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.10

Windows注册表等于内核
设置Windows注册表（不修改注册表，连接VPN默认会报789错误），具体操作如下：
单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
找到下面的注册表子项，然后单击它：
HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services\Rasman\Parameters
在"编辑"菜单上，单击"新建"->"DWORD值"
在"名称"框中，键入"ProhibitIpSec"
在"数值数据"框中，键入"1"，然后单击"确定"
退出注册表编辑器，然后重新启动计算机


NTP时间同步
要求搭建一个NTP服务器，为整个网络环境中的所有主机提供时间校准服务
Network Time Protocol（网络时间协议）采用的是分层设计，如图-9所示，Stratum层的总数限制在15以内（包括15）














[root@client ~]# yum -y install chrony
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
软件包 chrony-3.2-2.el7.x86_64 已安装并且是最新版本
无须任何处理
[root@client ~]# rpm -qc chrony
/etc/chrony.conf
/etc/chrony.keys
/etc/logrotate.d/chrony
/etc/sysconfig/chronyd

修改配置文件
[root@proxy ~]# cat /etc/chrony.conf
.. ..
server 0.centos.pool.ntp.org iburst   		
#server用户客户端指向上层NTP服务器
allow 192.168.4.0/24          		#允许那个IP或网络访问NTP
#deny  192.168.4.1             	#拒绝那个IP或网络访问NTP
local stratum 10              		#设置NTP服务器的层数量,不要超过15
.. ..

4)启动NTP服务
[root@proxy ~]# systemctl  restart  chronyd
[root@proxy ~]# systemctl  enable  chronyd

闰秒会导致服务器崩溃
会多一秒
正常59---00
闰秒59---60---00

[root@proxy ~]# cal 2019
全是日历
[root@proxy ~]# cal 1752
1752年的9月份少了11天

gnome-terminal -x bash -c "bash ./a:exec bash;"

###############################################################################
*****************************************************************************************
###############################################################################

什么是集群
-一组通过高速互联的计算组，并以单一系统的模式加以管理
-将很多的服务器集中在一起，提供同一种服务，在客户端看来只有一个服务器
-可以在付出成本比较低的情况下获得在性能、可靠性、灵活性方面的相对较高的收益
-任务调度是集群系统中的核心技术

集群目的
-提高性能
-降低成本
-提高可扩展性
-增强可靠性

集群分类
	高性能计算集群HPC
-通过集群开发的并行应用程序，解决复杂的科学问题

	负载均衡（LB）集群
-客户端负载在计算机群中尽可能平均分摊

	高可用（HA）集群
-避免单点故障，当一个系统发生故障时，可以快速迁移

LVS集群组成
	前端：负载均衡层
-由一台或多台负载调度器构成
	中间：服务器群组层
-由一组实际运行应用服务的服务器组成
	底端：数据恭喜那个储存层
-提供共享储存空间的存储区域

LVS术语
	Director Server：调度服务器
-将负载分布到Real Server的服务器

	Real Server：真实服务器
-真正提供应用服务的服务器

	VIP：虚拟IP地址
-公布给用户访问的虚拟IP地址

	RIP：真实IP地址
-集群节点上使用的IP地址

	DIP：调度器链接节点的服务的IP地址


-nginx代理服务器
-lvs原理就是路由转发+调度


LVS工作模式
VS/NAT
	-通过网络地址转换实现的虚拟服务器
	-大并发访问时，调度器的性能成为瓶颈
VS/DR
	-直接使用路由技术实现虚拟服务器
	-节点服务器需要配置VIP，注意MAC地址广播
VS/TUN
	-通过隧道方式实现虚拟服务器

lvs原理就是路由转发 + 调度功能

NAT模式不适用于大规模集群

DR模式适用于大规模集群

TUN模式 用的不多



负载均很调度法
LVS目前实现了10种调度算法
常用调度算法有4种
轮询(Round Robin) ：rr
	-将客户端请求平均分发到Real Server
加权轮询（Weighted Round Robin）：wrr
	-根据Real Server权重值进行轮询调度
最少连接（Least Connections）：lc
	-选择连接数最少的服务器
加权最少连接：wlc
	-根据Real Server权重值，选择连接数最少的服务器
源地址哈希（Source Hashing）：sh
	-更具请求的目标IP地址，作为散列健（Hash Key）从静态分配的散列表找出对因的服务器
目标地址哈希：dh

**********************************************************************************
**********************************************************************************

ipvsadm -A		//添加虚拟服务器
ipvsadm -E		//修改
ipvsadm -D		//删除
ipvsadm -C		//清空所有

ipvsadm -a		//添加真实服务器
ipvsadm -e		//修改
ipvsadm -d		//删除
ipvsadm -L		//查看LVS规则表
-s [rr|wrr|lc|wlc]	//指定集群算法

Masq 地址欺骗

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：使用命令增、删、改LVS集群规则

1）创建LVS虚拟集群服务器（算法为加权轮询：wrr）
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr

2）为集群添加若干real server
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -m -w 1
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr
  -> 192.168.2.100:80             Masq    1      0          0
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -m -w 2
[root@proxy ~]# ipvsadm –a -t 192.168.4.5:80 -r 192.168.2.201 -m -w 3
[root@proxy ~]# ipvsadm –a -t 192.168.4.5:80 -r 192.168.2.202 -m -w 4

3）修改集群服务器设置(修改调度器算法，将加权轮询修改为轮询)
[root@proxy ~]# ipvsadm -E -t 192.168.4.5:80 -s rr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 rr
  -> 192.168.2.100:80             Masq    1      0          0         
  -> 192.168.2.200:80             Masq    2      0          0         
  -> 192.168.2.201:80             Masq    2      0          0         
  -> 192.168.2.202:80             Masq    1      0          0

4）修改read server（使用-g选项，将模式改为DR模式）
[root@proxy ~]# ipvsadm -e -t 192.168.4.5:80 -r 192.168.2.202 -g

5）查看LVS状态
[root@proxy ~]# ipvsadm -Ln

6）创建另一个集群（算法为最少连接算法；使用-m选项，设置工作模式为NAT模式）
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:3306 -s lc
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.100 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.200 -m

6）永久保存所有规则
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

7）清空所有规则
[root@proxy ~]# ipvsadm -C

*****************************************************************************
client---nginx(代理）----web（2.5在上网）
client---lvs（转发）-----web（4.10在上网）

1.lvs主机 ip_forword=1
2.web主机必须配网关

*****************************************************************************

2 案例2：部署LVS-NAT集群
2.1 问题

使用LVS实现NAT模式的集群调度服务器，为用户提供Web服务：
集群对外公网IP地址为192.168.4.5
调度器内网IP地址为192.168.2.5
真实Web服务器地址分别为192.168.2.100、192.168.2.200
使用加权轮询调度算法，真实服务器权重分别为1和2

NAT模式: -m
TUN模式(隧道模式): -i
DR模式(直连路由): -g


2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置基础环境

1）设置Web服务器（以web1为例）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
2）启动Web服务器软件
[root@web1 ~]# systemctl restart httpd
3)关闭防火墙与SELinux
[root@web1 ~]# systmctl stop firewalld
[root@web1 ~]# setenforce 0

步骤三：部署LVS-NAT模式调度器

1)确认调度器的路由转发功能(如果已经开启，可以忽略)
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
[root@proxy ~]# cat /proc/sys/net/ipv4/ip_forward
1
[root@proxy ~]# echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
#修改配置文件，设置永久规则

2）创建集群服务器
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr

2）添加真实服务器
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -w 1 -m

3）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

步骤四：客户端测试

客户端使用curl命令反复连接http://192.168.4.5，查看访问的页面是否会轮询到不同的后端真实服务器。


*******************************************************************************
*******************************************************************************

client----lvs
	vip	

3 案例3：部署LVS-DR集群
3.1 问题

使用LVS实现DR模式的集群调度服务器，为用户提供Web服务：
客户端IP地址为192.168.4.10
LVS调度器VIP地址为192.168.4.15
LVS调度器DIP地址设置为192.168.4.5
真实Web服务器地址分别为192.168.4.100、192.168.4.200
使用加权轮询调度算法，web1的权重为1，web2的权重为2
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。


3.3 步骤

实现此案例需要按照如下步骤进行。
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
步骤一：配置实验网络环境

1）设置Proxy代理服务器的VIP和DIP

注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口！！！

[root@proxy ~]# cd /etc/sysconfig/network-scripts/
[root@proxy ~]# cp ifcfg-eth0{,:0}
[root@proxy ~]# cat ifcfg-eth0


[root@proxy ~]# vim ifcfg-eth0:0
TYPE=Ethernet
BOOTPROTO=none
#eth0有则不用添加   DEFROUTE=yes
NAME=eth0:0
DEVICE=eth0:0
ONBOOT=yes
IPADDR=192.168.4.15
PREFIX=24

TYPE=Ethernet        #网卡类型
BOOTPROTO=none       #none手动配置ip  dhcp为自动获取(需要吧网卡ip和子网掩码注释掉)
NAME=eth0:0          #网卡名
DEVICE=eth0:0        #网卡名
ONBOOT=yes           #开机是否自动激活
IPADDR=192.168.4.5   #网卡ip 
PREFIX=24            #子网掩码


[root@proxy ~]# systemctl restart network

rhel7 和centos7系统中 network 和NetworkManager两个程序都在管理eth0,到导致重启不成功 
可以先stop NetworkManager服务
旧可以重启成功了

2）设置Web1服务器网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0

接下来给web1配置VIP地址。
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。

[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0

NETMASK=255.255.255.255  #主机地址回环地址


DEVICE=lo:0              #网卡名
IPADDR=192.168.4.15      #ip地址
NETMASK=255.255.255.255  #网络掩码
NETWORK=192.168.4.15     #网络地址
BROADCAST=192.168.4.15   #广播地址
ONBOOT=yes               #开机是否激活
NAME=lo:0                #网卡名


重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
[root@web1 ~]# systemctl stop firewalld
[root@web1 ~]# setenforce 0

3）设置Web2服务器网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0

接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0


防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web2 ~]# sysctl -p


重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
[root@web2 ~]# systemctl stop firewalld
[root@web2 ~]# setenforce 0

步骤二：配置后端Web服务器

1）自定义Web页面
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html

2）启动Web服务器软件
[root@web1 ~]# systemctl restart httpd
[root@web2 ~]# systemctl restart httpd

步骤三：proxy调度器安装软件并部署LVS-DR模式调度器

1）安装软件（如果已经安装，此步骤可以忽略）
[root@proxy ~]# yum -y install ipvsadm

2）清理之前实验的规则，创建新的集群服务器规则
[root@proxy ~]# ipvsadm -C                                #清空所有规则
[root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr

3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1

4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
TCP  192.168.4.15:80 wrr
  -> 192.168.4.100:80             Route   1      0          0         
  -> 192.168.4.200:80             Route   2      0          0
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

**********************************************************************
**********************************************************************

lvs==nginx
lvs:优点:在内核里运行 工作效率最高	 工作在四层tcp ,udp 	
     缺点:不带健康检查功能              功能简单(转发)

免费:lvs   haproxy   nginx   [F5(big-ip)三十万.底层物理层 效率更高 
lvs > haproxy > nginx 性能
nginx > haproxy > lvs 功能

##########################################################################




keepalived原理和路由VRRP协议原理类似
		router1(ip1)
电脑------vip
		router2(ip2)

keepalived也叫浮动vip

keepalived功能:
1.实现VRRP(浮动vip)
2.自动配置LVS规则
3.健康检查功能
tcp_check
http_get
ssl_get


keepalived概述
-实现了高可用集群
-最初是为了LVS设计的，专门监控各服务器节点的状态
-后来加入了VRRP功能，防止单点故障

keepalived运行原理
-检测每个服务器节点状态
-服务器节点异常或工作出现故障，keepalived将故障节点从集群系统中剔除
-故障节点恢复后，Keepalived再将其加入到集群系统中
-所有工作自动完成，无需人工干预

*******************************************************************************
*******************************************************************************
1 案例1：Keepalived高可用服务器
1.1 问题

准备三台Linux服务器，两台做Web服务器，并部署Keepalived高可用软件，一台作为客户端主机，实现如下功能：
使用Keepalived实现web服务器的高可用
Web服务器IP地址分别为192.168.4.100和192.168.4.200
Web服务器的浮动VIP地址为192.168.4.80
客户端通过访问VIP地址访问Web页面

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置网络环境（如果在前面课程已经完成该配置，可以忽略此步骤）

1）设置Web1服务器网络参数、配置Web服务
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd

2）设置Web2服务器网络参数、配置Web服务
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd


3）配置proxy主机的网络参数（如果已经设置，可以忽略此步骤）
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0

----------------------------------------------------------------------------------------------------------

步骤二：安装Keepalived软件

注意：两台Web服务器做相同的操作。
[root@web1 ~]# yum install -y keepalived
[root@web2 ~]# yum install -y keepalived 


步骤三：部署Keepalived服务

1）修改web1服务器Keepalived配置文件
[root@web1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  web1                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state MASTER                         //主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                    //定义网络接口
  virtual_router_id 51                //主备服务器VRID号必须一致
  priority 100                     //服务器优先级,优先级高优先获取VIP
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主备服务器密码必须一致
  }
  virtual_ipaddress {                   //谁是主服务器谁获得该VIP（实验需要修改）
192.168.4.80 
}    
}


2）修改web2服务器Keepalived配置文件
[root@web2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  web2                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state BACKUP                             //备服务器为BACKUP（实验需要修改）
  interface eth0                        //定义网络接口
  virtual_router_id 51                    //主辅VRID号必须一致
  priority 50                             //服务器优先级（实验需要修改）
  advert_int 1
  authentication {
     auth_type pass
     auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                 //谁是主服务器谁配置VIP（实验需要修改）
192.168.4.80 
 }   
}


3）启动服务
[root@web1 ~]# systemctl start keepalived
[root@web2 ~]# systemctl start keepalived


4）配置防火墙和SELinux
启动keepalived会自动添加一个drop的防火墙规则，需要清空！
[root@web1 ~]# iptables -F
[root@web1 ~]# setenforce 0
[root@web2 ~]# iptables -F
[root@web1 ~]# setenforce 0

步骤四：测试
1）登录两台Web服务器查看VIP信息
[root@web1 ~]# ip addr show eth0
[root@web2 ~]# ip addr show eth0

2) 客户端访问
客户端使用curl命令连接http://192.168.4.80，查看Web页面；关闭Web1服务器的网卡，客户端再次访问http://192.168.4.80，验证是否可以正常访问服务。


*********************************************************************************
*********************************************************************************

2 案例2：Keepalived+LVS服务器
2.1 问题

使用Keepalived为LVS调度器提供高可用功能，防止调度器单点故障，为用户提供Web服务：
LVS1调度器真实IP地址为192.168.4.5
LVS2调度器真实IP地址为192.168.4.6
服务器VIP地址设置为192.168.4.15
真实Web服务器地址分别为192.168.4.100、192.168.4.200
使用加权轮询调度算法，真实web服务器权重不同


注意：两台LVS调度器执行相同的操作（如何已经安装软件，可用忽略此步骤）。
安装软件
[root@proxy1 ~]# yum install -y keepalived
[root@proxy1 ~]# systemctl enable keepalived
[root@proxy1 ~]# yum install -y ipvsadm
[root@proxy1 ~]# ipvsadm -C
[root@proxy2 ~]# yum install -y keepalived
[root@proxy2 ~]# systemctl enable keepalived
[root@proxy2 ~]# yum install -y ipvsadm
[root@proxy2 ~]# ipvsadm -C


部署Keepalived实现LVS-DR模式调度器的高可用

1）LVS1调度器设置Keepalived，并启动服务
[root@proxy1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  lvs1                        //设置路由ID号(实验需要修改)
}
vrrp_instance VI_1 {
  state MASTER                             //主服务器为MASTER
  interface eth0                        //定义网络接口
  virtual_router_id 50                    //主辅VRID号必须一致
  priority 100                         //服务器优先级
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                   //配置VIP（实验需要修改）
192.168.4.15 
 }   
}
virtual_server 192.168.4.15 80 {           //设置ipvsadm的VIP规则（实验需要修改）
  delay_loop 6
  lb_algo wrr                          //设置LVS调度算法为WRR
  lb_kind DR                               //设置LVS的模式为DR
  #persistence_timeout 50
#注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
  protocol TCP
  real_server 192.168.4.100 80 {         //设置后端web服务器真实IP（实验需要修改）
    weight 1                             //设置权重为1
    TCP_CHECK {                            //对后台real_server做健康检查
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
 real_server 192.168.4.200 80 {       //设置后端web服务器真实IP（实验需要修改）
    weight 2                          //设置权重为2
    TCP_CHECK {
    connect_timeout 3
    nb_get_retry 3                    //get尝试次数
    delay_before_retry 3              //延迟多长时间再次尝试
    }
  }
}
[root@proxy1 ~]# systemctl start keepalived
[root@proxy1 ~]# ipvsadm -Ln                     #查看LVS规则
[root@proxy1 ~]# ip a  s                          #查看VIP配置

*********************************************************************************
*********************************************************************************

2）LVS2调度器设置Keepalived
[root@proxy2 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                //设置报警收件人邮箱
  }
  notification_email_from ka@localhost    //设置发件人
  smtp_server 127.0.0.1                //定义邮件服务器
  smtp_connect_timeout 30
  router_id  lvs2                        //设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state BACKUP                             //从服务器为BACKUP（实验需要修改）
  interface eth0                        //定义网络接口
  virtual_router_id 50                    //主辅VRID号必须一致
  priority 50                             //服务器优先级（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                       //主辅服务器密码必须一致
  }
  virtual_ipaddress {                   //设置VIP（实验需要修改）
192.168.4.15  
}  
}
virtual_server 192.168.4.15 80 {          //自动设置LVS规则（实验需要修改）
  delay_loop 6
  lb_algo wrr                          //设置LVS调度算法为WRR
  lb_kind DR                               //设置LVS的模式为DR
 # persistence_timeout 50
#注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
  protocol TCP
  real_server 192.168.4.100 80 {        //设置后端web服务器的真实IP（实验需要修改）
    weight 1                              //设置权重为1
    TCP_CHECK {                         //对后台real_server做健康检查
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
 real_server 192.168.4.200 80 {         //设置后端web服务器的真实IP（实验需要修改）
    weight 2                              //设置权重为2
    TCP_CHECK {
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
[root@proxy2 ~]# systemctl start keepalived
[root@proxy2 ~]# ipvsadm -Ln                 #查看LVS规则
[root@proxy2 ~]# ip  a   s                    #查看VIP设置


客户端测试

客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。



3.3 步骤

实现此案例需要按照如下步骤进行。
注意事项：

将前面实验VIP、LVS等实验的内容清理干净！！！！！！

删除所有设备的VIP，清空所有LVS设置，关闭keepalived！！！

web1关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web1 ~]# ifdown eth0
[root@web1 ~]# ifdown lo:0
[root@web1 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth1
Web2关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web2 ~]# ifdown eth0
[root@web2 ~]# ifdown lo:0
[root@web2 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth1
proxy关闭keepalived服务，清理LVS规则。
[root@proxy ~]# systemctl stop keepalived
[root@proxy ~]# systemctl disable keepalived
[root@proxy ~]# ipvsadm -C
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
[root@proxy ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth1


步骤一：配置后端Web服务器

设置两台后端Web服务（如果已经配置完成，可用忽略此步骤）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# systemctl start httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# systemctl start httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html


步骤二：部署HAProxy服务器

1）配置网络，安装软件
[root@haproxy ~]# yum -y install haproxy


2）修改配置文件
[root@haproxy ~]# vim /etc/haproxy/haproxy.cfg
global
 log 127.0.0.1 local2   ###[err warning info debug]
 chroot /usr/local/haproxy
 pidfile /var/run/haproxy.pid ###haproxy的pid存放路径
 maxconn 4000     ###最大连接数，默认4000
 user haproxy
 group haproxy
 daemon       ###创建1个进程进入deamon模式运行
defaults
 mode http    ###默认的模式mode { tcp|http|health } log global   ###采用全局定义的日志
 option dontlognull  ###不记录健康检查的日志信息
 option httpclose  ###每次请求完毕后主动关闭http通道
 option httplog   ###日志类别http日志格式
 option forwardfor  ###后端服务器可以从Http Header中获得客户端ip
 option redispatch  ###serverid服务器挂掉后强制定向到其他健康服务器
 timeout connect 10000 #如果backend没有指定，默认为10s
 timeout client 300000 ###客户端连接超时
 timeout server 300000 ###服务器连接超时
 maxconn  60000  ###最大连接数
 retries  3   ###3次连接失败就认为服务不可用，也可以通过后面设置
listen stats 0.0.0.0:1080   #监听端口
    stats refresh 30s   #统计页面自动刷新时间
    stats uri /stats   #统计页面url
    stats realm Haproxy Manager #进入管理解面查看状态信息
    stats auth admin:admin  #统计页面用户名和密码设置
  #stats hide-version   #隐藏统计页面上HAProxy的版本信息
listen  websrv-rewrite 0.0.0.0:80
   balance roundrobin
   server  web1 192.168.2.100:80 check inter 2000 rise 2 fall 5
   server  web2 192.168.2.200:80 check inter 2000 rise 2 fall 5
#check 设置健康检查 可不添加
 #每隔2秒钟检查一次  确认两次成功链接才认为web服务器完好或修复好 失败连接五次视为web服务器故障


3）启动服务器并设置开机启动
[root@haproxy ~]# systemctl start haproxy
[root@haproxy ~]# systemctl enable haproxy
步骤三：客户端验证

客户端配置与HAProxy相同网络的IP地址，并使用火狐浏览器访问http://192.168.4.5，测试调度器是否正常工作，客户端访问http://192.168.4.5:1080/stats测试状态监控页面是否正常。访问状态监控页的内容，参考图-4所示。

图-4
备注：
Queue队列数据的信息（当前队列数量，最大值，队列限制数量）；
Session rate每秒会话率（当前值，最大值，限制数量）；
Sessions总会话量（当前值，最大值，总量，Lbtot: total number of times a server was selected选中一台服务器所用的总时间）；
Bytes（入站、出站流量）；
Denied（拒绝请求、拒绝回应）；
Errors（错误请求、错误连接、错误回应）；
Warnings（重新尝试警告retry、重新连接redispatches）；
Server(状态、最后检查的时间（多久前执行的最后一次检查）、权重、备份服务器数量、down机服务器数量、down机时长)。

keepalived.conf配置组成：

      global_defs{......}

      vrrp_script XXX{......}

      vrrp_instance VI_X{......}

      virtual_server IPPORT { ...... }

           orvirtual_server fwmark int { ...... } 

           orvirtual_server group string { ...... }    

keepalived.conf常用参数解析：

以下为双主模式下keepalived+nginx配置。

[root@testkeepalived]# cat keepalived.conf

! ConfigurationFile for keepalived

global_defs {

   notification_email {

#notification_email：指定当keepalived出现问题时，发送邮件给哪些用户。  

     root@localhost

   }

   notification_email_from field@localhost

#notification_emai_from：发送邮件时，邮件的源地址。    

   smtp_server 127.0.0.1

#smtp_server<DOMAIN|IP> [<PORT>]：smtp服务器的地址或域名。默认端口为25.如：smtp_server smtp.field.com 25      

   smtp_connect_timeout 30

#指定smtp服务器连接的超时时间，单位s。  

   router_id test.field.com

#router_id：指定标识该机器的route_id. 如：route_id LVS_DEVEL  

   vrrp_mcast_group4 224.18.0.200

#vrrp_mcast_group4224.0.0.18：指定发送VRRP组播消息使用的IPV4组播地址。默认是224.0.0.18

#vrrp_mcast_group6ff02::12 指定发送VRRP组播消息所使用的IPV6组播地址。默认是ff02::12  

}

#vrrp_script添加一个周期性执行的脚本。脚本的退出状态码会调用它的所有的VRRP Instance记录。

#至少应该有一个VRRP实例调用它并且优先级不能为0.优先级范围是1-254.

vrrp_scriptchk_maintanance {

        script "[[ -f /etc/keepalived/down]] && exit 1 || exit 0"

#手工编写测试keepalived脚本，如果down文件存在则优先级-2       

        interval 1

#interval多长时间检查一次

#如果失败返回1权重-2

        weight -2

}

vrrp_scriptchk_nginx {

        script "killall -0 nginx &>/dev/null"

#nginx检测脚本，nginx服务是否在线。       

        interval 1

#interval多长时间检查一次

#如果失败返回1权重-2

        weight -5

}

vrrp_instanceVI_1 {

    state MASTER

#stateMASTER|BACKUP：指定该keepalived节点的初始状态。   

    interface eth0

#interface eth0：vrrp实例绑定的接口，用于发送VRRP包，注意要与本机借口一致。

    virtual_router_id 51

#virtual_router_id51：指定VRRP实例ID，范围是0-255，注意每个vip实例id必须严格一致。   

    priority 100

#priority 100：指定优先级，优先级高的将成为MASTER。 

    advert_int 1

#advert_int 1：指定发送VRRP通告的间隔。单位是秒。

    authentication {

        auth_type PASS

#auth_typePASS|AH：指定认证方式。PASS简单密码认证(推荐),AH:IPSEC认证(不推荐)。  

        auth_pass 4e78bb3a

#auth_pass 1234：指定认证所使用的密码，可用“openssl rand -hex 4”生成8位随机码     

}

    virtual_ipaddress {

        192.168.88.80/16 dev eth0 label eth0:0

#指定VIP地址/掩码，接口名，别名，可只是用IP/掩码。

    }

track_script {

#track_script 添加一个track脚本，即vrrp_script配置的脚本。每个周期通过调用脚本，会监控服务状态。

        chk_nginx

}

#通知脚本

        notify_master"/etc/keepalived/notify.sh master"

        notify_backup"/etc/keepalived/notify.sh backup"

        notify_fault"/etc/keepalived/notify.sh fault"

}

vrrp_instanceVI_2 {

    state BACKUP

    interface eth0

    virtual_router_id 61

    priority 99

    advert_int 1   

#nopreempt

#设置为非抢占模式。默认是抢占模式，设置非抢占模式时，即使高优先级的机器已经上线，也允许低优先级的机器继续成为MASTER。注意使用非抢占模式时，初始化状态必须为BACKUP。

#preempt_delay：

#设置抢占延迟。单位是秒，范围是0---1000，默认是0.发现低优先级的MASTER后多少秒开始抢占。   

    authentication {

        auth_type PASS

        auth_pass Te7UYb3a

    }

    virtual_ipaddress {

        192.168.88.90/16 dev eth0 label eth0:1

    }

track_script {

#track_script 调用脚本

        chk_nginx

}

        notify_master"/etc/keepalived/notify.sh master"

        notify_backup"/etc/keepalived/notify.sh backup"

        notify_fault"/etc/keepalived/notify.sh fault"

}

#virtual_server192.168.200.100 443 {

#    delay_loop 6

#  delay_loop <INT>：健康检查的时间间隔。

#    lb_algo rr

#  lb_argo rr|wrr|lc|wlc|lblc|sh|dh：LVS调度算法。默认为轮询。

#    lb_kind NAT

#  lb_kind NAT|DR|TUN：LVS模式。

#    nat_mask 255.255.255.0

#    persistence_timeout 50

#persistence_timeout360：持久化超时时间，单位是秒。默认是6分钟。

#    protocol TCP

#  protocol TCP|UDP|SCTP：使用的4层协议。默认TCP.

#    sorry_server 192.168.200.200 1358

#sorry_server<IPADDR> <PORT>：添加一个备用服务器。当所有的RS都故障时，作为显示页面。

#    real_server 192.168.201.100 443 {

#        weight 1

#weight<INT>：给服务器指定权重。默认是1.

#        SSL_GET {

#            url {

#              path /

#path<STRING>：指定要检查的URL的路径。如path / or path /mrtg2

#              digestff20ad2481f97b1754ef3e12ecd3a9cc

#digest<STRING>：摘要。计算方式：genhash-s 172.17.100.1 -p 80 -u /index.html

#            }

#            url {

#              path /mrtg/

#              digest 9b3a0c85a887a256d6939da88aabd8cd

#            }

#            connect_timeout 3

#            nb_get_retry 3   

#nb_get_retry<INT>：get尝试次数。

#            delay_before_retry 3

#delay_before_retry<INT>：延迟多长时间再次尝试。

#        }

#    }

#}


**********************************************************************************
**********************************************************************************

nginx分析
-优点：
	-工作在7层，可以针对http做分流策略
	-1.9版本开始支持4层代理
	-正则表达式比HAProxy强大
	-安装、配置、测试简单，通过日志可以解决多数问题
	-并发量可以达到几万次
	-nginx还可以作为Web服务器使用
-缺点：
	-仅支持http、https、mail协议，应用面小
	-监控检查仅通过端口，无法使用url检查 

------------------------------------------------------------------------------
LVS分析
优点：
	-负载能力强，工作在4层，对内存、CPU消耗低
	-配置性低，没有太多可配置性，减少认为错误
	-应用面广，几乎可以为所有应用提供负载均衡
缺点：
	-不支持正则表达式，不能实现动静分离
	-如果网络架构庞大，LVS-DR配置比较繁琐

---------------------------------------------------------------------------
HAProxy分析
优点：
	-支持session，cookie功能
	-可以通过url进行健康检查
	-效率，负载均衡速度，高于嗯inx，低于LVS
	-HAProxy支持TCP，可以对MySQL惊醒负载均衡
	-调度算法丰富
缺点：
	-正则弱于nginx
	-日志依赖于syslogd

-----------------------------------------------------------------------------

haproxy两种格式：

frontend 名称 *：80
	use_backend 名称
backend 名称
	balance roundrobin
	server web1
	server web2
----------------------------------------

listen 名称 *：80
	balance roundrobin
	server web1
	server web2

----------------------------------------------------------------------------


3 案例3：配置HAProxy负载平衡集群
3.1 问题

准备4台Linux服务器，两台做Web服务器，1台安装HAProxy，1台做客户端，实现如下功能：
客户端访问HAProxy，HAProxy分发请求到后端Real Server
开启HAProxy监控页面，及时查看调度器状态
设置HAProxy为开机启动


3.3 步骤

实现此案例需要按照如下步骤进行。
注意事项：

将前面实验VIP、LVS等实验的内容清理干净！！！！！！

删除所有设备的VIP，清空所有LVS设置，关闭keepalived！！！

web1关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web1 ~]# ifdown eth0
[root@web1 ~]# ifdown lo:0
[root@web1 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth1
Web2关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web2 ~]# ifdown eth0
[root@web2 ~]# ifdown lo:0
[root@web2 ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth1
proxy关闭keepalived服务，清理LVS规则。
[root@proxy ~]# systemctl stop keepalived
[root@proxy ~]# systemctl disable keepalived
[root@proxy ~]# ipvsadm -C

[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0

[root@proxy ~]# nmcli connection modify eth1 ipv4.method manual \
ipv4.addresses 192.168.2.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth1
步骤一：配置后端Web服务器

设置两台后端Web服务（如果已经配置完成，可用忽略此步骤）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# systemctl start httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html

[root@web2 ~]# yum -y install httpd
[root@web2 ~]# systemctl start httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
步骤二：部署HAProxy服务器

1）配置网络，安装软件
[root@haproxy ~]# yum -y install haproxy
2）修改配置文件
[root@haproxy ~]# vim /etc/haproxy/haproxy.cfg
global
 log 127.0.0.1 local2   ###[err warning info debug]
 chroot /usr/local/haproxy
 pidfile /var/run/haproxy.pid ###haproxy的pid存放路径
 maxconn 4000     ###最大连接数，默认4000
 user haproxy
 group haproxy
 daemon       ###创建1个进程进入deamon模式运行
defaults
 mode http    ###默认的模式mode { tcp|http|health } log global   ###采用全局定义的日志
 option dontlognull  ###不记录健康检查的日志信息
 option httpclose  ###每次请求完毕后主动关闭http通道
 option httplog   ###日志类别http日志格式
 option forwardfor  ###后端服务器可以从Http Header中获得客户端ip
 option redispatch  ###serverid服务器挂掉后强制定向到其他健康服务器
 timeout connect 10000 #如果backend没有指定，默认为10s
 timeout client 300000 ###客户端连接超时
 timeout server 300000 ###服务器连接超时
 maxconn  60000  ###最大连接数
 retries  3   ###3次连接失败就认为服务不可用，也可以通过后面设置
listen stats 0.0.0.0:1080   #监听端口
    stats refresh 30s   #统计页面自动刷新时间
    stats uri /stats   #统计页面url
    stats realm Haproxy Manager #进入管理解面查看状态信息
    stats auth admin:admin  #统计页面用户名和密码设置
  #stats hide-version   #隐藏统计页面上HAProxy的版本信息
listen  websrv-rewrite 0.0.0.0:80
   balance roundrobin
   server  web1 192.168.2.100:80 check inter 2000 rise 2 fall 5
   server  web2 192.168.2.200:80 check inter 2000 rise 2 fall 5

3）启动服务器并设置开机启动
[root@haproxy ~]# systemctl start haproxy
[root@haproxy ~]# systemctl enable haproxy
步骤三：客户端验证

客户端配置与HAProxy相同网络的IP地址，并使用火狐浏览器访问http://192.168.4.5，测试调度器是否正常工作，客户端访问http://192.168.4.5:1080/stats测试状态监控页面是否正常。访问状态监控页的内容，参考图-4所示。

图-4
备注：
Queue队列数据的信息（当前队列数量，最大值，队列限制数量）；
Session rate每秒会话率（当前值，最大值，限制数量）；
Sessions总会话量（当前值，最大值，总量，Lbtot: total number of times a server was selected选中一台服务器所用的总时间）；
Bytes（入站、出站流量）；
Denied（拒绝请求、拒绝回应）；
Errors（错误请求、错误连接、错误回应）；
Warnings（重新尝试警告retry、重新连接redispatches）；
Server(状态、最后检查的时间（多久前执行的最后一次检查）、权重、备份服务器数量、down机服务器数量、down机时长)。


##############################################################################################
##############################################################################################
##############################################################################################

DAS存储（直连存储）
NAS存储（网络附加存储）文件系统的共享 nfs，samba，httpd
	分区，格式化，共享目录----->mount
	ext3.ext4，xfs，ntfs，fat32
SAN存储（存储区域网络）块共享：iscsi
	独立的网络存储
SDS（软件定义存储
）分布式存储

什么是分布式存储系统：
-是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连
-分布式文件系统的设计基于客户机/服务器模式

常用分布式文件系统：
Lustre
Hadoop
FastDFS
Ceph	
GlusterFS

什么是ceph
	-是一个分布式文件系统
	-具有高扩展，高可用，高性能的特点
	-可以提供对象存储，块存储。文件系统储存
	-可以提供PB集ie的储存空间（PB--TB--GB）
	-软件定义储存，作为储存行业一大趋势，已经越来越受到市场的认可
帮助文档：http：//docs.ceph.org/start/intro

ceph组件

OSDs
	-存储设备
Monitors
-	-集群监控组件
RadosGateway（RGW）
	-对象储存网关
MDSs
	-存放文件系统的元数据（对象储存和块存储不需要该组件）
Client
	-ceph客户端


    -^-
   /   \
 |O o|  
    ).-.(
  '/|||\`
   | '|` |
     '|`

*********************************************************************************
*********************************************************************************

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装前准备

1）物理机为所有节点配置yum源服务器。
提示：ceph10.iso在/linux-soft/02目录。
[root@room9pc01 ~]# mkdir  /var/ftp/ceph
[root@room9pc01 ~]# mount ceph10.iso /var/ftp/ceph/
2）配置无密码连接(包括自己远程自己也不需要密码)，在node1操作。
[root@node1 ~]# ssh-keygen   -f /root/.ssh/id_rsa    -N ''
[root@node1 ~]# for i in 10  11  12  13
 do
     ssh-copy-id  192.168.4.$i
 done

3）修改/etc/hosts并同步到所有主机。
警告：/etc/hosts解析的域名必须与本机主机名一致！！！！
 [root@node1 ~]# cat /etc/hosts
... ...
192.168.4.10  client
192.168.4.11     node1
192.168.4.12     node2
192.168.4.13     node3
警告：/etc/hosts解析的域名必须与本机主机名一致！！！！
[root@node1 ~]# for i in 10  11  12  13
do
scp  /etc/hosts  192.168.4.$i:/etc/
done

4）修改所有节点都需要配置YUM源，并同步到所有主机。
[root@node1 ~]# cat /etc/yum.repos.d/ceph.repo
[mon]
name=mon
baseurl=ftp://192.168.4.254/ceph/MON
gpgcheck=0
[osd]
name=osd
baseurl=ftp://192.168.4.254/ceph/OSD
gpgcheck=0
[tools]
name=tools
baseurl=ftp://192.168.4.254/ceph/Tools
gpgcheck=0
[root@node1 ~]# yum repolist                #验证YUM源软件数量
源标识            源名称                    状态
Dvd                redhat                    9,911
Mon                mon                        41
Osd                osd                        28
Tools            tools                    33
repolist: 10,013
[root@node1 ~]# for i in  10  11  12  13
do
scp  /etc/yum.repos.d/ceph.repo  192.168.4.$i:/etc/yum.repos.d/
done


5）所有节点主机与真实主机的NTP服务器同步时间。
提示：默认真实物理机已经配置为NTP服务器。
[root@node1 ~]# vim /etc/chrony.conf
… …
server 192.168.4.254   iburst
[root@node1 ~]# for i in 10 11 12 13
do
     scp /etc/chrony.conf 192.168.4.$i:/etc/
     ssh 192.168.4.$i "systemctl restart chronyd"
done


步骤三：准备存储磁盘

物理机上为每个虚拟机准备3块磁盘（可以使用命令，也可以使用图形直接添加）。
 [root@room9pc01 ~]# virt-manager


********************************************************************************
********************************************************************************

2 案例2：部署ceph集群
2.1 问题

沿用练习一，部署Ceph集群服务器，实现以下目标：
安装部署工具ceph-deploy
创建ceph集群
准备日志磁盘分区
创建OSD存储空间
查看ceph状态，验证
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：安装部署软件ceph-deploy

1）在node1安装部署工具，学习工具的语法格式。
[root@node1 ~]#  yum -y install ceph-deploy
[root@node1 ~]#  ceph-deploy  --help
[root@node1 ~]#  ceph-deploy mon --help


2）创建目录
[root@node1 ~]#  mkdir ceph-cluster	//名字无所谓，但是以后执行ceph命令必须在此目录下
[root@node1 ~]#  cd ceph-cluster/

步骤二：部署Ceph集群

1）创建Ceph集群配置,在ceph-cluster目录下生成Ceph配置文件。
在ceph.conf配置文件中定义monitor主机是谁。
[root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3
[root@node1 ceph]# cat ceph.conf				//执行上面命令，自动生成以下文件

[global]
fsid = 0062377e-9d3a-4514-90b1-de25787bf006
mon_initial_members = node1, node2, node3
mon_host = 192.168.4.11,192.168.4.12,192.168.4.13
auth_cluster_required = cephx
auth_service_required = cephx			//cephx是密码占位符
auth_client_required = cephx

2）给所有节点安装ceph相关软件包。
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
    ssh  $i "yum -y install ceph-mon ceph-osd ceph-mds ceph-radosgw"
done 


ceph-osd		-存储设备
ceph-mon		-集群监控组件
ceph-radosgw	-对象储存网关
ceph-mds		-存放文件系统的元数据（对象储存和块存储不需要该组件）


3）初始化所有节点的mon服务，也就是启动mon服务（主机名解析必须对）。
[root@node1 ceph-cluster]# ceph-deploy mon create-initial
###自动远程另外三台服务器,拷贝配置文件过去三台服务器并开启服务

常见错误及解决方法（非必要操作，有错误可以参考）：
如果提示如下错误信息：
[node1][ERROR ] admin_socket: exception getting command descriptions: [Error 2] No such file or directory

解决方案如下（在node1操作）：
先检查自己的命令是否是在ceph-cluster目录下执行的！！！！如果确认是在该目录下执行的create-initial命令，依然报错，可以使用如下方式修复。
[root@node1 ceph-cluster]# vim ceph.conf      #文件最后追加以下内容
public_network = 192.168.4.0/24

修改后重新推送配置文件:
[root@node1 ceph-cluster]# ceph-deploy --overwrite-conf config push node1 node2 node3


/dev/vdb[20G]缓存盘
/dev/vdc[20G]共享盘
/dev/vdd[20G]共享盘

	
**********************************************************************
***********************************************************************

步骤三：创建OSD

备注：vdb1和vdb2这两个分区用来做存储服务器的journal缓存盘。
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
     ssh $i "parted /dev/vdb mklabel gpt"
     ssh $i "parted /dev/vdb mkpart primary 1 50%"
     ssh $i "parted /dev/vdb mkpart primary 50% 100%"
 done


2）磁盘分区后的默认权限无法让ceph软件对其进行读写操作，需要修改权限。

[root@node1 ceph]# for i in node1 node2 node3
> do
> ssh $i "chown ceph:ceph /dev/vdb1"
> ssh $i "chown ceph:ceph /dev/vdb2"
done

#上面的权限修改为临时操作，重启计算机后，权限会再次被重置。
#我们还需要将规则写到配置文件实现永久有效。
#规则：如果设备名称为/dev/vdb1则设备文件的所有者和所属组都设置为ceph。
#规则：如果设备名称为/dev/vdb2则设备文件的所有者和所属组都设置为ceph。

[root@node1 ceph-cluster]# vim /etc/udev/rules.d/70-vdb.rules
ENV{DEVNAME}=="/dev/vdb1",OWNER="ceph",GROUP="ceph"
ENV{DEVNAME}=="/dev/vdb2",OWNER="ceph",GROUP="ceph"

[root@node1 ceph]# for i in node2 node3
> do
> scp /etc/udev/rules.d/vdb.rules $i:/etc/udev/rules.d/vdb.rules 
> done

-----------------------------------------------------------------------
1.分区fdisk、parted 【vdb1，vdb2】
2.修改权限
	chown ceph:ceph
	vim /etc/udev/rules.d/xxx.rules
----------------------------------------------------------------------

3）初始化清空磁盘数据（仅node1操作即可）。
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:vdc   node1:vdd    
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node2:vdc   node2:vdd
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node3:vdc   node3:vdd   


4）创建OSD存储空间（仅node1操作即可）
重要：很多同学在这里会出错！将主机名、设备名称输入错误！！！
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2  
//创建osd存储设备，vdc为集群提供存储空间，vdb1提供JOURNAL缓存，
//一个存储设备对应一个缓存设备，缓存需要SSD，不需要很大
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node2:vdc:/dev/vdb1 node2:vdd:/dev/vdb2
[root@node1 ceph-cluster]# ceph-deploy osd create \
 node3:vdc:/dev/vdb1 node3:vdd:/dev/vdb2 

常见错误及解决方法（非必须操作）。
使用osd create创建OSD存储空间时，如提示下面的错误提示：
[ceph_deploy][ERROR ] RuntimeError: bootstrap-osd keyring not found; run 'gatherkeys'
可以使用如下命令修复文件，重新配置ceph的密钥文件：
[root@node1 ceph-cluster]#  ceph-deploy gatherkeys node1 node2 node3 


步骤四：验证测试

1) 查看集群状态。
[root@node1 ~]#  ceph  -s


2）常见错误（非必须操作）。
如果查看状态包含如下信息：
health: HEALTH_WARN
        clock skew detected on  node2, node3…  


clock skew表示时间不同步，解决办法：请先将所有主机的时间都使用NTP时间同步！！！
Ceph要求所有主机时差不能超过0.05s，否则就会提示WARN，如果使用NTP还不能精确同步时间，可以手动修改所有主机的ceph.conf，在[MON]下面添加如下一行：
mon clock drift allowed = 1
如果状态还是失败，可以尝试执行如下命令，重启ceph服务：
[root@node1 ~]#  systemctl restart ceph\*.service ceph\*.target


************************************************************************

部署Ceph集群
yum -y install ceph-deploy
ceph-deploy --help

1.部署Ceph-mon
ceph-deploy new node1 node2 node3
yum -y install ceph-mon  ceph-osd  ceph-mds	 ceph-radosgw
ceph-deploy mon create-initial
2.部署ceph-osd
有磁盘，格式化，启动共享
/dev/vdb1，vdb2
ceph-deploy disk zap node1：vdc node1：vdd
ceph-deploy osd create node1:vdc:/dev/vdb1 node1:/dev/vdb2


*************************************************************************
ceph共享池( rbd)
	【共享镜像，共享镜像，共享镜像】(共享)

3 案例3：创建Ceph块存储
3.1 问题

沿用练习一，使用Ceph集群的块存储功能，实现以下目标：
创建块存储镜像
客户端映射镜像
创建镜像快照
使用快照还原数据
使用快照克隆镜像
删除快照与镜像

3.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：创建镜像

1）查看存储池。
[root@node1 ~]# ceph osd lspools
0 rbd,

2）创建镜像、查看镜像
[root@node1 ~]# rbd create demo-image --image-feature  layering --size 10G
[root@node1 ~]# rbd create rbd/image --image-feature  layering --size 10G

#这里的demo-image和image为创建的镜像名称，可以为任意字符。
#--image-feature参数指定我们创建的镜像有哪些功能，layering是开启COW功能。
#提示：ceph镜像支持很多功能，但很多是操作系统不支持的，我们只开启layering。
[root@node1 ~]# rbd list
[root@node1 ~]# rbd info demo-image
rbd image 'demo-image':
    size 10240 MB in 2560 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3aa2ae8944a
    format: 2
    features: layering


MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
**********************************************************************************
//////////////////////////////////////////////////////////////////////////////////////////
**********************************************************************************
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

cow 写时复制

rbd create 创建镜像
客户端rbd map访问镜像

kvm
真实主机  /etc/libvirt/qeumu/xx.xml
		/var/lib/libvirt/images/xx.img			在虚拟机的数据存在这个文件里			
		//每建一台虚拟机，多这两个文件


1 案例1：块存储应用案例
1.1 问题

延续Day03的实验内容，演示块存储在KVM虚拟化中的应用案例，实现以下功能：
Ceph创建块存储镜像
客户端安装部署ceph软件
客户端部署虚拟机
客户端创建secret
设置虚拟机配置文件，调用ceph存储
1.2 方案

使用Ceph存储创建镜像。
KVM虚拟机调用Ceph镜像作为虚拟机的磁盘。
	

1.3 步骤

实现此案例需要按照如下步骤进行。
1）创建磁盘镜像。
[root@node1 ~]# rbd create vm1-image --image-feature  layering --size 10G
[root@node1 ~]# rbd  list
[root@node1 ~]# rbd  info  vm1-image


2）Ceph认证账户（仅查看即可）。
Ceph默认开启用户认证，客户端需要账户才可以访问，默认账户名称为client.admin，key是账户的密钥。
可以使用ceph auth添加新账户（案例我们使用默认账户）。
[root@node1 ~]# cat /etc/ceph/ceph.conf                    //配置文件 
[global]
mon_initial_members = node1, node2, node3
mon_host = 192.168.2.10,192.168.2.20,192.168.2.30
auth_cluster_required = cephx                                //开启认证
auth_service_required = cephx                                //开启认证
auth_client_required = cephx                                //开启认证
[root@node1 ~]# cat /etc/ceph/ceph.client.admin.keyring        //账户文件
[client.admin]
    key = AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==

3）创建KVM虚拟机（注意：这里使用真实机当客户端！！！）。
使用virt-manager创建2台普通的KVM虚拟机。
4）配置libvirt secret（注意：这里使用真实机当客户端！！！）。
编写账户信息文件，让KVM知道ceph的账户名称。

[root@room9pc01 ~]# vim secret.xml            //新建临时文件，内容如下 
<secret ephemeral='no' private='no'>
        <usage type='ceph'>
                <name>client.admin secret</name>
        </usage>
</secret>
#使用XML配置文件创建secret
[root@room9pc01 ~]# virsh secret-define secret.xml
733f0fd1-e3d6-4c25-a69f-6681fc19802b       
//随机的UUID，这个UUID对应的有账户信息

给secret绑定admin账户的密码，密码参考ceph.client.admin.keyring文件。
[root@room9pc01] virsh secret-set-value \
--secret 733f0fd1-e3d6-4c25-a69f-6681fc19802b \
--base64 AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg
//这里secret后面是之前创建的secret的UUID
//base64后面是client.admin账户的密码
//现在secret中既有账户信息又有密钥信息


6）虚拟机的XML配置文件。
每个虚拟机都会有一个XML配置文件，包括：
虚拟机的名称、内存、CPU、磁盘、网卡等信息。
[root@room9pc01 ~]# vim /etc/libvirt/qemu/vm1.xml
//修改前内容如下
<disk type='file' device='disk'>
      <driver name='qemu' type='qcow2'/>
      <source file='/var/lib/libvirt/images/vm1.qcow2'/>
      <target dev='vda' bus='virtio'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
    </disk>


不推荐直接使用vim修改配置文件，推荐使用virsh edit修改配置文件，效果如下：
[root@room9pc01] virsh edit vm1                //vm1为虚拟机名称
<disk type='network' device='disk'>
      <driver name='qemu' type='raw'/>
      <auth username='admin'> 
      <secret type='ceph' uuid='733f0fd1-e3d6-4c25-a69f-6681fc19802b'/>
      </auth>
      <source protocol='rbd' name='rbd/vm1-image'>          <host name='192.168.4.11' port='6789'/>     </source>
    <target dev='vda' bus='virtio'/>
      <address type='pci' domain='0x0000' bus='0x09' slot='0x08' function='0x0'/>
 </disk>
注意：如果有设备编号冲突的情况下，需要修改设备编号，任意修改一个数字即可。

***********************************************************************************
***********************************************************************************

文件系统【格式化】ext3，ext4，xfs，ntfs
inode(256)		元数据（metadata） 数据的数据
block(4k)		数据

块共享
	客户端/dev/rbd0	格式
文件系统共享

yum -y install ceph-mon ceph-osd ceph-mds ceph-radosgw
ceph-deploy new node1 node2 node3
ceph-deploy mon creare-initial
deph-deploy osd create node1 node2 node3
ceph-deploy mds create node3
ceph-deploy rgs create node3

--------------------------------------------------------------------------------------
yum y install ceph-mds
ceph-deploy mds create node3
文件系统【inode+block】
ceph osd pool create 池（inode）
ceoh osd pool create 池（block）
ceph fs new inode + block

mount -t ceph 192.168.4.11:6789:/ /mnt -o name=admin,secret=AQBsY...

-------------------------------------------------------------------------------------------

2 案例2：Ceph文件系统
2.1 问题

延续前面的实验，实现Ceph文件系统的功能。具体实现有以下功能：
部署MDSs节点
创建Ceph文件系统
客户端挂载文件系统

2.3 步骤

实现此案例需要按照如下步骤进行。
1）添加一台新的虚拟机，要求如下：
IP地址:192.168.4.14
主机名:node4
配置yum源（包括rhel、ceph的源）
与Client主机同步时间
node1允许无密码远程node4

2）部署元数据服务器
登陆node4，安装ceph-mds软件包
[root@node4 ~]# yum -y install ceph-mds 
登陆node1部署节点操作
[root@node1 ~]# cd  /root/ceph-cluster
//该目录，是最早部署ceph集群时，创建的目录

-------练习环境从这里开始：----------

[root@node1 ceph-cluster]# ceph-deploy mds create node4
//给nod4拷贝配置文件，启动mds服务


同步配置文件和key
[root@node1 ceph-cluster]# ceph-deploy admin node4
3）创建存储池
[root@node4 ~]# ceph osd pool create cephfs_data 128
//创建存储池，对应128个PG
[root@node4 ~]# ceph osd pool create cephfs_metadata 128
//创建存储池，对应128个PG

5）创建Ceph文件系统
[root@node4 ~]# ceph mds stat                     //查看mds状态
e2:, 1 up:standby
[root@node4 ~]# ceph fs new myfs1 cephfs_metadata cephfs_data
new fs with metadata pool 2 and data pool 1
//注意，先写medadata池，再写data池
//默认，只能创建1个文件系统，多余的会报错

[root@node4 ~]# ceph fs ls
name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
[root@node4 ~]# ceph mds stat
e4: 1/1/1 up {0=node4=up:creating}

6）客户端挂载
[root@client ~]# mount -t ceph 192.168.4.11:6789:/  /mnt/cephfs/ \
-o name=admin,secret=AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==
//注意:文件系统类型为ceph
//192.168.4.11为MON节点的IP（不是MDS节点）
//admin是用户名,secret是密钥
//密钥可以在/etc/ceph/ceph.client.admin.keyring中找到


*******************************************************************************
*******************************************************************************

对象存储（百度云盘）

3 案例3：创建对象存储服务器
3.1 问题

延续前面的实验，实现Ceph对象存储的功能。具体实现有以下功能：
安装部署Rados Gateway
启动RGW服务
设置RGW的前端服务与端口
客户端测试
3.2 步骤

步骤一：部署对象存储服务器

1）准备实验环境，要求如下：
IP地址:192.168.4.15
主机名:node5
配置yum源（包括rhel、ceph的源）
与Client主机同步时间
node1允许无密码远程node5
修改node1的/etc/hosts，并同步到所有node主机
2）部署RGW软件包
[root@node1 ~]# ceph-deploy install --rgw node5
同步配置文件与密钥到node5
[root@node1 ~]# cd /root/ceph-cluster
[root@node1 ~]# ceph-deploy admin node5
3）新建网关实例
启动一个rgw服务
[root@node1 ~]# ceph-deploy rgw create node5
登陆node5验证服务是否启动
[root@node5 ~]# ps aux |grep radosgw
ceph      4109  0.2  1.4 2289196 14972 ?       Ssl  22:53   0:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.node4 --setuser ceph --setgroup ceph
[root@node5 ~]# systemctl  status ceph-radosgw@\*
4）修改服务端口
登陆node5，RGW默认服务端口为7480，修改为8000或80更方便客户端记忆和使用
[root@node5 ~]#  vim  /etc/ceph/ceph.conf
[client.rgw.node5]
host = node5
rgw_frontends = "civetweb port=8000"
//node5为主机名
//civetweb是RGW内置的一个web服务
步骤二：客户端测试（扩展选做实验）

1）curl测试
[root@client ~]# curl  192.168.4.15:8000
<?xml version="1.0" encoding="UTF-8"?><ListAllMyBucketsResult xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><Owner><ID>anonymous</ID><DisplayName></DisplayName></Owner><Buckets></Buckets></ListAllMyBucketsResult>
2）使用第三方软件访问
登陆node5（RGW）创建账户
[root@node5 ~]#  radosgw-admin user create \
--uid="testuser" --display-name="First User"
… …
"keys": [
        {
            "user": "testuser",
            "access_key": "5E42OEGB1M95Y49IBG7B",
            "secret_key": "i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6"
        }
    ],
... ...
#
[root@node5 ~]# radosgw-admin user info --uid=testuser
//testuser为用户，key是账户访问密钥
3）客户端安装软件
[root@client ~]#  yum install s3cmd-2.0.1-1.el7.noarch.rpm
修改软件配置（注意，除了下面设置的内容，其他提示都默认回车）
[root@client ~]#  s3cmd --configure
Access Key: 5E42OEGB1M95Y49IBG7BSecret Key: i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6
S3 Endpoint [s3.amazonaws.com]: 192.168.4.15:8000
[%(bucket)s.s3.amazonaws.com]: %(bucket)s.192.168.4.15:8000
Use HTTPS protocol [Yes]: No
Test access with supplied credentials? [Y/n] n
Save settings? [y/N] y
//注意，其他提示都默认回车
4）创建存储数据的bucket（类似于存储数据的目录）
[root@client ~]# s3cmd ls
[root@client ~]# s3cmd mb s3://my_bucket
Bucket 's3://my_bucket/' created
[root@client ~]# s3cmd ls
2018-05-09 08:14 s3://my_bucket
[root@client ~]# s3cmd put /var/log/messages s3://my_bucket/log/
[root@client ~]# s3cmd ls
2018-05-09 08:14 s3://my_bucket
[root@client ~]# s3cmd ls s3://my_bucket
DIR s3://my_bucket/log/
[root@client ~]# s3cmd ls s3://my_bucket/log/
2018-05-09 08:19 309034 s3://my_bucket/log/messages 
测试下载功能
[root@client ~]# s3cmd get s3://my_bucket/log/messages /tmp/
测试删除功能
[root@client ~]# s3cmd del s3://my_bucket/log/messages

#################################################
ceph中文文档
http://docs.ceph.org.cn/  
#################################################

MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*******************************************************************************
///////////////////////////////////////////////////////////////////////////////////////
*******************************************************************************
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW


常见服务器品牌包括：IBM服务器、Dell服务器、HP服务器、浪潮服务器、华为服务器。

与普通电脑一样，服务器也是由主板、内存、CPU、磁盘、网卡、显卡、电源、主机箱等硬件设备组成。
服务器分为塔式服务器、机架式服务器、刀片服务器。
RAID是Redundant Arrays of Independent Drives（独立冗余磁盘阵列）的简称，RAID分为很多级别，常用级别有RAID0、RAID1、RAID5、RAID6、RAID10、RAID01。


ECC带校验功能内存条

异或算法
0 0 错0
0 1 对1
1 0 对1
1 1 错0

ups电池

1）CPU
英特尔：酷睿八代（i3,i5,i7,i9），酷睿九代(i3,i5,i7,i9)
至强E（标准版），至强W（高功耗版）
奔腾处理器
AMD：	家用版（锐龙、速龙）
服务器版本（皓龙、霄龙）
2) 内存
常见品牌：金士顿、三星
家用普通内存不具有数据校验功能
服务器配置带ECC数据校验功能的内存条
规格：DDR1、DDR2、DDR3、DDR4、DDR5
3）硬盘
常见品牌：三星、英特尔、希捷、西部数据
家用磁盘接口：SATA
服务器磁盘接口：SAS
SSD固态硬盘
大小：2.5寸、3.5寸
4）远程管理设备
Dell：	iDRAC
HP：	iLO
IBM：	Tivoli/ˈtɪvəli/


Write Through	直写
Write Back		回写
write through模式时数据同时被写入缓存和磁盘，安全，但是写入速度慢
write back模式时数据先写入缓存，再写入磁盘，写入速度快，但数据写入缓存时突发断电会导致数据丢失



idrac:
1.配置网络参数，序列号（要钱）
   账户密码
浏览器使用图形操作

2.端口重定向（不要钱）
  idrack网络参数
    账户和密码
缺点：没有图形界面


idrac setting
newwork 
		LOM1/LOM2/LOM3/LOM4
		


Dell服务器iDRAC远程管理配置

1）配置端口重定向
iDRAC（Integrated Dell Remote Access Controller），是戴尔服务器集成的远程控制卡。
iDRAC需要授权使用，有授权的情况下可以直接通过浏览器访问：http://服务器IP，远程管理服务器，没有授权的情况下可以通过端口重定向将服务器上的显示内容重定向到远程管理端的电脑上（一般是用自己的笔记本远程服务器），这种方式不需要授权。
开启服务器后根据提示快速按F2键进入BIOS界面

进入BIOS Settings后，选择Serial Communication菜单
将控制台重定向到com2，设置Serial Device=com1，Serial Device=com2

2）初始化清空iDRAC设置
进入iDRAC Setting界面选择Rest iDRAC configuration to defaults

3）配置iDRAC网络
进入iDRAC Setting界面选择network
选择网卡并配置IP地址,网段需要根据实际情况自行配置。
开启IPMI智能平台管理接口（配置后可以通过命令行管理服务器），客户端安装ipmitool软件包

4）配置远程管理账户
进入iDRAC Setting界面选择User Configuration
配置账户名称root，并设置密码


*****************************************************************************

目前主流的建站模板：
	Wordpress、帝国、织梦等系统，而word press是目前市场占有率最高的一款产品
************************************************************************

MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*******************************************************************************
///////////////////////////////////////////////////////////////////////////////////////
*******************************************************************************
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

基础架构（硬件+系统）
平台（LNMP，java+tomcat）
软件（Java代码，php代码，python代码）

Iaas云（基础架构）	阿里云，华为	云主机，虚拟机永远都不会坏（是由两文件组成）
PasS云（平台）	openshift云  google云
SaaS云（软件）	百度云盘

耦合
	web --database
	静态
	动态
	调度
	储存nfd--ceph
解耦
	业务
微服务【docker容器】

灰度发布，蓝绿发布

lnmp lnp---mysql
	迁移数据（锁）主从


NFS使用的是随机端口


高可用网站架构的设计与实现方案

nfs,ceph(更新)
rm vim
git(版本控制)svn
修改，提交，修改提交1--20
md5sum
CI/CD（支持git）
持续集成/持续部署
开发---git（inotify）--->test--->服务器（虚拟机），docker容器		




Nginx 静态处理性能比 Apache 高 3倍以上
轻量级，同样起web 服务，比apache 占用更少的内存及资源 
nginx的负载能力比apache高很多


MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
***********************************************************************************
///////////////////////////////////////////////////////////////////////////////////////////
***********************************************************************************
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
CPU > 内存 > 磁盘 > 数据库
复杂的查询
元数据（描述数据的数据）
表，图片表（表头）
名称	     时间    大小  分辨路       描述   地址
a.jpg  2019  4M  800*600  风景	  广州	

排名前四的数据库：
Oracle	mysql	PostgreSQL	SQLserver



专业术语
DB（DataBase）
	-数据库
	-依照某种数据模型进行组织并存放到存储器的数据集合

DBMS（DataBase Management System）
	-数据库管理系统
	-用来操纵和管理数据库的服务软件

DBS（DataBase System）
	-数据库系统：即DB+DBMS
	-指带有数据库并整合了数据管理软件的计算机系统


*******************************************************************************
*******************************************************************************

案例一:安装部署MySQL
1.准备工作(非必须的操作):
关闭防火墙(如果有的话)
关闭SELinux(如果有的话)
如果之前有mariadb,则需要先卸载,并删除对应的配置与数据:
systemctlstop mariadb
rm-rf /etc/my.cnf
rm -rf /var/lib/mysql/*
rpm -e --nodeps mariadb mariadb-server mariadb-devel
2.安装部署MySQL
[root@mysql50 ~]# tar -xf mysql-5.7.17.tar
[root@mysql50 ~]# yum -y install mysql-community*
3.启动服务
[root@mysql50 ~]# systemctl start mysqld
提示:第一次启动,需要初始化数据,会比较慢
[root@mysql50 ~]# systemctl status mysqld
[root@mysql50 ~]# systemctl enable mysqld


4.mysql主要参数

etc/my.cnf MySQL		主配置文件
/var/lib/mysql 		数据库目录
3306 				默认端口号
mysqld MySQL			主进程名称
TCP 				传输协议
msyql:mysql 			进程所有者与所属组
/var/log/mysqld.log 	错误日志文件


5.配置MySQL管理员密码(默认数据库管理员账户为root)
第一次启动时,mysql会自动为root账户配置随机密码,我们需要通过日志查看该密码
[root@mysql50 ~]# grep password /var/log/mysqld.log
2018-12-25T12:43:41.164573Z 1 [Note] A temporary password is generated for root@localhost:cvAd3af8a<j?
[root@mysql50 ~]# mysql-uroot -p'cvAd3af8a<j?'
mysql> show databases;
ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.
注意:用该密码登录到服务端后,必须马上修改密码,不然会报上面的错误。


策略参数							值			  描述
validate_password_policy		0 或者 LOW		 长度
							1 或者 MEDIUM(默认)  长度;数字、大写、小写,特殊符
							2 或者 STRONG		 长度;数字、大写小写,特殊符号;字典文件


mysql>set global validate_password_policy=0;
//只验证长度
Query OK, 0 rows affected (0.00 sec)
mysql>set global validate_password_length=6;
//修改密码长度,默认值是8个字符
Query OK, 0 rows affected (0.00 sec)
mysql>alter user user() identified by "123456";
//修改登陆密码
Query OK, 0 rows affected (0.00 sec)
修改密码后,可以数据库命令了!
mysql>show databases;

永久设置:
# vim /etc/my.cnf
//修改配置添加如下内容
[mysqld]
validate_password_policy=0
validate_password_length=6


案例二:数据库基本管理
1.数据库操作基本流程
✓ 连接登陆数据库
✓ 创建数据库
✓ 创建数据表
✓ 插入数据记录
✓ 断开连接
连接 MySQL 的方法:命令行、Web 网页、安装图形软件、编写脚本(PHP、java...)

连接MySQL数据库的命令语法格式:
[root@mysql50 ~]# mysql	[-h服务器IP或域名	-u用户名	-p密码	数据库名称]
quit 或者 exit 退出数据库
[root@mysql50 ~]# mysql-h 127.0.0.1 -uroot
-p123456
注意事项:
操作指令不区分大小写(密码和变量除外)
每条SQL语句都以分号;结束
默认不支持Tab键补齐
\c 可以取消书写错误的命令
常用的SQL命令分类:
DDL数据定义语言(create,alter,drop)
DML数据操作语言(insert,update,delete)
DCL数据控制语言(grant,revoke)
DTL 数据事务语言(commit,rollback,savepoint)



注意事项:
操作指令不区分大小写(密码和变量除外)
每条SQL语句都以分号;结束
默认不支持Tab键补齐
\c 可以取消书写错误的命令

常用的SQL命令分类:
DDL数据定义语言(create,alter,drop)
DML数据操作语言(insert,update,delete)
DCL数据控制语言(grant,revoke)
DTL 数据事务语言(commit,rollback,savepoint)

2.数据库相关指令练习
mysql> show databases;
#查看数据库
mysql> usemysql;
#切换数据库
mysql> select database();
#查看当前数据库
+------------+
| database()|
+------------+
| mysql|
+------------+
1 row in set (0.00 sec);
mysql> create database tts character set utf8mb4;
mysql> drop database tts;
#创建数据库
#删除数据库

提示:数据库命名规则
(数字、字母、下划线,不能纯数字;区分大小写;不能使用关键词或特殊符号)

3.数据表相关指令练习
创建数据表基本语法格式如下:
create table 数据库名称.数据表名称(
字段名1 数据类型(宽度) 约束条件,
字段名2 数据类型(宽度) 约束条件,
... ...
);

mysql> show character set;							#查看所有可用编码
mysql> create database school character set utf8mb4;	#创建数据库
mysql> create table school.student(
学号	char(20),
姓名	char(20),
性别	char(5),
手机	int(11),
通信地址 	char(50));

查看数据表结构语法格式:desc数据表名称;
mysql> desc school.student;

插入数据的语法格式:insert into 数据库名称.数据表名称 values (值列表);
mysql> insert into school.student values('NSD181001','葫芦娃','男',1388888888,'北京');
一次插入1条数据.
mysql> insert into school.student values('NSD181002','蛇精','女',1389999999,'上海'),
('NSD181003','爷爷','男',1387777777,'长白山');
一次插入多条数据(多条数据使用逗号分隔)

查看数据:
mysql> select * from school.student;

更新数据语法格式:update 数据库名称.数据表名称 set 字段=值 [where条件]
mysql> update school.student set 性别='女';					#更新所有数据
mysql> update school.student set 性别='男'，where 姓名='葫芦娃';	#更新满足条件的数据

删除数据:
mysql> delete from school.student where 学号='NSD181003';	#删除表中满足条件的数据
mysql> delete from school.student;						#删除表中所有数据

删除数据表:
mysql> drop table school.student;		#删除整个数据表



案例三:MySQL 数据类型
数值型:体重、身高、成绩、工资、金额
字符型:姓名、地址、单位、邮箱
枚举型:爱好、性别、专业
日期时间型:出生日期、注册时间

1. 字符类型
类型				描述
char(字符数)   	固定长度,最大长度255字符,不够指定的字符数时自动在右边填补空格,超
				出指定字符数则无法写入。
varchar(字符数) 	可变长度,根据实际数据大小分配存储空间,超出指定字符数则无法写入。
text/blob 		字符数大于65535时使用。

mysql> create table school.info(
	   name char(4),
	   email varchar(30));
Query OK, 0 rows affected (0.32 sec)
mysql> desc school.info;
mysql> insert into school.info values('tom','tom@163.com');
Query OK, 1 row affected (0.06 sec)		#注意:字符串需要使用引号!
mysql> select * from school.info;

mysql> insert into school.info values('aaaaaaaaaaaaaaaaaaa','tom@163.com');
ERROR 1406 (22001): Data too long for column 'name' at row 1
#超过了指定的 4 个字符,写入失败。
char(4)如果实际写入了 2 个字符,但是占用的空间是 4 个字符.
varchar(30)如果实际写入了 2 个字符,实际仅占用 2 个字符的空间.


2.数值类型
类型 		范围(有符号) 			范围(无符号) 	用途
tinyint 		-128~127 			0~255 		微小整数
smallint 	-32768~32767 		0~65535 		小整数
mediumint	-2(*23) ~2(*23)-1 	0~2(*24)-1	中整数
int			-2 ~2 -1	 (31)		0~2 -1(32)	大整数
bigint		-2 ~2 -1	 (63)		0~2 -1(64)	极大整数
float		-2 ~2 -1	 (31)		0~2 -1(32)	单精度浮点数(M,D)
double		-2 ~2 -1	 (63)		0~2 -1(64)	双精度浮点数(M,D)
#(M,D),其中 M 为总宽度,D 为小数位数,M 应大于 D
#使用 unsigned 标记无符号存储

mysql> create table school.num(
id tinyint,
age int(3),
score float(4,2));

mysql> desc school.num;


mysql> insert into school.num values(1111,22,11.2);
ERROR 1264 (22003): Out of range value for column 'id' at row 1
#提示值超出范围(tinyint 只能存-128~127 或者 0~255 之间的值,默认为有符号)。

mysql> insert into school.num values(130,22,11.2);
ERROR 1264 (22003): Out of range value for column 'id' at row 1
#130 也提示错误,因为默认使用的是有符号的存储,如果需要无符号需要创建表时添加 unsigned 标记

mysql> insert into school.num values(-125,22,11.2);
Query OK, 1 row affected (0.06 sec)
#正确

mysql> insert into school.num values(-125,22,143.434);
ERROR 1264 (22003): Out of range value for column 'score'at row 1
提示:错误,小数的总长度为 4 位,也就是整数为 2 位,小数为 2 位。当整数写 3 位就报错。

mysql> insert into school.num values(-125,22,14.43);
Query OK, 1 row affected (0.02 sec)

mysql> insert into school.num values(-125,22,1.40223444);
Query OK, 1 row affected (0.01 sec)
mysql> select * from school.num;
#1.40223444 最终查询结果为 1.40
提示:不报错误,整数位合法,小数位超出,系统会自动把多余的删除,进行四舍五入。

#创建表格时可以使用 unsigned 标记为无符号数据类型
mysql> create table school.num2(id tinyint unsigned, age int(3), score float(4,2));
Query OK, 0 rows affected (0.23 sec)

mysql> insert into school.num2 values(255,22,22.34);
Query OK, 1 row affected (0.03 sec)


3. 日期时间类型
datetime日期时间类型,范围1000-01-01 00:00:00:000000~9999-12-31 23:59:59.999999
如果不给该类型的数据赋值,则默认为NULL

timestamp日期时间类型,范围1970-01-01 00:00:00:000000~2038-01-19 03:14:07.999999
如果不给该类型的数据赋值,则mysql自动为其分配当前的系统时间

date日期类型,范围0001-01-01~9999-12-31
默认使用4位数字表示,当只用2位数字负值时:
01~69自动识别为2001~2069
70~99自动识别为1970~1999

year年份类型,范围1901-2155
time时间类型,范围HH:MM:SS


时间函数
MySQL服务内置命令
-可以使用时间函数给字段赋值
curtime（）	获取当前的系统时间
curdate（）	获取当前的系统日期
now（）		获取当前系统日期和时间
year（）		获取年
month（）	获取月
day（）		获取日
date（）		获取日期
time（）		获取时间

4. 枚举类型(选择类型)
enum(值1,值2,值3...) #单选项
set(值 1,值 2,值 3...)
#多选项
mysql> create table school.tea(
name char(5),
gender enum('boy','girl'),
interest set('book','film','music','football'),
);

mysql> descschool.tea;
mysql> insert into school.teavalues('tom','man','it,boot')
错误,超出了可选择的范围
mysql> insert into school.teavalues('tom','boy','book,film')
正常写入

数据库
密码: grep password /var/log/mysqld.log
登录: mysql -u root -p
改密码: set global validate_password_policy=0;
	set global validate_password_length=6;
	alter user user() identified by "123456";
永久设置: vim /etc/my.cnf
	validate_password_policy=0
	validate_password_length=6
查看当前数据库: select database();
创建数据库:	create database tts character set utf8mb4;
删除数据库:	drop database tts;
查看所有可用编码:  show character set;

创建表:
create table school.student(
学号  	 char(20),
姓名  	 char(20),
性别 	 enum('男','女'),
手机号   int(11),
通信地址 char(50));

创建表:
create table myself1(name char(20),age tinyint unsigned, sex enum('boy','girl'));

创建表:
mysql> create table t7(
    -> name char(8) not null,
    -> age tinyint unsigned default 20,
    -> class char(20) not null default "nsd1904",
    -> sex enum('man','woman') default 'man',
    -> pay float(7,2) default 28000
     -> );


查看数据表结构: desc school.student;
插入数据:	insert into school.student values('NSD181001','葫芦娃','男',1388888888,'北京');
查看数据:	select * from school.student;
更新数据:	update school.student set 性别='男' where 姓名='葫芦娃';
删除数据:	delete from school.student where 学号='NSD181003';
删除表中所有数据: delete from school.student;
删除数据表:	drop table school.student;
枚举类型(选择类型):  	enum(值1,值2,值3...)  #单选项
			set(值 1,值 2,值 3...) #多选项
create table school.tea(
name char(5),
gender enum('boy','girl'),
interest set('book','film','music','football'));
几个mysql内置的时间函数: 
now()
sysdate()
date() 范围0001-01-01~9999-12-31
year() 范围1901-2155
time() 范围HH:MM:SS

往表结构添加:   		alter table myself add homeaddr char(50) not null default 'gz' first;
往表结构后添加: 		alter table myself add homeaddr char(50) after name;	
修改字段位置: 			alter table myself modify sex enum('boy','girl') after name;
修改表结构字段类型:		alter table myself modify name varchar(25);
修改表结构字段名称及类型:	alter table myself change age num char(20);
删除字段:			alter table myself drop num;
修改表名:			alter table myself rename school;
更新表里的名称:		update t9 set 员工_id=8 where 员工_id=2;

新建索引:
    -> index(name),
    -> index(id)
添加索引:	create index yyy on tea4(name);
查看索引:	show index from tea4\G;
删除索引:	drop index yyy on tea4;

建表时创建主键:			create table t8(name char(3) primary key,id int);
在已有表里添加主键:			alter table t8 add primary key (name);  数据不能有重复项
删除主键:				alter table t8 drop primary key
建表时添加复合主键:			create table t5(name char(10),class char(10),status enum('no','yes'),primary key(name,class));
主键可以与auto_increment;连用:	create table t6( id int primary key auto_increment, name char(10), age int, sex enum('w','m'));
			验证:	 	insert into t6(name,age,sex) values('tom',null,w);
建表时创建外键:			create table t9(员工_id int primary key auto_increment,name char(20))engine=innodb;
查看建表时命令:			show create table t9\G
创建外键:				create table gzb(gz_id int,pay float(7,2),foreign key(gz_id) references t9(员工_id) on update cascade on delete 					cascade)engine=innodb;
使用外键时,必须原表里有相同的字段:	insert into gzb values(1,50000);
删除外键:				alter table gzb drop foreign key gzb_ibfk_1;

庞老师
静静
   panglj@tedu.cn

tmooc  PPT   案例1 

++++++RDBMS1-DAY01
1 数据库相关概念？ 
2 搭建MySQL数据库服务器？ 装包 修改配置文件 启动服务 登陆
3 数据库服务的基本使用？ 库 表 记录 select delete update insert
4 mysql数据库类型


++++++RDBMS1-DAY02
连接数据库服务器 
创建db2库

在db2库 
里创建 myself 表  有3个字段 分别是
name 姓名
age 年龄
sex 性别

把自己的信息记录到表里
				时间10分钟 到 09：18 
mysql> create database db2;
mysql> use db2;
mysql> create table myself(name char(20), age tinyint unsigned,sex  enum("boy","girl") );

mysql> insert into  myself values("yaya",19,"girl");
mysql> select * from  myself;


一、表结构
	1.1 字段约束条件  (控制字段赋值) Null | Key | Default | Extra


	1.2 修改表结构
		alter  table  表名  执行动作；
		add(after/first) modify  change  drop  rename

二、mysql键值
	普通索引 index   *** 使用规则 使用（创建查看删除）
	唯一索引 unique
	主键 primary key ***使用规则 使用（创建查看删除）
	外键 foreign key ***使用规则 使用（创建查看删除）
	全文索引 fulltext	

PRI   PRI
姓名  班级  	缴费状态
name class   	status
bob   nsd1904   no
员工信息表yginfo
  员工编号     姓名
    yg_id      name
	1      bob
	2      alice
	3      tom
create table  yginfo(
yg_id int primary key auto_increment,
name  char(20)
)engine=innodb;

insert into  yginfo(name)values("bob");
insert into  yginfo(name)values("alice");
insert into  yginfo(name)values("tom");

select  * from yginfo;

工资表 gzb
      gz_id  pay
     员工编号  工资 
	
create table gzb(
gz_id int,
pay  float(7,2),
foreign key(gz_id) references yginfo(yg_id) on update cascade 
on delete cascade
)engine=innodb;

show create table gzb\G;

+++++++++++RDBMS1_DAY03
1、数据导入导出
	检索目录
		查看默认检索目录
		mysql> show variables like  "secure_file_priv";
		修改检索目录
			]# mkdir  /myload  
			]# chown  mysql  /myload
			]# vim  /etc/my.cnf
     			[mysqld]
     			secure_file_priv="/myload“
			:wq
			]# systemctl  restart mysqld
		mysql> show variables like  "secure_file_priv";

	数据导入:把系统文件的内容存储到表里

		 命令：mysql>  load  data  infile   "目录名/文件名" 
into   table  库名.表名 fields terminated   by   "分隔符" lines  terminated  by   "\n";

		例子：把/etc/passwd 文件的内容存储到db3库下的user表里。

mysql> create database db3;
Query OK, 1 row affected (0.00 sec)

mysql> use db3;

			mysql> create table  user(
    -> name char(50),
    -> password char(1),
    -> uid int,
    -> gid int,
    -> comment char(150),
    -> homedir  char(100),
    -> shell  char(100)
    -> );

mysql> system  cp /etc/passwd  /myload/

mysql> load data infile "/myload/passwd" into table db3.user  fields terminated by  ":" lines terminated by  "\n";

mysql> alter table db3.user add  id int primary key  auto_increment first;

mysql> select  * from db3.user where  id=1;
mysql> select  * from db3.user where  id<=5;
		10:10 上课。

	数据导出: 把表记录保存到系统文件里。
	
	命令1 mysql>  SQL查询命令 into  outfile  "目录/文件名" ；

	命令2 mysql>  SQL查询命令 into  outfile  "目录/文件名" fields terminated by "分隔符"；

	命令3 mysql>  SQL查询命令 into  outfile  "目录/文件名" fields terminated by "分隔符"   lines   terminated   by   “\n” ；


mysql> select  * from db3.user where  id<=5 into outfile  "/myload/user.txt" ;

mysql> select  * from db3.user where  id<=5 into outfile  "/myload/user.txt" 
    -> fields terminated by "###"\c

mysql> select  name,shell,uid  from db3.user where id<=3  into outfile  "/myload/user3.txt" fields terminated by "###" lines  terminated by "?";

mysql>system  cat /myload/user.txt;
mysql>system  cat /myload/user1.txt;
mysql>system  cat /myload/user2.txt;
					练习到10：30 
2、管理表记录
	插入表记录 insert into 库.表 values(值列表);

mysql> 
insert into db3.user 
values(22,"bob","x",2000,2000,"test user","/home/bob","/bin/bash");

insert into db3.user 
values
(25,"tom","x",2001,2001,"test user","/home/tom","/bin/bash"),
(26,"lucy","x",2002,2002,"test user","/home/lucy","/bin/bash");

mysql> insert into db3.user(name)values("alice");

mysql> insert into db3.user(name)values("jerry"),("mack"),("rose");


	查询表记录 select * from  库.表;

		select   字段1, .. .., 字段N  from  库名.表名;

		mysql> select name,shell from db3.user;
		mysql> select * from db3.user;

select  字段1, .. , 字段N  from  库名.表名  where   条件表达式;
		
		mysql> select name,shell from db3.user where id <= 2 ;
		mysql> select * from db3.user where id <= 2 ;


	更新表记录 update  库.表 set 字段名=值；
		
mysql> select password,comment from db3.user;
mysql> update db3.user  set    password="a" , comment="student" ;
mysql> select password,comment from db3.user;

mysql> update db3.user set password="x" , comment="root" where name="root";
mysql> select password,comment from db3.user;
mysql> select  * from db3.user where name="root";

	练习时间 5分钟 到 11：33 

	删除表记录 delete from 库.表；
			mysql> select  * from db3.user;
			mysql> delete from db3.user where id >=25;
			mysql> delete from db3.user where id =23;

3、匹配条件
	3.1 基本匹配条件 （select  、update 、delete）
		数值比较: =  !=  >  >=  <  <=  

mysql> select name from db3.user where uid=20;
mysql> select name from db3.user where uid=0;
mysql> select name,uid from db3.user where uid<=10;

		字符比较: =  !=
mysql> select name from db3.user where  shell = "/bin/bash";
mysql> select name , shell from db3.user where  shell != "/bin/bash";


mysql> select name,comment from db3.user where name = comment;
mysql> select name,uid,gid from db3.user where uid = gid;
		is    null  空
		is not  null  非空
mysql> insert into  db3.user(name) values(null),(NULL),(""),("null");
mysql> select id, name  from db3.user  where name is not null;
mysql> select id, name  from db3.user  where name is  null;
		逻辑匹配(多个判断条件)
		逻辑与 and  或 &&    多个条件必须同时成立
		逻辑或 or  或  ||    多个条件某1个条件成立即可
		逻辑非 ！ not        取反
mysql> select name,uid from db3.user where name="root"  and  uid=3;
mysql> select name,uid from db3.user where name="root"  or  uid=3;
		范围内匹配
mysql> select name from db3.user where  name in ("adm","sync","mysql","bin");
mysql> select name,uid from db3.user where  uid in (12,70,23);
mysql> select name,shell from db3.user where shell not in ("/bin/bash","/sbin/nologin");
mysql> select  * from db3.user where uid between 10 and 20 ;
	去重显示		
mysql> select  distinct shell  from db3.user;
						练习15分钟到 14：35

	3.2 高级匹配条件
		模糊查询 like
		where 字段名 like  '表达式' ;
			_ 表示1个字符

			% 表示零个或多个字符

mysql> select name from db3.user where  name  like  '___';
mysql> select name from db3.user where  name  like  '____';
mysql> select name from db3.user where  name  like  '%a%';
mysql> select name from db3.user where  name  like  '__%__';

		正则表达式 regexp
		where 字段名  regexp   '正则表达式'
		^  $  .  *  []  |

mysql> select name from db3.user  where name  regexp '^a';
mysql> select name from db3.user  where name  regexp 't$';
mysql> select name from db3.user  where name  regexp '^a|t$';
mysql> select name from db3.user  where name  regexp '^r.*t$';
mysql> insert into  db3.user(name)values("yaya9"),("y8aya"),("ya6ya");
mysql> select name from  db3.user where name regexp '[0-9]';

		四则运算 + - * / %

mysql> alter table db3.user 
    -> add   system  int  default 80 ,
    -> add   mysql   int  default 80 ;

mysql> alter table db3.user 
    -> add  age  tinyint default 19 after name;

mysql> select  * from db3.user where name="root";

mysql> select name,age, 2019 - age  csyf  from db3.user ;

mysql> select name ,uid  from  db3.user where uid%2  =  0 ;
mysql> select name ,uid  from  db3.user where uid%2  !=  0 ;

mysql> select name,uid from db3.user where  uid  <=10;
mysql> update db3.user set  uid=uid+1 where uid  <=10;
		
		() 提高优先级
mysql> select name,system,mysql, system+mysql zfs , (system+mysql)/2 pzf  from db3.user where name="root";
		

	3.3  操作查询结果
		 1 聚集函数 (mysql服务内置对数据做统计的命令)
		avg() min() max() sum() count()

			mysql> select max(uid) from db3.user;
			mysql> select min(uid) from db3.user;
			mysql> select avg(uid) from db3.user;
			mysql> select sum(uid) from db3.user;
			
mysql> select name from  db3.user 
	   where shell not in ("/bin/bash","/sbin/nologin");

mysql> select count(name) from  db3.user 
           where shell not in ("/bin/bash","/sbin/nologin");

mysql> select  * from db3.user;
mysql> select  count(*) from db3.user;

		2 查询结果排序 order by  字段名  asc|desc

mysql> select name , uid  from  db3.user where  uid >= 10  and  uid <= 1000 ;


mysql> select name , uid  from  db3.user 
                where  uid >= 10  and  uid <= 1000  order by  uid;

mysql> select name , uid  from  db3.user
                where  uid >= 10  and  uid <= 1000  order by  uid desc ;

	     3  查询结果分组 group  by 字段名；
mysql> select   shell  from  db3.user;
mysql> select   shell  from  db3.user  group by shell;

mysql> select   shell  from  db3.user where  uid <= 500;
mysql> select   shell  from  db3.user where  uid <= 500 group by shell;

	    4 查询结果过滤 having 条件

mysql> select name  from  db3.user where  shell != "/bin/bash"

mysql> select name  from  db3.user where  shell != "/bin/bash"
	having  name="mysql";

	   5 限制查询结果显示行数 limit

mysql> select  id,name,shell,homedir  from  db3.user where uid <= 15;

mysql> select  id,name,shell,homedir  from  db3.user 
		where uid <= 15 limit 3;

mysql> select  id,name,shell,homedir  from  db3.user 
		where uid <= 15 limit 1;

mysql> select  id,name,shell,homedir  from  db3.user
		where uid <=15  limit 0,3;

mysql> select  id,name,shell,homedir  from  db3.user 
		where uid <=15  limit 3,3;

4、MySQL管理工具
	4.1 安装图形工具phpmyadmin

++++++RDBMS1_day04
	192.168.4.50   192.168.4.51
1、用户授权
	1.1 授权： 添加用户并设置权限
	1.2 命令格式 mysql> grant 
    grant  权限列表  on   库名  to  用户名@”客户端地址” 
    identified  by  “密码” //授权用户密码
    with  grant  option ;    //有授权权限 ,可选项

        1.3  授权库 mysql (授权信息)
		user表    记录已有的授权用户及权限

select host , user from  mysql.user;
show grants for  "mysql.sys"@"localhost";
mysql> show  grants  for  admin2@"localhost";


		db表       记录已有授权用户对数据库的访问权限
mysql> update mysql.db set Delete_priv="N"  where db="db3" and user="admin2" and host="localhost"\G;

mysql> flush privileges;

mysql> show  grants  for  admin2@"localhost"; 

mysql> select  * from  mysql.db  where db="db3" and user="admin2" and host="localhost"\G; 


		tables_priv表       记录已有授权用户对表的访问权限

mysql> select host , db  , user  ,table_name from  mysql.tables_priv;
		
mysql> select  * from  mysql.tables_priv where user="admin"\G;

mysql> show grants for  admin@"192.168.4.%";

		columns_priv表   记录已有授权用户对字段的访问权限
mysql> grant select,update(name , uid ) on  db3.user  to yaya99@"%"
    -> identified by "123qqq...A";

mysql> show grants for  yaya99@"%";

mysql> select  * from  mysql.columns_priv \G;
		
		1.4 删除授权用户
			mysql> drop user yaya99@"%" ;
			mysql> select user ,host from mysql.user;

		1.5 撤销权限 （删除用户的访问权限）
			命令格式：
			mysql> revoke  权限列表  on  库名.表   from    
             用户名@"客户端地址";

		mysql> revoke grant option on  *.* from mydba@"%" ;
		mysql> show  grants  for  mydba@"%" ;
		mysql> revoke  drop ,delete  on *.*  from  mydba@"%" ;
		mysql> show  grants  for  mydba@"%" ;
		mysql> revoke  all  on *.*  from  mydba@"%" ;
		mysql> show  grants  for  mydba@"%" ;

		1.4  恢复root密码   练习时间10分钟到 14：28
]# vim /etc/my.cnf
   [mysqld]
    skip-grant-tables
   :wq
]# systemctl restart mysqld

]# mysql
mysql> select user,host , authentication_string from mysql.user;
mysql> update  mysql.user set  authentication_string=password("aaa123...A")
       where user="root" and host="localhost";

mysql> flush privileges;
mysql> exit

]# vim /etc/my.cnf
    [mysqld]
      #skip-grant-tables
   :wq
]# systemctl restart mysqld
]# mysql -uroot -paaa123...A
mysql> show databases;
		1.5 修改数据库管理员root 用户本机登陆密码
		
[root@host50 ~]# mysqladmin  -uroot -p  password "123456"
Enter password: 	输入旧密码

	     ]# mysql  -uroot -p123456   //使用修改的密码登陆


2、完全备份
	2.1 相关概念
	
	2.2 物理备份与恢复  练习时间6分钟 到 15：01 
	           物理备份 192.168.4.50
]# mkdir /dbbak
]# cp  -r /var/lib/mysql  /dbbak/mysql.bak
]# ls /dbbak/mysql.bak/
]# scp -r /dbbak/mysql.bak  root@192.168.4.51:/root/

	           物理恢复 192.168.4.51
]# systemctl  stop mysqld
]# rm -rf /var/lib/mysql
]# cp -r /root/mysql.bak/  /var/lib/mysql
]# chown  -R mysql:mysql /var/lib/mysql
]# systemctl  start mysqld
]#mysql -uroot -p123qqq...A
mysql> show databases;	


	完全备份 mysqldump 
	]# mysqldump -uroot -p123qqq...A  --all-databases > /dbbak/all.sql
	]# mysqldump -uroot -p123qqq...A  db3 > /dbbak/db3.sql
	]# mysqldump -uroot -p123qqq...A  db3 user > /dbbak/db3_user.sql
	]# mysqldump -uroot -p123qqq...A  -B db3 db4 > /dbbak/twodb.sql

	]# ls /dbbak/*.sql

	]# cat /dbbak/db3.sql
	
	]# scp  /dbbak/twodb.sql  root@192.168.4.51:/root/
	完全恢复 192.168.4.51
	]# mysql -uroot -p123qqq...A
	mysql> drop  database  db3;
	mysql> drop  database  db4;
	mysql> show  databases;
	mysql> exit

	]# mysql -uroot -p123qqq...A <  /root/twodb.sql
	]# mysql -uroot -p123qqq...A
	mysql> show  databases;
	mysql> use db3;
	mysql> show  tables;
	mysql> select count(*) from user;

3、增量备份 (启用mysql服务的binlog日志文件)

	3.1 binlog日志的使用
		1、binlog日志介绍

		2、启用日志
	]# vim /etc/my.cnf
		[mysqld]
		server_id=50
		log-bin
	:wq

	]# systemctl  restart mysqld
	]# cd /var/lib/mysql
	]# ls  *-bin.*
host50-bin.000001  host50-bin.index

		3、手动创建新的日志文件
   ]# systemctl  restart mysqld
   ]# systemctl  restart mysqld

   ]# mysql -uroot -p123qqq...A  -e "show databases"
   ]# mysql -uroot -p123qqq...A  -e "flush logs"

   ]# mysql -uroot -p123qqq...A 
      mysql> flush  logs;
      mysql> flush  logs;

   ]# mysqldump -uroot -p123qqq...A  --flush-logs  db3 > /dbbak/db3.sql

		删除已有的日志文件
mysql> purge  master  logs  to  "host50-bin.000003";

mysql> reset  master ;
		
mysql> show  master status;
	

		4、修改日志记录格式
]# vim /etc/my.cnf
 [mysqld]
  binlog_format="mixed"
:wq

]# systemctl restart  mysqld
]# mysql  -uroot -p123qqq...A
mysql> 
mysql> show  variables like  "binlog_format";
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | MIXED |
+---------------+-------+
1 row in set (0.00 sec)

mysql> reset master;
mysql> show  master status;


		5、查看日志内容		
  108  mysqlbinlog /var/lib/mysql/host50-bin.000001 | grep -i create
  109  mysqlbinlog /var/lib/mysql/host50-bin.000001 | grep -i insert
  110  mysqlbinlog /var/lib/mysql/host50-bin.000001 | grep -i select
  111  mysqlbinlog /var/lib/mysql/host50-bin.000001 | grep -i update
  112  mysqlbinlog /var/lib/mysql/host50-bin.000001 | grep -i delete
  113  mysqlbinlog /var/lib/mysql/host50-bin.000001 | grep -i desc

	3.2 修改日志文件的存储位置及文件命令 练习时间6分钟到 09：14
  115  mkdir /mylog
  116  chown  mysql /mylog
  117  ls -ld /mylog/

  118  vim /etc/my.cnf
	  [mysqld]
		binlog_format="mixed"
		server_id=50
		log-bin=/mylog/db50
	:wq

  119  systemctl  restart mysqld
  120  ls /mylog/db50.*
[root@host50 ~]# mysql -uroot  -p123qqq...A
mysql> show  master status;
mysql> select count(*) from db3.user;
mysql>exit

]# mysqldump  -uroot  -p123qqq...A  db3  > /dbbak/db3.sql
]# scp /dbbak/db3.sql  root@192.168.4.51:/root/

192.168.4.51:
	 ]# mysql  -uroot  -p123qqq...A
	 mysql> show databases;
	 mysql> create database db3; (没有库时创建)
	 mysql> exit;
	 ]# mysql  -uroot  -p123qqq...A  db3 < /root/db3.sql
	 ]# mysql  -uroot  -p123qqq...A
	 mysql> select count(*) from db3.user;

192.168.4.50:
	]# mysql  -uroot  -p123qqq...A
	mysql> show  master status;
insert into db3.user(name,uid)values("dc",201)
insert into db3.user(name,uid)values("dc2",201)
insert into db3.user(name,uid)values("dc3",201)
insert into db3.user(name,uid)values("dc4",201)
insert into db3.user(name,uid)values("dc5",201)
	mysql> show master status;
	mysql> select count(*) from db3.user;

		3.3 日志文件如何区分记录的多条SQL命令
			偏移量
			时间点
[root@host50 ~]# scp  /mylog/db50.000001   root@192.168.4.51:/root/

	3.2 使用binlog日志恢复数据
	     命令格式
	     ]# mysqlbinlog  日志文件名   | mysql -uroot -p密码
	     ]# mysqlbinlog 选项  日志文件名 | mysql -uroot -p密码
		选项 
		--start-position=数字 --stop-position=数字 
--start-datetime=“yyyy-mm-dd hh:mm:ss” --stop-datetime="yyyy-mm-dd hh:mm:ss"
[root@mysql51 ~]# mysqlbinlog  /root/db50.000001 | mysql -uroot -p123qqq...A

[root@mysql51 ~]# mysql -uroot -p123qqq...A
mysql> select  count(*) from  db3.user;
mysql> select name from db3.user where name like  'dc%";

		休息到10：15；
192.168.4.50:
mysql> show master status;
mysql> insert into db3.user(name,uid)values("aa",301);
mysql> insert into db3.user(name,uid)values("aaa",301);
mysql> insert into db3.user(name,uid)values("aaaa",301);
mysql> insert into db3.user(name,uid)values("aaaaa",301);
mysql> insert into db3.user(name,uid)values("aaaaaa",301);
mysql> delete  from  db3.user where  name regexp '^aa.*';
mysql> show master status;

[root@host50 ~]# scp /mylog/db50.000001  root@192.168.4.51:/tmp/


192.168.4.51:
[root@mysql51 ~]# mysqlbinlog --start-position=2232 --stop-position=3656  /tmp/db50.000001  |  mysql -uroot  -p123qqq...A

]# mysql -uroot  -p123qqq...A
mysql> select name from  db3.user where name  regexp   '^aa.*';

		练习到 10：46 

192.168.4.50：
[root@mysql50 ~]# mysqlbinlog --start-position=2232 --stop-position=3656  /tmp/db50.000001  |  mysql -uroot  -p123qqq...A

]# mysql -uroot  -p123qqq...A
mysql> select name  from  db3.user where name  regexp   '^aa.*';

+++++RDBMS1_DAY05 -----数据备份与恢复（percona）
1.percona软件介绍

2 在192.168.4.50 主机安装percona软件

]# scp /linux-soft/03/mysql/libev-4.15-1.el6.rf.x86_64.rpm \
> root@192.168.4.50:/root/

]# scp /linux-soft/03/mysql/percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm  root@192.168.4.50:/root/

]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm 
]# yum -y  install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm 
]# rpm -qa  | grep  -i percona
]# rpm -ql percona-xtrabackup-24
]# innobackupex --help
]# man innobackupex

3 使用innobackupex 对数做备份和恢复
	3.1 命令格式
			]# innobackupex  <选项>
	3.2 常用选项
		--user  --password  --no-timestamp --apply-log 
		--copy-back 

	3.3 完全备份与恢复
50 ]#innobackupex  --user root --password 123qqq...A   /allbak --no-timestamp
50 ]# ls  /allbak
50 ]# scp -r  /allbak  root@192.168.4.51:/root/


51 ]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm 
51 ]# yum -y  install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm 

[root@host51 ~]# systemctl  stop mysqld
[root@host51 ~]# rm -rf /var/lib/mysql/*
[root@host51 ~]# ls /var/lib/mysql


[root@host51 ~]# innobackupex  --apply-log  /root/allbak/
]# cat /root/allbak/xtrabackup_checkpoints 
]# innobackupex  --copy-back  /root/allbak/
]# ls /var/lib/mysql -l
]# chown  -R mysql:mysql /var/lib/mysql

]# systemctl  start mysqld
]# mysql -uroot -p123qqq...A
mysql> show databases ;  select  * from db5.a ; select  * from db5.b;

		时间10分钟 到 15：40 

	3.2 恢复完全备份中的单张表

50]# mysql  -uroot  -p123qqq...A
mysql> use db5;
mysql> show tables;
mysql> select  * from a;
mysql> select  * from b;
mysql> delete from b;
mysql> select  * from b; select  * from a;
mysql> show  tables;

	使用备份文件恢复b表的数据

mysql> alter  table db5.b discard  tablespace; 		
mysql> system ls /var/lib/mysql/db5/b.*
mysql> desc b;
mysql> select  * from  b;


]# innobackupex --apply-log --export  /allbak
]# ls /allbak/db5/


]# cp /allbak/db5/b.{cfg,exp,ibd} /var/lib/mysql/db5/
]# chown mysql:mysql /var/lib/mysql/db5/b.*
]# ls -l /var/lib/mysql/db5/b.*

mysql>  alter  table  db5.b  import  tablespace;

mysql> system rm -rf  /var/lib/mysql/db5/b.cfg 
mysql> system rm -rf  /var/lib/mysql/db5/b.exp

mysql> system ls /var/lib/mysql/db5/b.*
/var/lib/mysql/db5/b.frm  /var/lib/mysql/db5/b.ibd
mysql> 
mysql> desc db5.b;
mysql> select  * from  db5.b;

	3.2 增量备份与恢复
	
	增量备份:备份上次备份后，所有新产生的数据。
		
	首备份数据（完全备份）
[root@host50 ~]# innobackupex --user root --password 123qqq...A  /datafull --no-timestamp

[root@host50 ~]# ls /datafull
[root@host50 ~]# cat /datafull/xtrabackup_checkpoints
	第2次备份  （增量备份）
		select  count(*) from db5.a;
		insert into db5.a values(999);//插入多条
		select  count(*) from db5.a;
[root@host50 ~]# innobackupex --user root --password 123qqq...A \
   --incremental /new2dir  --incremental-basedir=/datafull --no-timestamp

[root@host50 ~]# ls /new2dir
[root@host50 ~]# cat /new2dir/xtrabackup_checkpoints
	第3次备份  （增量备份）  
			mysql> select count(*) from db5.a;
			insert into db5.a values(7777);//插入多条	
			mysql> select count(*) from db5.a;

[root@host50 ~]# innobackupex --user root --password 123qqq...A \
--incremental /new3dir  --incremental-basedir=/new2dir --no-timestamp

[root@host50 ~]# ls /new3dir	
[root@host50 ~]# cat /new3dir/xtrabackup_checkpoints
		5分钟 到16:57

[root@host50 ~]# scp -r /datafull  root@192.168.4.51:/root/
[root@host50 ~]# scp -r /new2dir/  root@192.168.4.51:/root
[root@host50 ~]# scp -r /new3dir/  root@192.168.4.51:/root/

	在192.168.4.51 恢复数据
		步骤如下：
	清空数据库目录
[root@host51 ~]# systemctl  stop  mysqld
[root@host51 ~]# rm  -rf /var/lib/mysql/*
[root@host51 ~]# ls /var/lib/mysql/

	准备恢复数据
[root@host51 ~]# innobackupex  --apply-log  --redo-only  /root/datafull

	合并数据
[root@host51 ~]# innobackupex  --apply-log  --redo-only  /root/datafull \
--incremental-dir=/root/new2dir

[root@host51 ~]# innobackupex  --apply-log  --redo-only  /root/datafull \
--incremental-dir=/root/new3dir

	拷贝数据

[root@host51 ~]# innobackupex  --copy-back /root/datafull/
[root@host51 ~]# chown  -R  mysql:mysql  /var/lib/mysql
       启动服务
[root@host51 ~]# systemctl  start mysqld
[root@host51 ~]# 
[root@host51 ~]# mysql -uroot -p123qqq...A
mysql> show  databases;


[root@host51 ~]# rm  -rf  /root/new2dir/
[root@host51 ~]# rm  -rf  /root/new3dir/



